{"docstore/ref_doc_info": {"a1257221-d282-4f8d-9947-3f700592d383": {"node_ids": ["3732e28d-e71f-4d7d-ba7d-a0805f0b7ae4", "1eebecd4-e59d-41e8-9723-20480aad9197"], "metadata": {"filename": "computer.pdf"}}, "d1893b24-7b06-405c-a887-e8591aa2306f": {"node_ids": ["63977760-4cb9-4924-a6d1-07d9b2a8075e", "e376d566-7e18-434f-ad97-f5369a40fa94"], "metadata": {"filename": "computer.pdf"}}, "bc7ed7cc-7917-4e07-a0dd-4185ada8977b": {"node_ids": ["f61c7ded-b3b7-455d-a0c1-9e2b3b0369d6", "c80a0de5-1294-4e89-92fa-67c9035600ba"], "metadata": {"filename": "computer.pdf"}}, "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839": {"node_ids": ["c4081bc3-47e7-433f-a19c-adc995d1e032", "fa3b0e4f-c9b9-47fc-8b84-d2b48e602760"], "metadata": {"filename": "computer.pdf"}}, "30f94de4-5623-4e09-83be-fc5748776393": {"node_ids": ["4095869b-ae76-4ce1-a48c-8d2cea737e51", "10dbabd5-c32a-4e82-9108-24ff0cf8830b"], "metadata": {"filename": "computer.pdf"}}, "640651a2-8207-4d3c-a7eb-08cca1fe6e99": {"node_ids": ["bbd6f0e3-164e-41f5-825e-558c047a08e4", "648d3b03-303b-42c0-a52c-e524e7ebef65"], "metadata": {"filename": "computer.pdf"}}, "be734eda-b84a-4c55-8855-185ae5f36dfb": {"node_ids": ["08cfd150-e98f-44ab-94c6-4e1bfe9395e1"], "metadata": {"filename": "ware.pdf"}}, "e2c783cc-a444-4050-aedb-cf5a274932ab": {"node_ids": ["1ba895ec-efea-4220-b6ef-80ad29f07348", "ab1d3eda-24de-4fe2-8ba1-8ee394ff28b5"], "metadata": {"filename": "computer.pdf"}}, "493bcda4-6b99-4d77-98be-ea4b685e845c": {"node_ids": ["8ce08d25-c8d6-4150-b3a8-747199a09f8a", "66fd7445-28f0-451d-9407-fb6efebdf6bb"], "metadata": {"filename": "computer.pdf"}}, "c0cf3f91-02bc-436b-8add-520fe657819b": {"node_ids": ["1210b008-b4f8-48e9-8c64-8f950f3d84de", "ff210928-9d06-4151-bc13-7dd5e853c4ee"], "metadata": {"filename": "computer.pdf"}}, "4594b5f2-a220-4618-875c-09d449782311": {"node_ids": ["350c5285-fc42-4e2e-bc01-d38d5a35d94e", "4e0373b6-c46f-4c03-ba3e-4072260ab853"], "metadata": {"filename": "computer.pdf"}}, "c6c7287d-21fb-4948-9b52-180c137318b1": {"node_ids": ["e24ba7f6-46a9-4dda-9def-45a67721b786", "69b87dd7-bf49-4d1f-aea6-67e65073cc59"], "metadata": {"filename": "computer.pdf"}}, "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7": {"node_ids": ["d10ba7c5-d413-4a20-ae22-9ad2dea4a089", "8e2ed64f-443a-4ccc-b5a0-1db5f43952dd"], "metadata": {"filename": "computer.pdf"}}, "d8e2994c-91a7-499a-ad27-2d6b07280208": {"node_ids": ["e917b414-e840-4a38-bed9-25f54ed4775c", "9d406574-b8a5-497e-8091-fe644ddc6382", "6cebead5-65b6-4710-b810-e63eab959a54", "77acaa98-3d2f-4ac1-8f60-e59a74188582", "73fb3584-8e07-4415-a94e-2b602f4e58cb", "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9", "0de9a1fd-69e8-4769-9267-c0a2b8fafd56", "a334d951-62b2-4ae8-96cd-9be3f6598c45", "bf32291c-7ee0-4ade-9040-45e016fa7baa", "fcad9eb6-d3df-47f4-8035-e70c734fbe4e", "a725505a-3100-4b26-83eb-3cb7f2c90674", "01e80f2f-e744-4056-b3f7-a2c0862f0815", "160e78ad-fb8d-42c7-9622-41486dfc6908", "f7fb867d-4499-454f-9938-9bacfa5f2256", "f0c5977c-67f9-4f97-82b9-f8d1681f4813", "af6c1554-9f7b-4f1a-8866-22b7d5c2177e", "d485086a-deae-46f3-83f6-836210f8b21a", "8939d10d-1fb1-4adc-83f7-677621637a6b", "f7b6ff9d-a81a-468e-a544-e05022f8f79f", "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913", "1563777f-7a75-49a6-84f3-caa1ea5d6419", "73383c8e-2ce9-4d11-acd6-66f1927b9f79", "31c69716-dd50-4e06-9d48-9721e28311ce", "99dc1d3a-ad27-4f99-9792-0d80f2a044a4", "84523f3d-015b-433e-914f-fcef694a1afa", "73afbf76-da3b-4e43-8d47-d567d3bce4d5", "b16dbabf-14bc-4c5b-8e4a-40b81cf29048", "ec67c4d3-66b9-4f24-9c58-57113ad812ea", "564f3a27-50c9-4436-b690-b44ba03eb60f", "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3", "371aba88-da90-4d25-9654-7dbdfe3f2c1e", "7072d991-c0d7-4229-826e-93ba7378a855", "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0", "ad683f83-3cba-44bc-af68-d626fc046445", "3020acea-f8c9-4c84-af0e-018801cbd300", "ffd91dc4-ddd5-446a-94d4-ff98779c3baf", "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c", "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b", "eea8d6e7-9125-4c8f-be4a-f13c35dd0708", "e4356756-edb8-4cae-8303-9b552d0cb3ac", "471b361c-eb0b-45d8-8153-818941ad81e9", "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea", "b6750083-b00d-4023-aa7d-371978f91439", "abbb2bcb-0df0-4143-a14c-7895a15e889e", "908c1dc9-6dfa-4a90-aab0-5c3163538fe9", "b13c1f4e-ef5e-4017-9132-7cf57795c300", "4878e34e-60dc-42fd-b295-149174ce612d", "90edd788-6a51-465d-ac7f-43cdb03858bd", "63e5606f-f066-432c-8d9e-545a8360819e", "d70c5e94-a178-4781-9306-72327ddac925", "eb04d43a-74bd-444d-a83e-40b0b31571ab", "62fdce68-032b-4fb6-8416-eb8e80f6355c", "78358f6b-7a4e-4985-b1c2-e1a0faa4c691", "647fb88d-c014-48c8-876e-b1463adba515", "3531adac-7db6-4632-8bbb-6279d07252eb", "8671b2f3-590c-460c-accd-6961142fcb40", "48540507-3861-4dfc-9e89-09d8b43532ab", "684dc86a-1b2e-4aaa-bb47-70e07cf9f597", "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac", "965a72af-3845-49b1-b1d5-21712f0d8d8e", "97811389-4a6d-4f81-affe-a73ac5587a08", "d6cde2b4-2390-4003-8c9f-f6a2f529f445", "3b673e4d-93db-4704-bbaa-ff1d467560a8", "0c06a881-d356-48e1-9dbf-319e1489b5ca", "4d278904-a78c-41c6-bac9-7a61c4c21ab4", "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9", "7f263947-7383-43a2-be22-39b99cb5a91f", "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c", "1e029456-2349-4129-8f61-4067cd0657d6", "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e", "0c1df18c-5d92-4290-8cfe-480f9066a379", "6f61084d-df44-4d97-8ff7-2105e6b1e8d2", "8850614d-dd1b-4beb-8219-adf93321ba24", "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb", "787699e2-a516-424a-89d0-03763cc2c216", "8cd4e341-8b13-46d8-bed4-6a984d0cb372", "835f4d37-14db-4be5-bcf9-34bd76c0663d", "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8", "0e003cbb-0a63-4b33-962e-2ce986e02e32", "8c135d63-f222-4db6-baaf-12f3a9e3c452", "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f", "a5b6456b-9069-4290-af6b-5604ef801d32", "d0d23288-1f8f-4206-b143-2d27443330a0", "bf2ceb5d-f329-47ac-87f2-eef545fbb54f", "4f25b662-1891-4305-9079-4ab2e2170813", "24375d55-a978-4c4e-90a4-d8beb35572bb", "36d409f7-601b-47d5-9472-deefdf8e3697", "9b817c53-525b-4cb5-990f-eb8332c6627e"], "metadata": {"filename": "soft.pdf"}}, "ed0eb801-6a0c-4316-8882-4e98a3e4d178": {"node_ids": ["75516d67-96c6-43da-b89e-8e4d52e6a546", "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee", "f0cf1cb0-3124-4086-92a8-42e9a44bcda6", "e9400b64-c39b-4322-9e3a-833b07693f82", "c5a590e6-1666-45e9-8bac-80410e976250", "6284572f-7815-45df-a826-663f5593a7d1", "bee753c9-767e-4a9b-9c26-be8c2c94c0e5", "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a", "06607e52-c67e-4b9b-8888-d67eaf66b14c", "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04", "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760", "e8fe1fc0-cc49-44f2-9bd9-7c030716d637", "f126d84f-d078-45b5-ac88-cc45423d1ad3", "f5723f22-83cc-491d-b119-a74c448dceaa", "29c4130d-4a8f-42c3-9f6c-83eee33e9c77", "777ebdba-4ab9-4e95-a585-c670b16d9353", "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e", "a759a57f-61f7-4325-a448-57876fef0e48", "3b40ad02-ea55-4fc5-9749-5002848e5e89", "19f001be-31d3-4844-88e7-a2d0e988d470", "9bf26669-ce55-49ba-90fd-b14ff8bd7f98", "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0", "f30f2602-a16c-4487-8c4b-bcafab8959b4", "b1a9726d-ec99-4834-970d-5f151350e4e7", "b7dc2c22-2136-4b93-9585-28ed9a27df46", "d51d616a-59b2-446e-a90a-62b5768c9948", "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32", "f910cc61-52c5-4ad7-b537-a5033fcddf73", "ca460780-de4d-4596-abca-57b8306cce6f", "d8d48aae-3f6f-4321-bbdc-689c17b657af", "04d37175-a2ff-4c7f-963c-0b0566728f32", "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3", "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a", "f4504b97-2ace-4b7f-8028-5f7955354fa6", "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76", "80528e67-82c1-4c11-bb96-2379ea8e806c", "d47afd40-e451-438f-b54e-5a7e3b201736", "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427", "e2c603ea-be17-435f-85f0-669563edc427", "912bf6d7-38ff-4919-9a08-dc5a12963b40", "e4c44a77-716c-48e0-bf88-d2945929a9a6", "4baec4eb-bb89-4e9f-92eb-d560c1fe0255", "d1e38ebb-1373-4b28-bd0e-5a468441430e", "1da6a96c-8932-4b3d-a98a-1548d255fcc4", "36e52a11-8c7d-4c84-aa6f-a87b09c220c4", "3478af1b-c91f-4cbe-8293-10136e7c4e2e", "84302560-fc91-4f75-961e-51a723ec130b", "39c3b979-b7a0-43c6-b06a-92172d3c1d6c", "7bc0102f-be1d-4787-a7c5-5dde3d0527c7", "94351431-31da-41da-9a05-fac85280d386", "e7c345aa-3114-4a76-94c1-6df680d972d7", "c4f9b63a-d006-4ecf-beed-4648424b17f1", "7448f40b-b826-4777-a93c-cba0253fb59f", "716ebf8f-074c-4c50-91e4-39cc655b3c10", "a4829875-4df5-4215-bdc3-21c4dbcc8d88", "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d", "0bfc9fd9-2fd1-4288-8add-d5869e074b74", "2d35f180-3f10-4e08-9917-3b0fe4587833", "cac64d6e-536a-4c25-b078-89bd17dfef59", "d06932a8-b777-482b-9c1c-2d42fb497a46", "4a7089d1-ad69-4272-a3b9-000029dced56", "03b32e81-c345-498d-aa38-548d034c71c7", "7955dc08-67b9-494a-b986-394ceab886fd", "5fafacf9-f6ce-4140-a5d8-a6b865f91762", "174d8f90-db6d-451e-9c85-a550145bb064", "214472ca-989c-40f7-82ed-9b57efb4be8d", "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f", "b272cead-cccd-4b2a-a02d-4503b1471c0a", "8fd746b2-4f60-48bc-81c2-493d1162296e", "8cfb2b9c-859b-4436-947d-7b1620d50f87", "3260bd06-1d45-4647-b57d-4eba192c5dce", "20fc74ca-3f29-4f9a-856c-72f9009a628b", "bf63c7a4-df67-4efe-b646-b868485d22e9", "791b77f1-2ca2-486c-bd66-71802f54fc54", "d575640e-ff6e-4f34-837d-306d6513c110", "9e195c5d-fe0e-46fe-90e8-20296a8a6060", "9b851148-f6e6-457d-99ef-c6b72f9d5dbf", "a8425034-f811-4497-97b0-743a9adde769", "98784a66-39d0-4b81-87fa-d17cab9bc243", "62d1a6fd-dccf-46be-9ac6-3480e0e17366", "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3", "7575763a-6c7c-43b2-ab8c-c338f3d2c814", "6d2b4279-ac2f-4ae4-821d-a15d1657c534", "105c5646-761f-45e7-8258-7cedb52c3476", "3e149501-6908-4ec1-8a3e-a7d0605e0bbb", "41153092-1ab6-4b2f-a285-996a158b0fd1", "9dc6567c-8023-4a0c-9003-60c93a5e38a4", "eb97c706-3f5b-43c3-ad73-15b59b6a0f10"], "metadata": {"filename": "soft.pdf"}}, "2903c3cd-8969-489e-8da5-879efdb715a1": {"node_ids": ["44cf0c46-fd99-4b63-a73a-e529582e8f90"], "metadata": {"filename": "ware.pdf"}}}, "docstore/data": {"3732e28d-e71f-4d7d-ba7d-a0805f0b7ae4": {"__data__": {"id_": "3732e28d-e71f-4d7d-ba7d-a0805f0b7ae4", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a1257221-d282-4f8d-9947-3f700592d383", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1eebecd4-e59d-41e8-9723-20480aad9197", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1eebecd4-e59d-41e8-9723-20480aad9197": {"__data__": {"id_": "1eebecd4-e59d-41e8-9723-20480aad9197", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a1257221-d282-4f8d-9947-3f700592d383", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3732e28d-e71f-4d7d-ba7d-a0805f0b7ae4", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "63977760-4cb9-4924-a6d1-07d9b2a8075e": {"__data__": {"id_": "63977760-4cb9-4924-a6d1-07d9b2a8075e", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d1893b24-7b06-405c-a887-e8591aa2306f", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e376d566-7e18-434f-ad97-f5369a40fa94", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e376d566-7e18-434f-ad97-f5369a40fa94": {"__data__": {"id_": "e376d566-7e18-434f-ad97-f5369a40fa94", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d1893b24-7b06-405c-a887-e8591aa2306f", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63977760-4cb9-4924-a6d1-07d9b2a8075e", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f61c7ded-b3b7-455d-a0c1-9e2b3b0369d6": {"__data__": {"id_": "f61c7ded-b3b7-455d-a0c1-9e2b3b0369d6", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bc7ed7cc-7917-4e07-a0dd-4185ada8977b", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c80a0de5-1294-4e89-92fa-67c9035600ba", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c80a0de5-1294-4e89-92fa-67c9035600ba": {"__data__": {"id_": "c80a0de5-1294-4e89-92fa-67c9035600ba", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bc7ed7cc-7917-4e07-a0dd-4185ada8977b", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f61c7ded-b3b7-455d-a0c1-9e2b3b0369d6", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c4081bc3-47e7-433f-a19c-adc995d1e032": {"__data__": {"id_": "c4081bc3-47e7-433f-a19c-adc995d1e032", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fa3b0e4f-c9b9-47fc-8b84-d2b48e602760", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fa3b0e4f-c9b9-47fc-8b84-d2b48e602760": {"__data__": {"id_": "fa3b0e4f-c9b9-47fc-8b84-d2b48e602760", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4081bc3-47e7-433f-a19c-adc995d1e032", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4095869b-ae76-4ce1-a48c-8d2cea737e51": {"__data__": {"id_": "4095869b-ae76-4ce1-a48c-8d2cea737e51", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "30f94de4-5623-4e09-83be-fc5748776393", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "10dbabd5-c32a-4e82-9108-24ff0cf8830b", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "10dbabd5-c32a-4e82-9108-24ff0cf8830b": {"__data__": {"id_": "10dbabd5-c32a-4e82-9108-24ff0cf8830b", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "30f94de4-5623-4e09-83be-fc5748776393", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4095869b-ae76-4ce1-a48c-8d2cea737e51", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bbd6f0e3-164e-41f5-825e-558c047a08e4": {"__data__": {"id_": "bbd6f0e3-164e-41f5-825e-558c047a08e4", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "640651a2-8207-4d3c-a7eb-08cca1fe6e99", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "648d3b03-303b-42c0-a52c-e524e7ebef65", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "648d3b03-303b-42c0-a52c-e524e7ebef65": {"__data__": {"id_": "648d3b03-303b-42c0-a52c-e524e7ebef65", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "640651a2-8207-4d3c-a7eb-08cca1fe6e99", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bbd6f0e3-164e-41f5-825e-558c047a08e4", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "08cfd150-e98f-44ab-94c6-4e1bfe9395e1": {"__data__": {"id_": "08cfd150-e98f-44ab-94c6-4e1bfe9395e1", "embedding": null, "metadata": {"filename": "ware.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "be734eda-b84a-4c55-8855-185ae5f36dfb", "node_type": "4", "metadata": {"filename": "ware.pdf"}, "hash": "a775c0e2ac9adad67a980853a63a173d1ea908bfd597ba881dd3c9721bef47ad", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q1. What is Software Engineering?\nA1. Software Engineering is a systematic, disciplined, and quantifiable approach to the\ndevelopment, operation, and maintenance of software.\nQ2. What are the phases of the Software Development Life Cycle (SDLC)?\nA2. The main phases include: 1) Requirements Gathering, 2) Design, 3) Implementation, 4) Testing,\n5) Deployment, and 6) Maintenance.\nQ3. What is Requirement Engineering?\nA3. Requirement Engineering is the process of defining, documenting, and maintaining the\nrequirements in the engineering design process.\nQ4. What is Agile methodology?\nA4. Agile is an iterative approach to software development that emphasizes flexibility, collaboration,\nand customer feedback.Q5. What is Extreme Programming (XP)?\nA5. XP is a type of Agile software development that takes effective practices to extreme levels like\ncontinuous integration, test-first programming, and pair programming.\nQ6. What is the difference between verification and validation?\nA6. Verification checks if the software meets the specified requirements, while validation checks if\nthe software meets the business needs.\nQ7. What is System Engineering?\nA7. System Engineering is an interdisciplinary field that focuses on designing and managing\ncomplex systems over their life cycles.\nQ8. What is a Use Case Diagram?\nA8. A Use Case Diagram is a UML diagram that shows the interactions between a system and its\nexternal entities (actors) to achieve a goal.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1456, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1ba895ec-efea-4220-b6ef-80ad29f07348": {"__data__": {"id_": "1ba895ec-efea-4220-b6ef-80ad29f07348", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2c783cc-a444-4050-aedb-cf5a274932ab", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ab1d3eda-24de-4fe2-8ba1-8ee394ff28b5", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ab1d3eda-24de-4fe2-8ba1-8ee394ff28b5": {"__data__": {"id_": "ab1d3eda-24de-4fe2-8ba1-8ee394ff28b5", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "e2c783cc-a444-4050-aedb-cf5a274932ab", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1ba895ec-efea-4220-b6ef-80ad29f07348", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8ce08d25-c8d6-4150-b3a8-747199a09f8a": {"__data__": {"id_": "8ce08d25-c8d6-4150-b3a8-747199a09f8a", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "493bcda4-6b99-4d77-98be-ea4b685e845c", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "66fd7445-28f0-451d-9407-fb6efebdf6bb", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "66fd7445-28f0-451d-9407-fb6efebdf6bb": {"__data__": {"id_": "66fd7445-28f0-451d-9407-fb6efebdf6bb", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "493bcda4-6b99-4d77-98be-ea4b685e845c", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8ce08d25-c8d6-4150-b3a8-747199a09f8a", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1210b008-b4f8-48e9-8c64-8f950f3d84de": {"__data__": {"id_": "1210b008-b4f8-48e9-8c64-8f950f3d84de", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c0cf3f91-02bc-436b-8add-520fe657819b", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ff210928-9d06-4151-bc13-7dd5e853c4ee", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ff210928-9d06-4151-bc13-7dd5e853c4ee": {"__data__": {"id_": "ff210928-9d06-4151-bc13-7dd5e853c4ee", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c0cf3f91-02bc-436b-8add-520fe657819b", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1210b008-b4f8-48e9-8c64-8f950f3d84de", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "350c5285-fc42-4e2e-bc01-d38d5a35d94e": {"__data__": {"id_": "350c5285-fc42-4e2e-bc01-d38d5a35d94e", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4594b5f2-a220-4618-875c-09d449782311", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4e0373b6-c46f-4c03-ba3e-4072260ab853", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4e0373b6-c46f-4c03-ba3e-4072260ab853": {"__data__": {"id_": "4e0373b6-c46f-4c03-ba3e-4072260ab853", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "4594b5f2-a220-4618-875c-09d449782311", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "350c5285-fc42-4e2e-bc01-d38d5a35d94e", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e24ba7f6-46a9-4dda-9def-45a67721b786": {"__data__": {"id_": "e24ba7f6-46a9-4dda-9def-45a67721b786", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c6c7287d-21fb-4948-9b52-180c137318b1", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "69b87dd7-bf49-4d1f-aea6-67e65073cc59", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "69b87dd7-bf49-4d1f-aea6-67e65073cc59": {"__data__": {"id_": "69b87dd7-bf49-4d1f-aea6-67e65073cc59", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c6c7287d-21fb-4948-9b52-180c137318b1", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e24ba7f6-46a9-4dda-9def-45a67721b786", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d10ba7c5-d413-4a20-ae22-9ad2dea4a089": {"__data__": {"id_": "d10ba7c5-d413-4a20-ae22-9ad2dea4a089", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8e2ed64f-443a-4ccc-b5a0-1db5f43952dd", "node_type": "1", "metadata": {}, "hash": "097b3a0052ef5c66d5d5e8c64d982169dcd3bdb6344a2a63a4363c282b38ee21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1.what are different types of software testing? Explain briefly?  \nSoftware Testing can be classified into two types:  \n1. Manual Testing  \n2. Automation Testing  \n1. Manual Testing  \n\u2022 Manual testing is a technique to test the software that is carried out using the functions and features of an application.  \n\u2022 In this testing, testers make test cases for the codes, test the software, and give the final report about that software.  \n\u2022 Manual testing is time -consuming because it is done by humans, and there is a chance of human errors.  \nAdvantages of Manual Testing:  \n\u2022 Fast and accurate visual feedback: It detects almost every bug in the software application and is used to test the \ndynamically changing GUI designs like layout, text, etc.  \n\u2022 Less expensive: It is less expensive as it does not require any high -level skill or a specific type of tool.  \n\u2022 No coding is required: No programming knowledge is required while using the black box testing method. It is easy to learn \nfor the new testers.  \n\u2022 Efficient for unplanned changes:  Manual testing is suitable in case of unplanned changes to the application, as it can be \nadopted easily.  \n2. Automation Testing  \n\u2022 Automated Testing  is a technique where the Tester writes scripts on their own and uses suitable Software or Automation \nTool to test the software.  \n\u2022 It is an Automation Process of a Manual Process. It allows for executing repetitive tasks without the intervention of a Manua l \nTester.  \nAdvantages of Automation Testing:  \n\u2022 Simplifies Test Case Execution: Automation testing can be left virtually unattended and thus it allows monitoring of the \nresults at the end of the process. Thus, simplifying the overall test execution and increasing the efficiency of the applicat ion.  \n\u2022 Improves Reliability of Tests: Automation testing ensures that there is equal focus on all the areas of the testing, thus \nensuring the best quality end product.  \n\u2022 Increases amount of test coverage:  Using automation testing, more test cases can be created and executed for the \napplication under test. Thus, resulting in higher test coverage and the detection of more bugs. This allows for the testing o f \nmore complex applications and more features can be  tested.  \n\u2022 Minimizing Human Interaction: In automation testing, everything is automated from test case creation to execution thus \nthere are no changes for human error due to neglect. This reduces the necessity for fixing glitches in the post -release phase.  \n2. Explain in detail about white Box Testing and Black Box Testing. Differentiate black box testing and white box testing?  \nWhite Box Testing:  \nWhite Box Testing, also known as Clear Box Testing, Open Box Testing, or Structural Testing, is a testing \ntechnique where the internal structure, design, and implementation details of the software under test are \nknown to the tester.  \nTechniques used in White Box Testing:  \n1. Statement Coverage:  It ensures that each statement in the code is executed at least once during \ntesting.  \n2. Branch Coverage:  This technique ensures that all branches or decision points in the code are \nexecuted at least once during testing.  \n3. Path Coverage:  It aims to test every possible path through the software. This is the most \ncomprehensive but also the most time -consuming technique.  \n4. Condition Coverage:  It ensures that all logical conditions in the code are evaluated to both true and \nfalse.  \n5. Loop Coverage:  This technique focuses on testing loops in the code, ensuring that all possible loop \niterations are executed.  \nBlack Box Testing:  \nBlack Box Testing, also known as Behavioral Testing or Functional Testing, is a testing technique where \nthe internal structure, design, and implementation details of the software under test are not known to the \ntester.  \nTechniques used in Black Box Testing:  \n1.Equivalence Partitioning:  It divides the input domain of a program into classes of data from which test \ncases can be derived.  \n2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4777, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8e2ed64f-443a-4ccc-b5a0-1db5f43952dd": {"__data__": {"id_": "8e2ed64f-443a-4ccc-b5a0-1db5f43952dd", "embedding": null, "metadata": {"filename": "computer.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7", "node_type": "4", "metadata": {"filename": "computer.pdf"}, "hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d10ba7c5-d413-4a20-ae22-9ad2dea4a089", "node_type": "1", "metadata": {"filename": "computer.pdf"}, "hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "2.Boundary Value Analysis:  It focuses on testing the boundaries between equivalence classes.  \n3.Decision Table Testing:  It involves creating a table that shows combinations of inputs and \ncorresponding actions or outputs.  \n4.State Transition Testing:  It is used when the system behavior can be described in terms of states and \ntransitions between those states.  \n5.Use Case Testing:  It involves testing the entire system based on its specified use cases.  \n3. What is Debugging? Discuss debugging process in software testing.  \nDebugging  is the process of identifying and resolving errors or bugs, in a software system.  \nProcess of Debugging  \nThe steps involved in debugging are:  \n \n1.Identify Error  \nIdentifying errors early saves time. Mistakes in identification waste time. Customer site bugs are hard to find. Correct \nidentification saves time and prevents user site errors.  \n2. Identify the Error Location  \nAfter identifying an error, we need to identify the exact location in the code where an error occurs. Identifying the exact \nlocation that leads to errors can help to fix the problem faster.  \n3. Analyze Error  \nYou must use an appropriate approach to analyze the error at this stage. This will help you to understand the problem. This \nstage is critical as solving one error may lead to another.  \n4. Prove the Analysis  \nOnce the identified error has been analyzed, you must focus on other software errors. This process involves test automation, \nwhere you need to write the test cases through the test framework.  \n5. Cover Lateral Damage  \nUnit test all modified code. If all pass, proceed; if not, fix failing tests. In Fix and Validate stage, resolve all bugs and \nretest thoroughly.  \n6.  Fix & Validate  \nThe final stage is fix and validation, which focuses on resolving defects before running all of the test scripts to determine  if \nthey pass.  \n4.Define Alfa and beta testing? Differentiate Alfa and Beta testing.  \nAlpha Testing:  Internal testing for identifying bugs and usability issues.  \nBeta Testing:  External testing by users for real -world feedback.  \n \n \n \n \n \n5. Calculate cyclomatic complexity of a flow graphs by all three methods.  \nChromatic Number: - The minimum numbers of colors is requri ed to color all the vertice s of a given graph \n \nMethod1                Method -2    Method -3 \n V(G)= P+1=1+1=2             V(G)= E -N+2=7 -7+2=2   V(G) =R+1=1+1=2  \n \nMethod 1     Method -2    Method -3 \nV(G)=P+1=1+1=2    V(G)=E -N+2     V(G)=R+1  \n                                                            =7-7+2=2            =1+1=2  \n \n \n \n \n \n \n6.What are different levels of Software testing? Explain briefly?  \nSoftware testing is typically categorized into different levels , each serving a specific purpose and \nconducted at different stages of the software development lifecycle. The common levels of software \ntesting include:  \n1.Unit Testing  \no Involves testing individual components or modules of the software in isolation.  \no Aimed at ensuring that each unit performs as expected.  \no Conducted by developers and often automated.  \n2.Integration Testing:  \no Focuses on testing the interactions between different modules or components of the software.  \no Ensures that integrated units work together as intended.  \no Helps identify interface defects and integration issues.  \n3.System Testing:  \no Tests the entire system as a whole to verify that it meets specified requirements.  \no Evaluates the system's compliance with functional and non -functional requirements.  \no Conducted in an environment similar to the production environment.  \n4.Acceptance Testing:  \no Involves testing the software from the end -users' perspective to determine whether it meets their needs \nand expectations.  \no Validates that the software satisfies the acceptance criteria defined by stakeholders.  \no Can be conducted as alpha testing (by internal users) or beta testing (by external users).", "mimetype": "text/plain", "start_char_idx": 3989, "end_char_idx": 7934, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e917b414-e840-4a38-bed9-25f54ed4775c": {"__data__": {"id_": "e917b414-e840-4a38-bed9-25f54ed4775c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9d406574-b8a5-497e-8091-fe644ddc6382", "node_type": "1", "metadata": {}, "hash": "783fd65c7d5852a22f31c8bb7b965b4437bb29c9dd21479848858f23183f37b2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1   \n \n \n \n \n \n \n \nDEPARTMENT OF COMPUTER SCIENCE & ENGINEERING  \n \n \nCS8494 \nSOFTWARE ENGINEERING  \nQuestion Bank  \nIII YEAR A & B / BATCH : 2017  -21\n2  \n  \n \nSYLLABUS  \n \n \nCS 8494 - SOFTWARE ENGINEERING  \n \n \n \n \nUNIT I - SOFTWARE PROCESS AND  PROJECT  MANAGEMENT  9 \nIntroduction to Software E ngineering, Software Process, Perspective and Specialized Process \nModels . Introduction to Agility -Agile process -Extreme programming -XP Process.  \nUNIT II -REQUIREMENTS ANALYSIS  AND SPECIFICATION  9 \nSoftware Requirements:Functional and Non -Functional, User requ irements, System \nrequirements,Software Requirements Document \u2013Requirement Engineering Process: Feasibility \nStudies,Requirements elicitation and analysis, requirements validation, requirements management - \nClassicalanalysis: Structured system Analysis, Petri  Nets-Data Dictionary  \nUNIT  III-SOFTWARE DESIGN  9 \nDesign process \u2013Design Concepts -Design Model \u2013Design Heuristic \u2013Architectural Design \u2013 \nArchitectural styles, Architectural Design, Architectural Mapping using Data Flow -User nterface \nDesign: Interface analysi s, Interface Design \u2013Component levelDesign: Designing Class based \ncomponents, traditional Components  \nUNIT IV -TESTING  AND  IMPLEMENTATION  9 \nSoftware testing fundamentals -Internal and external views of Testing -white box testing -basis \npathtesting -control stru cture testing -black box testing -Regression Testing \u2013Unit Testing \u2013\n3  \n IntegrationTesting  \u2013Validation  Testing  \u2013System  Testing  And Debugging  \u2013Software \nImplementationTechniques: Coding  practices -ING \n \n \n \n \nUNIT V  -PROJECT  MANAGEMENT  9 \n \n \nEstimation \u2013FP Based, LOC Ba sed, Make/Buy Decision, COCOMO II -Planning \u2013Project Plan, \nPlanning Process, RFP Risk Management \u2013Identification, Projection,RMMM -Scheduling and \nTracking \u2013Relationship between people and effort, Task Set & Network, Scheduling, EVA \u2013 \nProcessand Project Met rics \n \n \nTEXT BOOKS  \n\uf0b7 Roger S. Pressman,  \u201cSoftware Engineering  \u2013 A practitioner\u2019s  Approach\u201d,  Sixth  Edition,  \nMcGraw -Hill International Edition, 2005  \n\uf0b7 Ian Sommerville, \u201cSoftware engineering\u201d, Seventh Edition, Pearson Education Asia, 2007.  \n \n \n \nREFERENCES:  \n \n1. Rajib  Mall, \u2015Fundamentals of Software Engineering\u2016, Third Edition, PHI Learning \nPrivateLimited, 2009.  \n2. PankajJalote, \u2015Software Engineering, A Precise Approach\u2016, Wiley  India, \n2010.  \n3. Kelkar S.A., \u2015Software Engineering\u2016, Prentice Hall of India Pvt Ltd, 2007.  \n4. Steph en R.Schach, \u2015Software Engineering\u2016, Tata McGraw -Hill Publishing Company  \nLimited,2007.\n4  \n  \nINDEX PAGE  \n \n \n \n \nUNIT   \nREFERENCE BOOK   \nPAGE \nNUMBER  \n \nI Roger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGraw -Hill International Edi tion, 2010  1- 212 \n \n \nII Roger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGraw -Hill International Edition,  2010  220- 294 \n \nIII  \nRoger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGr aw-Hill International Edition,  2010  311- 357 \n \nIV  \nIan Sommerville, \u2015Software Engineering\u2016, 9th Edition, Pearson Education Asia, 2011  360- 427 \n \nV  \nIan Sommerville, \u2015Software Engineering\u2016, 9th Edition, Pearson Education Asia, 2011  663- 771 \n \n \n \n \n \n \n \n5  \n  \nUNIT \u2013 1 \nPART \u2013A \nS.NO  QUESTIONS  \n1 Write down the generic  process framework that is applicable to any software project / \nrelationship between work product, task, activity and system NOV/DEC -\n10,NOV/DEC2016,  NOV/DEC  2017  \nCommon process frame work  \n- Process frame work  activities  \n- Umbrella activities  \n- Frame work  activit ies \n- Task  sets \n2 List the goals  of software  engineering?  APR/MAY -11 \nSatisfy user requirements , High reliability , Low maintenance cost , Delivery on time , Low \nproduction cost , High performance , Ease of reuse.  \n3 What is the difference between verificat ion and validation?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3923, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9d406574-b8a5-497e-8091-fe644ddc6382": {"__data__": {"id_": "9d406574-b8a5-497e-8091-fe644ddc6382", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e917b414-e840-4a38-bed9-25f54ed4775c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0f719e162a73e966b7633fa6714cc9b8526bb7a24c7ac555d2c6d4ff1159d031", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6cebead5-65b6-4710-b810-e63eab959a54", "node_type": "1", "metadata": {}, "hash": "57d57e9679f0fba613978ca4f6708c6af0605875cff8ec1fa957e99ee1d601f5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "APR/MAY -11 \nSatisfy user requirements , High reliability , Low maintenance cost , Delivery on time , Low \nproduction cost , High performance , Ease of reuse.  \n3 What is the difference between verificat ion and validation? NOV/DEC -10 , APR/MAY -11 \n, NOV/DEC -11, MAY/JUN -13 \n\uf0b7 Verification refers to the set of activities that ensure that software correctly implements  \na specific  function.  Verification : \"Are  we building  the product  \nright?\"  \n \uf0b7 Validation refers to a different set of activities that ensure that the software that  has \nbeen built is traceable  to customer  requirements.  Validation : \"Are  \nwe building the right product?\"  \n6  \n 4 For the scenario described below, which life cycle model would you choose? Give the \nreason why you would choose this model. NOV/DEC -11 , \nYou are interacting with the MIS department of a very large oil company with multiple \ndepartments. They have a complex regency system. Migrating the data from this legacy \nsystem is not an easy task and wo uld take a considerable time. The oil company is very \nparticular about processes, acceptance criteria and legal contracts.  \nSpiral  model  Proactive problem prevention. Each iteration has a risk analysis,   \nsector   that   evaluates.  Alternatives for proactiv e problem  \navoidance.  \n5 Give two reasons why system engineers must understand the environment of a system? \nAPR/MAY -12 \n \n1. The reason for the existence of a system is to make some changes i its  \nenvironment.  \n \n2. The functioning of a system can be very difficult to  predict.  \n6 What are the two types of software products? APR/MAY -12 \n1. Generic products: these are stand -alone systems that are produced by a development  \nOrganization and sold in the open market to any customer who wants to buy it.  \n2. Customized products: these  are systems that are commissioned by a specific customer  \nand developed specially by some contractor to meet a special need.  \n7 What is the advantage of adhering to life cycle models for software? NOV/DEC -12 \nIt helps  to produce  good  quality  software  produc ts without  time and cost over  \nruns.It  encourages the development  of software in  a systematic  & disciplined  \n manner.  \n7  \n 8 Is it always possible to realize win -win spiral model for software? Justify.  \nNOV/DEC -12 \n \n \no Must identify stake holder and their win  condition  \no Developing buy -in to the model is important than the model itself  \no Eliminating the clashes between customers is important.  \n9 What is software process? List its activities. MAY/JUN -13 \nSoftware process is defined as the structured set of activities that are required to \ndevelop the software  system.  \nActivities \u2013 Specification, design & implementation, validation & evolution.  \n10 What are the various categories of software?  \n\uf0b7 System  software  \n\uf0b7 Application  software  \n\uf0b7 Engineering/Scientific software  \n\uf0b7 Embedded  software  \n\uf0b7 Web Applications  \n\uf0b7 Artificial Intelligence  software  \n11 What are the umbrella activities of a software process? APR/MAY 2015  \n\uf0b7 Software project tracking and  control.  \n\uf0b7 Risk management.  \n\uf0b7 Software Quality  Assurance.  \n\uf0b7 Formal Technical  Reviews.  \n\uf0b7 Software Configu ration  Management.  \n\uf0b7 Work product preparation and  production.  \n\uf0b7 Reusability  management.  \n\uf0b7 Measurement  \n12 What are the merits of incremental model?  \ni. The incremental model can be adopted when tere are less number of people involved \nin the project.  \n8  \n  ii. Technical r isks can be managed with each  increment.  \niii. For a very small time span,at least core product can be delivered to the customer.  \n13 List the task regions in the Spiral  model . \n\uf0b7 Customer communication \u2013 In this region it is suggested to establish customer  \ncommuni cation.  \n\uf0b7 Planning \u2013 All planning activities are carried out in order to define resources timeline \nand otherproject related  activities.  \n\uf0b7 Risk analysis \u2013 The tasks required to calculate technical and management risks.  \n\uf0b7 Engineering \u2013 In this the task region,task s required to build one or more representations \nof applications are carried  out. \n\uf0b7 Construct  and release  \u2013 All the necessary  tasks  required  to \nconstruct,test,install the applications are conducted. \u00be_Customer  evaluation  \n\u2013 Customer\u201f s feedback is obtained and  based on the customer  evaluation  \nrequired tasks are performed and implemented at installation stage.", "mimetype": "text/plain", "start_char_idx": 3700, "end_char_idx": 8108, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6cebead5-65b6-4710-b810-e63eab959a54": {"__data__": {"id_": "6cebead5-65b6-4710-b810-e63eab959a54", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9d406574-b8a5-497e-8091-fe644ddc6382", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7e249cdb42f4f885a9d658a8d891a88557d6d908a006240af964743aac617c84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "77acaa98-3d2f-4ac1-8f60-e59a74188582", "node_type": "1", "metadata": {}, "hash": "dbcd47db370dd81519f2140ba8cf0da671ba9539ea76589e5d605808b2773524", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Technical r isks can be managed with each  increment.  \niii. For a very small time span,at least core product can be delivered to the customer.  \n13 List the task regions in the Spiral  model . \n\uf0b7 Customer communication \u2013 In this region it is suggested to establish customer  \ncommuni cation.  \n\uf0b7 Planning \u2013 All planning activities are carried out in order to define resources timeline \nand otherproject related  activities.  \n\uf0b7 Risk analysis \u2013 The tasks required to calculate technical and management risks.  \n\uf0b7 Engineering \u2013 In this the task region,task s required to build one or more representations \nof applications are carried  out. \n\uf0b7 Construct  and release  \u2013 All the necessary  tasks  required  to \nconstruct,test,install the applications are conducted. \u00be_Customer  evaluation  \n\u2013 Customer\u201f s feedback is obtained and  based on the customer  evaluation  \nrequired tasks are performed and implemented at installation stage.  \n14 Characteristics  of software  contrast  to characteristics  of hardware?  \nAPR/MAY 2016  \n \no Software is easier to change than hardware. The cost of change is much higher for \nhardware than for  software.  \no Software products evolve through multiple releases by adding new features and re -\nwriting existing logic to support the new features. Hardware products consist of physical \ncomponents that cannot be \u201crefactored\u201d aft er manufacturing, and cannot add new \ncapabilities that require hardware changes.  \no Specialized hardware components can have much longer lead times for acquisition than \nis true for  software.  \no Hardware design is driven by architectural decisions. More of the ar chitectural work \nmust be done up front compared to software  products.  \no The cost of development for software products is relatively flat over  time.  \n9  \n  However, the cost of hardware development rises rapidly towards the end of the \ndevelopment cycle.  \no Testing software commonly requires developing thousands of test cases. Hardware \ntesting involves far fewer  tests.  \nHardware must be designed and tested to work over a range of time and environmental \nconditions, which is not the case for software.  \n15 List the proce ss maturity levels in SEIs CMM. NOV/DEC2015  \nLevel 1:Initial \u2013 Few processes are defined and individual efforts are taken. Level \n2:Repeatable \u2013 To track cost schedule and functionality basic project management \nprocesses are established.  \nLevel 3:Defined \u2013 The p rocess is standardized, documented and followed.  \nLevel 4:Managed \u2013 Both the software process and product are quantitatively understood \nand controlled using detailed measures.  \n16 What does Verification represent?  \nVerification represents the set of activitie s that are carried out to confirm that the \nsoftware correctly implements the specific  functionality.  \n17 What does Validation represent?  \nValidation represents the set of activities that ensure that the software that has been \nbuilt is satisfying the custome r requirements.  \n10  \n 18 What are the steps followed in testing?  MAY/JUNE 2016  \ni. Unit testing \u2013 The individual components are tested in this type of  testing.  \nii. Module testing \u2013 Related collection of independent components  are \ntested.  \niii. Sub-system testing \u2013 This is a kind of integration testing. Various modules  are \nintegrated into a subsystem and the whole subsystem is tested.  \niv. System testing \u2013 The whole system is tested in this system.  \nv. Acceptance  testing  \u2013 This type of testing  involves  testing  of the system  \nwith custom er data.If the system behaves as per customer need then it is accepted.  \n19 State  the  advantages  and disadvantages in LOC based cost estimation? APR/MAY \n2015  \n \nAdvantages of LOC  \n \n       It is straight forward  (simple)  \n \n       Easily can be automated (pl enty of tools are  available)  \n \nDisadvantages of LOC  \n \n       Its Language dependent  \n \n       Penalizes the well designed short  programs  \n \n       Cannot easily accommodate nonprocedural  languages  \n \n       Need a level of detail that may not be available at t he early stages of development.  \n11  \n 20 What is requirement engineering?  \n \nRequirement engineering is the process of establishing the services that the customer requires \nfrom the system and the constraints under which it operates and  \nis developed.  \n21 What are the various types of traceability in software engineering?  \n \ni. Source traceability \u2013 These are basically the links from requirement to stakeholders who \npropose these  requirements.  \n \nii . Requirements traceability \u2013 These are links between dependant  requirements.  \n \niii . Design traceability \u2013 These are links from requirements to  design.  \n22 If you have to develop a word processing software product, what process models will you \nchoose? Justify your answer.", "mimetype": "text/plain", "start_char_idx": 7177, "end_char_idx": 11979, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "77acaa98-3d2f-4ac1-8f60-e59a74188582": {"__data__": {"id_": "77acaa98-3d2f-4ac1-8f60-e59a74188582", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6cebead5-65b6-4710-b810-e63eab959a54", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "682cdf13bef3d73bc631be28bdc09b887609da7619d1d0b790dc240deb19db02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73fb3584-8e07-4415-a94e-2b602f4e58cb", "node_type": "1", "metadata": {}, "hash": "a9dbe4620d09d80a32889388bdde3bf30038c6bbdcb9d09a1cb99854d26b8131", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "11  \n 20 What is requirement engineering?  \n \nRequirement engineering is the process of establishing the services that the customer requires \nfrom the system and the constraints under which it operates and  \nis developed.  \n21 What are the various types of traceability in software engineering?  \n \ni. Source traceability \u2013 These are basically the links from requirement to stakeholders who \npropose these  requirements.  \n \nii . Requirements traceability \u2013 These are links between dependant  requirements.  \n \niii . Design traceability \u2013 These are links from requirements to  design.  \n22 If you have to develop a word processing software product, what process models will you \nchoose? Justify your answer. NOV/DEC 2016  \nWe will choose the incremental model for word processing  software. It focuses on  \n the aspects of the word processing software that are visible to the customer / end  \nuser. The feedback is used to refine the prototype.  \n23 What led to the transition from product to process oriented development in software \nengine ering? APR/MAY 2016  \n \nProduct techniques to designing software - Large numbers of software projects do not meet \ntheir expectations in terms of functionality, cost, or delivery schedule. Proces s - Composed of \nline practitioners who have varied skills, the group is at the center of the collaborative effort \nof everyone in the organization who is involved with software engineering process  \nimprovement.  \n \nProcess -oriented view on cooperating software components based on the concepts and \nterminology of a language/action perspective on cooperative work provides a more suitable \nfoundation for the analysis, design and implementation of software  \ncomponents in business applications.  \n12  \n 24 What are the advantag es and disadvantages of iterative software development model  \nNOV/DEC 2015  \nAdvantages  \n In iterative model we can only create a high -level design of the application before we \nactually begin to build the product and define the design solution for the entire  product.  \n Building and improving the product step by  step.  \n \n can get the reliable user  feedback  \n \n Less time is spent on documenting and more time is given for  designing.  \n \nDisadvantages  \n \n Each phase of an iteration is rigid with no overlaps  \n Costly system architec ture or design issues may arise because not all requirements are \ngathered up front for the entire  lifecycle  \n25 What are the issues in measuring the software size using LOC as metric NOV/DEC 2015, \nNOV/DEC 2017  \n \n\uf0b7 Lack of Accountability.  \n\uf0b7 Lack of Cohesion with  Functionality.  \n\uf0b7 Adverse Impact on  Estimation.  \n\uf0b7 Difference in Languages.  \n\uf0b7 Advent of GUI Tools  \n\uf0b7 Lack of Counting  Standards.  \n26 What is System Engineering? April/may 2018  \nSystem Engineering means designing, implementing, deploying and operating systems which \ninclude hardware, software and people.  \n27 What is the use of CMM? NOV/DEC2015  \nCapability Maturity Model is used in assessing how well an organization\u2019s  \nprocesses allow to complete and ma nage new software projects.  \n13  \n 28 What is meant by Software engineering paradigm?  \nThe development strategy that encompasses the process, methods and tools and generic phases \nis often referred to as a process model or software engineering  \nparadigm.  \n29 Define  agility and agile team. April /May  2015  \n\uf06e Agility -Effective (rapid and adaptive) response to change (team members, new \ntechnology,  requirements)  \n\uf06e Effective communication in structure and attitudes among all team members, \ntechnological and business people, so ftware engineers and managers \u3002 \n\uf06e Drawing the customer into the team. Eliminate \u201cus and them\u201d  attitude.  \nPlanning in an uncertain world has its limits and plan must be flexible.  \n\uf06e Organizing a team so that it is in control of the work  performed  \n\uf06e The development g uidelines stress delivery over analysis and design although these \nactivates are not discouraged, and active and  continuous  \n communication between developers and customers  \n\uf06e Eliminate all but the most essential work products and keep them  lean.  \nEmphasize an incremental delivery strategy as opposed to intermediate products that gets \nworking software to the customer as rapidly as  feasible  \n30 Write any two characteristics of software as a product. April /May 2015  \n1. Software is developed or engineered, it is not m anufactured in the classical  sense  \n2. Software doesn't \"wear  out.\"  \n3. Although the industry is moving toward component -based assembly, most software \ncontinues to be custom built.  \n31 Write the IEEE definition of software engineering .", "mimetype": "text/plain", "start_char_idx": 11272, "end_char_idx": 15915, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73fb3584-8e07-4415-a94e-2b602f4e58cb": {"__data__": {"id_": "73fb3584-8e07-4415-a94e-2b602f4e58cb", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "77acaa98-3d2f-4ac1-8f60-e59a74188582", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a72a9979ec82634e2e3a2e3cc6129bb1ee62ba82f27060ba9f928d199829272f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9", "node_type": "1", "metadata": {}, "hash": "a5d91005c46688b33db104174012079600e0af29e3887e640e7e94c34a6adef7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf06e Organizing a team so that it is in control of the work  performed  \n\uf06e The development g uidelines stress delivery over analysis and design although these \nactivates are not discouraged, and active and  continuous  \n communication between developers and customers  \n\uf06e Eliminate all but the most essential work products and keep them  lean.  \nEmphasize an incremental delivery strategy as opposed to intermediate products that gets \nworking software to the customer as rapidly as  feasible  \n30 Write any two characteristics of software as a product. April /May 2015  \n1. Software is developed or engineered, it is not m anufactured in the classical  sense  \n2. Software doesn't \"wear  out.\"  \n3. Although the industry is moving toward component -based assembly, most software \ncontinues to be custom built.  \n31 Write the IEEE definition of software engineering . NOV/DEC 2017  \nAccording to IEEE's definition software engineering can be defined as the \napplication of a systematic, disciplined, quantifiable approach to the development, operation, \nand maintenance of software , and the study of these approaches; that is, the application of \nengineeri ng to software . \n14  \n 32 List two deficiencies in waterfall model . Which process model do you suggest to \novercome each deficiency. APRIL/MAY 2017  \n\uf0b7 Once an application is in the testing  stage, it is very difficult to go back and change \nsomething that was not well -thought out in the concept  stage.  \n\uf0b7 No working software is produced until late during the life cycle.  \n33 What is Agile?  \nThe word \u2018agile\u2019 means \u2212  \n\uf0b7 Able to move your body quickly and  easily.  \n\uf0b7 Able to think quickly and  clearly.  \nIn business, \u2018agile\u2019 is used for describing ways of planning and doing work wherein it is \nunderstood that making changes as needed is an important part o f the job. Business\u2018agililty\u2019 \nmeans that a company is always in a position to take account of the market  changes.  \nIn software development, the term \u2018agile\u2019 is adapted to mean \u2018the  \nability to respond to changes \u2212 changes from Requirements, Technology and Pe ople.\u2019  \n34 What is Agile Manifesto?  \nThe Agile Manifesto states that \u2212  \nWe are uncovering better ways of developing software by doing it and helping others do it. \nThrough this work, we have come to value \u2212  \n\uf0b7 Individuals and interactions over processes and  tools. \n \n\uf0b7 Working software over comprehensive  documentation.  \n \n\uf0b7 Customer collaboration over contract  negotiation.  \n \n\uf0b7 Responding to change over following a  plan.  \nThat is, while there is value in the items on the right, we value the items on the left  more.  \n15  \n 35 What ar e the Characteristics of Agility?  \nfollowing are the characteristics of Agility \u2212  \n\uf0b7 Agility in Agile Software Development focuses on the culture of the whole team with multi -discipline, \ncross -functional teams that are empowered and  selforganizing.  \n\uf0b7 It fosters shared responsibility and  accounta bility.  \n \n\uf0b7 Facilitates effective communication and continuous  collaboration.  \n \n\uf0b7 The whole -team approach avoids delays and wait  times.  \n \n\uf0b7 Frequent and continuous deliveries ensure quick feedback that in in turn enable the team align to the  \nrequirements.  \n\uf0b7 Collabora tion facilitates combining different perspectives timely in implementation, defect fixes and \naccommodating  changes.  \n36 What are the principles of of agile methods? Customer \ninvolvement  \nCustomers should be closely involved throughout the development proces s. Their role  \nis provide and prioritize new system requirements and to evaluate the iterations of the  \n System.  \nIncremental delivery  \nThe software is developed in increments with the customer specifying the requirements to be included in each \nincrement.  \nPeople not process  \nThe skills of the development team should be recognized and exploited. Team members should be left to \ndevelop their own ways of working without prescriptive processes.  \nEmbrace  change  \nExpect the system requirements to change and so design th e system to accommodate these changes.  \nMaintain simplicity  \nFocus on simplicity in both the software being developed and in the development process. Wherever \npossible, actively work to eliminate complexity from the system.  \n37 What are the Problems with agi le methods?  \n \n\uf0b7 It can be difficult to keep the interest of customers who are involved in the  process.  \n\uf0b7  Team members may be unsuited to the intense involvement that characterizes agile methods.  \n\uf0b7 Prioritizing changes can be difficult where there are multiple  stakeholders . \n\uf0b7 Maintaining simplicity requires extra  work.  \n\uf0b7 Contracts may be a problem as with other approaches to iterative  development.", "mimetype": "text/plain", "start_char_idx": 15051, "end_char_idx": 19748, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9": {"__data__": {"id_": "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73fb3584-8e07-4415-a94e-2b602f4e58cb", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "3c4309adb267750364d7c6e6c9fcb96d9db00cff18711244ab382b36733fe415", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0de9a1fd-69e8-4769-9267-c0a2b8fafd56", "node_type": "1", "metadata": {}, "hash": "d18e67e46c300ada690f54733a0377c257c28ca3d54f51cb130795083518e4c6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "People not process  \nThe skills of the development team should be recognized and exploited. Team members should be left to \ndevelop their own ways of working without prescriptive processes.  \nEmbrace  change  \nExpect the system requirements to change and so design th e system to accommodate these changes.  \nMaintain simplicity  \nFocus on simplicity in both the software being developed and in the development process. Wherever \npossible, actively work to eliminate complexity from the system.  \n37 What are the Problems with agi le methods?  \n \n\uf0b7 It can be difficult to keep the interest of customers who are involved in the  process.  \n\uf0b7  Team members may be unsuited to the intense involvement that characterizes agile methods.  \n\uf0b7 Prioritizing changes can be difficult where there are multiple  stakeholders . \n\uf0b7 Maintaining simplicity requires extra  work.  \n\uf0b7 Contracts may be a problem as with other approaches to iterative  development.  \n16  \n 38 What is Extreme Programming?  \nXP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop a software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development me thodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self-organize. \nExtreme Programming provides specific core practices where  \u2212 \n\uf0b7 Each practice is simple and  self-complete.  \n \n\uf0b7 Combination of practices produces mor e complex and emergent behavior.  \n39 HOW Embrace Change happens in Extreme programming?  \nA key assumption of Extreme Programming is that the cost of changing a program can be held \nmostly constant over time.  \nThis can be achieved with \u2212  \n\uf0b7 Emphasis on continuous  feedback from the  customer  \n \n\uf0b7 Short  iterations  \n \n\uf0b7 Design and  redesign  \n \n\uf0b7 Coding and testing  frequently  \n \n\uf0b7 Eliminating defects early, thus reducing  costs  \n \n\uf0b7 Keeping the customer involved throughout the development  \n \n\uf0b7 Delivering working product to the  customer  \n17  \n 40 How Extreme Programming usedin a Nutshell?  \nExtreme Programming involves \u2212  \n\uf0b7 Writing unit tests before programming and keeping all of the tests running at all times. The \nunit tests are automated and eliminate defects early, thus reducing the costs.  \n\uf0b7 Starting with a simple design just enough to code the  features at hand and redesigning when  \nrequired.  \n\uf0b7 Programming in pairs (called pair programming), with two programmers at one screen, \ntaking turns to use the keyboard. While one of them is at the keyboard, the other constantly \nreviews and provides  inputs.  \n\uf0b7 Integrating and testing the whole system several times a  day. \n41 Why is it called \u201cExtreme?  \nExtreme Programming takes the effective principles and practices to extreme levels.  \n \n \uf0b7 Code reviews are effective as the code is reviewed all the  time.  \n \n\uf0b7 Testing is effective as there is continuous regression and  testing.  \n \n\uf0b7 Design is effective as everybody needs to do refactoring  daily.  \n \n\uf0b7 Integration testing is important as integrate and test several times a day.  \n\uf0b7 Short iterations are effective as the planning game for r elease planning and iteration  planning.  \n18  \n 42 What are the E xtreme Programming Advantages?  \nExtreme Programming solves the following problems often  faced  \nin the software development projects \u2212  \n\uf0b7 Slipped schedules \u2212 and achievable development cycles  ensure  \ntimely deliveries.  \n \n\uf0b7 Cancelled projects \u2212 Focus on continuous customer involvement ensures transparency with the \ncustomer and immediate resolution of any  issues. \n\uf0b7 Costs incurred in changes \u2212 Extensive and ongoing testing makes sure the changes do not break the \nexisting functionality. A running working system always ensures sufficient time for accommodating \nchanges such that the current operations are not  affect ed. \n\uf0b7 Production and post -delivery defects: Emphasis is on \u2212 the  unit \ntests to detect and fix the defects early.  \n43 What is Scrum ?  \nThe Scrum approach is a general agile method but its focus is on managing iterative \ndevelopment rather than specific agile pr actices. There are three phases in Scrum:  \n \n1.  The initial phase is an outline planning phase where you establish the general \nobjectives for the project and design the software  architecture.  \n2. This is followed by a series of sprint cycles, where each cycle deve lops an \n increment of the system.  \n3.  The project closure phase wraps up the project, completes required documentation \nsuch as system help frames and user manuals and assesses  the lessons learned from the  \nproject.  \n19  \n 44 What are the Advantages of scrum ?", "mimetype": "text/plain", "start_char_idx": 18803, "end_char_idx": 23598, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0de9a1fd-69e8-4769-9267-c0a2b8fafd56": {"__data__": {"id_": "0de9a1fd-69e8-4769-9267-c0a2b8fafd56", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f4fe093d05e935c4b86db62e17e432eb802826ff6ca06b4cd9a86028348e1c00", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a334d951-62b2-4ae8-96cd-9be3f6598c45", "node_type": "1", "metadata": {}, "hash": "d5420ee4cc735bec57371ae34bd434f28f9323424e40085e4b6a5de7a37524d4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Production and post -delivery defects: Emphasis is on \u2212 the  unit \ntests to detect and fix the defects early.  \n43 What is Scrum ?  \nThe Scrum approach is a general agile method but its focus is on managing iterative \ndevelopment rather than specific agile pr actices. There are three phases in Scrum:  \n \n1.  The initial phase is an outline planning phase where you establish the general \nobjectives for the project and design the software  architecture.  \n2. This is followed by a series of sprint cycles, where each cycle deve lops an \n increment of the system.  \n3.  The project closure phase wraps up the project, completes required documentation \nsuch as system help frames and user manuals and assesses  the lessons learned from the  \nproject.  \n19  \n 44 What are the Advantages of scrum ?  \n \n\uf0b7  The product is broken down into a set of manageable and understandable chunks . \n\uf0b7 Unstable requirements do not hold up progress . \n\uf0b7  The whole team has visibility of everything and consequently team \ncommunication is improved.  \n\uf0b7  Customers see on-time delivery of increments and gain feedback on  how the \nproduct  works.  \n\uf0b7  Trust between customers and developers is established and a positive culture is \ncreated in which everyone expects the project to  succeed.  \n45. Mention the Two perspectives on scaling of agile methods?  \n1. Scaling  up \n2. Scaling  out \n46. What is Scaling up  \nUsing agile methods for developing large software systems that cannot be developed by a \nsmall team. For large systems development, it is not possible to focus only on the code of the \nsystem; you need to do mor e up- front design and system documentation. Cross -team \ncommunication mechanisms have to be designed and used, which should involve regular phone \nand video conferences between team members and frequent, short electronic meetings where \nteams update each oth er on progress. Continuous integration, where the whole system is built \nevery time any developer checks in a change, is practically impossible; however, it is essential  \nto maintain  frequent  system  builds  and regular  releases  of the \nsystem.  \n47. What is Scaling out.  \nHow agile methods can be introduced across a large organization with many years of software \ndevelopment experience. Project managers who do not have experience of agile methods may \nbe reluctant to accept the risk of a new approach. Large organiza tions often have quality \nprocedures and standards that all projects are expected to follow and, because of their \nbureaucratic nature, these are likely to be incompatible with agile methods. Agile methods \nseem to work best when team members have a relativel y high skill level. However, within large  \norganizations,  \nthere are likely to be a wide range of skills and abilities.  \n20  \n \n \n \n \n \n \n48.  \n \n \n \n \nDraw the diagram of Extreme programming?  \n49 What is a gile development?  \nSpecification, design, implementation and testing a re inter -leaved and the outputs from the \ndevelopment process are decided through a process of negotiation during the software \ndevelopment process.  \nprojects include elements of plan -driven and agile processes. Deciding on the balance depends \non many technic al, human, and organizational issues . \n50. What is Scrum master?  \nThe role of the Scrum Master is to protect the development team from external distractions. At \nthe end of the sprint the work done is reviewed and presented to  \nstakeholders (including the pro duct owner).  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n21  \n PART \u2013B \n \n \n \n \n \n1 Explain  the  following:  (i)  waterfall  model  (ii)  Spiral  model  \n(iii)RAD   model   (iv)  Prototyping  model.  NOV/DEC -12, \nNOV/DEC -15, \n\uf0b7 A Project management methodology based on a  sequential design  proces s \n\uf0b7 Finishes one phase before another phase can  begin \n \n\uf0b7 SDLC  Model  \n \n\uf0b7 Linear Sequential  Model  \n \n\uf0b7 Simple to understand and easy to  implement  \nWaterfall model phases  \n There are separate identified phases in the waterfall  model:  \n1. Requirements analysis and  definition  \n2. System and software  design  \n3. Implementation and unit  testing  \n4. Integration and system  testing  \n5. Operation and  maintenance  \n The main drawback of the waterfall model is the difficulty of accommodating change after the \nprocess is underway. In principle, a phase has t o be complete before moving onto the next  phase.  \n(ii)SPIRAL MODEL  \nThe spiral model is divided into number of frame works. These frameworks are  \n22  \n denoted by task regions.", "mimetype": "text/plain", "start_char_idx": 22800, "end_char_idx": 27327, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a334d951-62b2-4ae8-96cd-9be3f6598c45": {"__data__": {"id_": "a334d951-62b2-4ae8-96cd-9be3f6598c45", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0de9a1fd-69e8-4769-9267-c0a2b8fafd56", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "37ee44dec0a027e0d597ceff5bd6e401d2cbe1c3aee637fab21c2683d71c4190", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf32291c-7ee0-4ade-9040-45e016fa7baa", "node_type": "1", "metadata": {}, "hash": "6d01d8b0c1e1f80c03d6e4e2bb19ef6e81c897fb75fdab3fec6a706946fc8740", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Requirements analysis and  definition  \n2. System and software  design  \n3. Implementation and unit  testing  \n4. Integration and system  testing  \n5. Operation and  maintenance  \n The main drawback of the waterfall model is the difficulty of accommodating change after the \nprocess is underway. In principle, a phase has t o be complete before moving onto the next  phase.  \n(ii)SPIRAL MODEL  \nThe spiral model is divided into number of frame works. These frameworks are  \n22  \n denoted by task regions.  \nUsually there are six task regions. In spiral model project entry point axis is  \ndefined.  \nThe task regions are:  \n1. Customer communication ,Planning Risk analysis., Engineering, Construct and release and \nCustomer evaluation.  \n\uf0b7 Drawbacks  \n1. It is based on customer communication.  \n2. It demands considerable risk assessment.  \n \n \n \n \n \n \n \n \nIt was original ly proposed by Barry Boehm, the spiral model is an evolutionary \nsoftware process model that couples the iterative nature of prototyping with the \ncontrolled and systematic aspects of the waterfall  model.  \n23  \n \n It provides the potential for rapid development of increasingly more  complete versions of the software.  \n The spiral  model  can be adopted  to apply  throughout  the entire  lifecycle  of the \napplication from concept development to  maintenance.  \n The spiral model is divided into set of framework activities defined by  software \nengineering  team.  \n The initial activity is shown from centre and developed in  clockwise direction.  \n \nAdvantages  \n\uf0b7 In this approach, the project monitoring is easy  and more  effective compared  to other  models.  \n\uf0b7 It reduces the number of risk in software  development before they become serious  problem.  \n\uf0b7 Suitable for very high  risk. \n\uf0b7 Schedule and cost is more  realistic.  \n\uf0b7 Risk management is in -built in the spiral  model.  \n\uf0b7 Changes can be accommodated in th e later   \n\uf0b7 stages  \n \n(iii) RAD Model  \nRAD or Rapid Application Development process is an adoption of the waterfall model; it targets at \ndeveloping software in a short span of time. RAD follows the iterative  \nSDLC RAD model has following phases  \niv. Business Modeling  \nv. Data Modeling  \nvi . Process Modeling  \nvii . Application Generation  \nviii . Testing and Turnover  \n24  \n \n \niv) Prototyping Model  \n Prototype methodology is defined as a Software Development model in which a prototype is built, \ntest, and then reworked when needed until an acceptable pr ototype is achieved. It also creates a base to \nproduce the final system.  \nSoftware prototyping model works best in scenarios where the project's requirements are not known. It is \nan iterative, trial, and error method which take place between the developer a nd the client  \n \nOften, a customer defines a set of general objectives for sof tware,  but does not identify detailed \nrequirements for functions and features.  \n In this case Prototyping is best suited  \n Prototyping can be used together with other models for e licitation requirements  \n The prototype can serve as \u201cthe first system.\u201d  \n Some prototypes are \u201cThrow Away\u201d while others also evolve become part of the actual \nsystem.  \n Both customers and developers like the prototyping paradigm.  \ni. Customer/End user gets a f eel for the actual  system  \n25  \n ii. Developer get to build something  immediately.  \n2 Discuss the various life cycle models in software development? APR/MAY -16 \n\uf0b7 The Software Development Lifecycle (SDLC)  is a systematic process for building software that \nensures the q uality and correctness of the software built.  \n\uf0b7 SDLC process aims to produce high -quality software which meets customer expectations.  \n\uf0b7 The system development should be complete in the pre -defined time frame and cost.  \nDLC consists of a detailed plan which ex plains how to plan, build, and maintain specific software. Every \nphase of the SDLC lifecycle has its own process and deliverables that feed into the next phase.  \n \n\uf0b7 Phase 1: Requirement collection and analysis  \n\uf0b7 Phase 2: Feasibility study:  \n\uf0b7 Phase 3: Design:  \n\uf0b7 Phase 4: Coding:  \n\uf0b7 Phase 5: Testing:  \n\uf0b7 Phase 6: Installation/Deployment:  \n\uf0b7 Phase 7: Maintenance:  \nPhase 1: Requirement collection and analysis:  \nThe requirement is the first stage in the SDLC process. It is conducted by the senior team members with \ninputs from all th e stakeholders and domain experts in the industry. Planning for the quality assurance \n26  \n requirements and recognization of the risks involved is also done at this stage.", "mimetype": "text/plain", "start_char_idx": 26823, "end_char_idx": 31359, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bf32291c-7ee0-4ade-9040-45e016fa7baa": {"__data__": {"id_": "bf32291c-7ee0-4ade-9040-45e016fa7baa", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a334d951-62b2-4ae8-96cd-9be3f6598c45", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1c5f9951b2cdbd54e59c678916a744b54ac3cae2b8eae42ac90ed1535f2867e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fcad9eb6-d3df-47f4-8035-e70c734fbe4e", "node_type": "1", "metadata": {}, "hash": "ec9c08565c5c22d8f8c8a172d536766bef8fd1f9d8fb032df5f7a7719c5567e2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "DLC consists of a detailed plan which ex plains how to plan, build, and maintain specific software. Every \nphase of the SDLC lifecycle has its own process and deliverables that feed into the next phase.  \n \n\uf0b7 Phase 1: Requirement collection and analysis  \n\uf0b7 Phase 2: Feasibility study:  \n\uf0b7 Phase 3: Design:  \n\uf0b7 Phase 4: Coding:  \n\uf0b7 Phase 5: Testing:  \n\uf0b7 Phase 6: Installation/Deployment:  \n\uf0b7 Phase 7: Maintenance:  \nPhase 1: Requirement collection and analysis:  \nThe requirement is the first stage in the SDLC process. It is conducted by the senior team members with \ninputs from all th e stakeholders and domain experts in the industry. Planning for the quality assurance \n26  \n requirements and recognization of the risks involved is also done at this stage.  \nThis stage gives a clearer picture of the scope of the entire project and the anticipated  issues, opportunities, \nand directives which triggered the project.  \nRequirements Gathering stage need teams to get detailed and precise requirements. This helps companies to \nfinalize the necessary timeline to finish the work of that system.  \nPhase 2: Feasib ility study:  \nOnce the requirement analysis phase is completed the next step is to define and document software needs. \nThis process conducted with the help of 'Software Requirement Specification' document also known as 'SRS' \ndocument. It includes everything  which should be designed and developed during the project life cycle.  \nThere are mainly five types of feasibilities checks:  \n\uf0b7 Economic:  Can we complete the project within the budget or not?  \n\uf0b7 Legal:  Can we handle this project as cyber law and other regulatory framework/compliances.  \n\uf0b7 Operation feasibility:  Can we create operations which is expected by the client?  \n\uf0b7 Technical:  Need to check whether the current computer system can support the software  \n\uf0b7 Schedule:  Decide that the project can be completed within the give n schedule or not.  \nPhase 3: Design:  \nIn this third phase, the system and software design documents are prepared as per the requirement \nspecification document. This helps define overall system architecture.  \nThis design phase serves as input for the next phas e of the model.  \nThere are two kinds of design documents developed in this phase:  \nHigh -Level Design (HLD)  \n(a) Brief description and name of each module  \n(b) An outline about the functionality of every module  \n(c) Interface relationship and dependencies between modules  \n(d) Database tables identified along with their key elements  \n(e) Complete architecture diagrams along with technology details  \nLow-Level Design(LLD)  \n\uf0b7 Functional logic of the modules  \n27  \n \uf0b7 Database tables, which include type and size  \n\uf0b7 Complete detail of the interface  \n\uf0b7 Addresse s all types of dependency issues  \n\uf0b7 Listing of error messages  \n\uf0b7 Complete input and outputs for every module  \nPhase 4: Coding:  \nOnce the system design phase is over, the next phase is coding. In this phase, developers start build the \nentire system by writing code using the chosen programming language. In the coding phase, tasks are \ndivided into units or modules and assigned to the various developers. It is the longest phase of the Software \nDevelopment Life Cycle process.  \nIn this phase, Developer needs to follow cer tain predefined coding guidelines. They also need to use \nprogramming tools like compiler, interpreters, debugger to generate and implement the code.  \nPhase 5: Testing:  \nOnce the software is complete, and it is deployed in the testing environment. The testing  team starts testing \nthe functionality of the entire system. This is done to verify that the entire application works according to the \ncustomer requirement.  \nDuring this phase, QA and testing team may find some bugs/defects which they communicate to develop ers. \nThe development team fixes the bug and send back to QA for a re -test. This process continues until the \nsoftware is bug -free, stable, and working according to the business needs of that system.  \nPhase 6: Installation/Deployment:  \nOnce the software testin g phase is over and no bugs or errors left in the system then the final deployment \nprocess starts. Based on the feedback given by the project manager, the final software is released and \nchecked for deployment issues if any.  \nPhase 7: Maintenance:  \nOnce the s ystem is deployed, and customers start using the developed system, following 3 activities occur  \n\uf06e Bug fixing - bugs are reported because of some scenarios which are not tested at all  \n\uf06e Upgrade - Upgrading the application to the newer versions of the Software  \n\uf06e Enhancement - Adding some new features into the existing software  \n3 What is the difference between information engineering & product engineering?", "mimetype": "text/plain", "start_char_idx": 30598, "end_char_idx": 35347, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fcad9eb6-d3df-47f4-8035-e70c734fbe4e": {"__data__": {"id_": "fcad9eb6-d3df-47f4-8035-e70c734fbe4e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf32291c-7ee0-4ade-9040-45e016fa7baa", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "05eb74e4165685ae01b66be80509343ed00bd64586b140611ab15bb73cb7c7d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a725505a-3100-4b26-83eb-3cb7f2c90674", "node_type": "1", "metadata": {}, "hash": "0544cef42f5f378ef0e5affc89a28f47667dd2fe0e12df1018011d30f419065d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The development team fixes the bug and send back to QA for a re -test. This process continues until the \nsoftware is bug -free, stable, and working according to the business needs of that system.  \nPhase 6: Installation/Deployment:  \nOnce the software testin g phase is over and no bugs or errors left in the system then the final deployment \nprocess starts. Based on the feedback given by the project manager, the final software is released and \nchecked for deployment issues if any.  \nPhase 7: Maintenance:  \nOnce the s ystem is deployed, and customers start using the developed system, following 3 activities occur  \n\uf06e Bug fixing - bugs are reported because of some scenarios which are not tested at all  \n\uf06e Upgrade - Upgrading the application to the newer versions of the Software  \n\uf06e Enhancement - Adding some new features into the existing software  \n3 What is the difference between information engineering & product engineering? Also explain the \nproduct engineering hierarchy in detail.  MAY/JUN -13 \n28  \n Product engineering   \n\uf0b7 It refers to the pro cess of designing and developing a device, assembly, or system such that it is \nproduced as an item for sale through some production  manufacturing  process.  \n\uf0b7 Product  engineering  usually entails activity dealing with issues of cost, producibility, quality, \nperformance, reliability, serviceability, intended lifespan and user features.  \n\uf0b7 These product characteristics are generally all sought in the attempt to make the resulting product \nattractive to its intended  market  and a successful contributor to the business  of the organization that \nintends to offer the product to that market.  \n\uf0b7  It includes design, development and transitioning to manufacturing of the product. The term \nencompasses developing the concept of the product and the design and development of its \nmech anical, electronics and  software  components.  \n\uf0b7  After the initial design and development is done, transitioning the product to manufacture it in \nvolumes is considered part  of product engineering.  \n\uf0b7 Product engineers are the technical interface between the comp onent development team and the \nproduction side (Front End and Back End), especially after the development phase and qualifications \nwhen the high volume production is running.  \n\uf0b7 Product engineers improve the product quality and secure the product reliability by balancing the \ncost of tests and tests coverage that could impact the production fall -off. They support failure \nanalysis request from customers.  \n\uf0b7 For example, the engineering of a  digital camera  would include defining the feature set, design of the \noptics , the mechanical and  ergonomic design  of the packaging, developing the electronics that \ncontrol the various component and developing the software that allows the user to see the pictures, \nstore them in memory and download them to a  computer . \n\uf0b7 Product engine ering is an  engineering  discipline that deals with both design \nand manufacturing  aspects of a product.  \nThe job requires the product engineer to have a very good working knowledge of:  \n\uf0b7 Statistical methods and tools  \n\uf0b7 Manufacturing process  \n\uf0b7 Software, hardware an d systems implementation  \n\uf0b7 Product reliability and qualification  \n\uf0b7 Physical analysis methods  \n\uf0b7 Computer -aided design  and simulation programs  \n\uf0b7 Specific technology  \n\uf0b7 Strong product Knowledge  \n29  \n  \uf0b7 Strong analytic work methodology and problem solving skills  \n\uf0b7 Continuous Impro vement Knowledge  \nInformation engineering  (IE) \n\uf0b7 It also known as  Information technology engineering  (ITE), information engineering \nmethodology  (IEM ) or data engineering , is a software engineering  approach to designing and \ndeveloping  information systems . \n\uf0b7 Information technology engineering involves an architectural approach for planning, analyzing, \ndesigning, and implementing applications.  \n\uf0b7 It has been defined by Steven M Davis as: \"An integrated and evolutionary set of tasks and \ntechniques that enhance busines s communication throughout an enterprise enabling it to develop \npeople, procedures and systems to achieve its vision  \nThere are two variants of information technology engineering. These are called the DP -driven variant and \nthe business -driven variant.  \n\uf0b7 DP-driven:  The DP -driven variant of information technology engineering was designed to enable IS \nDepartments to develop information systems that satisfied the information needs of the 1980s - \nwhich was largely a DP -driven development environment. Most of the CA SE tools available today \nsupport this DP -driven variant of ITE.  \ni. Business -driven:  ITE was extended into strategic business planning for the business -driven variant \nof information technology engineering. This variant was designed for rapid change in the clie nt/server, \nobject -oriented environment of the business -driven 1990's.  \nBTL6  \n4 (a ) List the principles of agile software development.", "mimetype": "text/plain", "start_char_idx": 34411, "end_char_idx": 39370, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a725505a-3100-4b26-83eb-3cb7f2c90674": {"__data__": {"id_": "a725505a-3100-4b26-83eb-3cb7f2c90674", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fcad9eb6-d3df-47f4-8035-e70c734fbe4e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a5710797cc3bc01de2e185abe042d2394867b3342a57565f18b2814268697610", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "01e80f2f-e744-4056-b3f7-a2c0862f0815", "node_type": "1", "metadata": {}, "hash": "9c27082dc9f5fb0251cd3fa353ad1206f0a29f07293ed6a82bbc7ec8fe16fe06", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These are called the DP -driven variant and \nthe business -driven variant.  \n\uf0b7 DP-driven:  The DP -driven variant of information technology engineering was designed to enable IS \nDepartments to develop information systems that satisfied the information needs of the 1980s - \nwhich was largely a DP -driven development environment. Most of the CA SE tools available today \nsupport this DP -driven variant of ITE.  \ni. Business -driven:  ITE was extended into strategic business planning for the business -driven variant \nof information technology engineering. This variant was designed for rapid change in the clie nt/server, \nobject -oriented environment of the business -driven 1990's.  \nBTL6  \n4 (a ) List the principles of agile software development.  NOV/DEC 2016  \n1. It describes a set of principles for software development  where,  \nRequirements  and solutions  evolve  through  the collaborative  effort  of self- \n(b) organizing + cross -functional teams  \n(c) It advocates  \nAdaptive  planning  \n1. Evolutionary  development  \n2. Early  delivery  \n3. Continuous  improvement  \n4. Encourages rapid and flexible response to  change  \n(d) These principles support the definition and cont inuing evolution of many software development \nmethods  \n30  \n  (e ) Every project needs to be handled differently  \nExisting methods need to be tailored  to best suit the project requirements  \n(f) Tasks are  divided to time boxes (small time frames) to deliver specific feature s for a  release  \n(g ) Iterative approach is taken &  working software build is delivered after each  iteration  \n(h) Agile Model Pros and Cons  \n(i )  It widely accepted in the software world  recently, however, this method may not always be suitable for all \nproducts.  \n(j)  \n(k) Pros  (l ) Cons \n(m ) Is a very realistic approach to software  \ndevelopment  \n(n) Promotes teamwork and cross  training.  \n(o ) Functionality can be developed rapidly  \nanddemonstrated.  \n(p) Resource requirements are  minimum.  \n(q) Suitable  for fixed  or changing  \nrequirements  \n(r ) Delivers early partial  workingsolutions.  \n(s ) Good  model  for environments  that \nchange  steadily.  \n(t) Minimal  rules,  documentation  easily  \nemployed.  \n(u) Enables concurrent development and \ndelivery within  an \n(v ) overall planned context.  \n(w ) Little or no planning  required  \n(x ) Easy to  manage  \n(y ) Gives flexibility t o developers  (z ) Not suitable  for handling  complex  \ndependencies.  \n(aa ) More  risk of sustainability,  \nmaintainability  and extensibility.  \n(bb) An overall plan, an agile leader and agile \nPM practice is  a \n(cc ) must without which it will not work.  \n(dd) Strict delivery management dictate s the \nscope, functionality to be delivered, and \nadjustments to meet the deadlines.  \n(ee ) Depends  heavily  on customer  interaction,  \nso if customer  is not clear, team can be \ndriven in the wrong  direction.  \n(ff) There is very high individual dependency, \nsince there is min imum documentation  \ngenerated.  \n(gg ) Transfer  of technology  to new team  \nmembers  may be quite  challenging  due \nto lack of documentation.  \n(hh)  \n(i i )  \n(jj)  \n(kk)  \n \n(l l )  \n(mm)  \n \n31  \n \u2022 \n \n \n \n(nn)  \n(oo )  \n(pp)  \n(qq)  \n(rr )  \n(ss )  \n(tt)  \n(uu)  \n(vv )  \n(ww ) Each build is incremental in terms  of features  \n(xx ) Final  build  holds  all the features required by the  customer  \n(yy ) Agile Principles  \n(zz )  The Agile Manifesto is based on twelve principles  \n1. Customer satisfaction by early and continuous delivery of valuable  software  \n2. Welcome changing requirements, even in late  development  \n3. Working software is delivered frequently (weeks rather  than months)  \n4. Close, daily cooperation between business people and  developers  \n5. Projects are built around motivated individuals, who should be  trusted  \n6. Face-to-face conversation is the best form of communication  (co-location)  \n7. Working software is the principal  measure of  progress  \n8. Sustainable development, able to maintain a constant  pace \n9.", "mimetype": "text/plain", "start_char_idx": 38617, "end_char_idx": 42658, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "01e80f2f-e744-4056-b3f7-a2c0862f0815": {"__data__": {"id_": "01e80f2f-e744-4056-b3f7-a2c0862f0815", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a725505a-3100-4b26-83eb-3cb7f2c90674", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "13a52da9974709524143616b7f224f9bc6290c3362956a050c8f1edd581a1800", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "160e78ad-fb8d-42c7-9622-41486dfc6908", "node_type": "1", "metadata": {}, "hash": "91ad599c326a14edadacb19ccced7f0571cbd6483d160c7e9655dc9251b72e02", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Customer satisfaction by early and continuous delivery of valuable  software  \n2. Welcome changing requirements, even in late  development  \n3. Working software is delivered frequently (weeks rather  than months)  \n4. Close, daily cooperation between business people and  developers  \n5. Projects are built around motivated individuals, who should be  trusted  \n6. Face-to-face conversation is the best form of communication  (co-location)  \n7. Working software is the principal  measure of  progress  \n8. Sustainable development, able to maintain a constant  pace \n9. Continuous attention to technical excellence and good  design  \n10.Simplicity \u2014the art of maximizing the amount of work not done \u2014is essential  \n11.Best architectures, requirements, and desi gns emerge from self -organizing  teams \n12.Regularly, the team reflects on how to become more effective, and adjusts  accordingly  \n \n \n32  \n 5 Write note on business process engineering and product engineering? MAY/JUN -13 , APRIL/MAY -\n15 \nBusiness Engineering  \ni. Business pro cess engineering is a way in which organizations study their current business processes \nand develop new methods to improve productivity, efficiency, and operational costs.  \nii.  As a business process engineer, you will examine the way an organization operates, its long -term \nperformance goals, and recommend ways it can work more seamlessly to achieve overall improvement.  \ni i i. Many business process engineers work as consultants contracted by companies seeking \nimprovements to their methodology and infrastructure.  \nProdu ct engineering   \n4. It refers to the process of designing and developing a device, assembly, or system such that it is produced \nas an item for sale through some production  manufacturing  process.  \n5. Prod uct engineering  usually entails activity dealing with issues of cost, reducibility, quality, \nperformance, reliability, serviceability, intended lifespan and user features.  \n6. These product characteris tics are generally all sought in the attempt to make the resulting product \nattractive to its intended  market  and a successful contributor to the business of the organization that \nintends to o ffer the product to that market.  \n7.  It includes design, development and transitioning to manufacturing of the product. The term \nencompasses developing the concept of the product and the design and development of its mechanical, \nelectronics and  software  components.  \n8.  After the initial design and development is done, transitioning the product to manufacture it in volumes \nis considered part  of product engineering.  \n9. Product engineers are the technical interface  between the component development team and the \nproduction side (Front End and Back End), especially after the development phase and qualifications \nwhen the high volume production is running.  \n10. Product engineers improve the product quality and secure the pro duct reliability by balancing the \ncost of tests and tests coverage that could impact the production fall -off. They support failure analysis \nrequest from customers.  \n11. For example, the engineering of a  digital camera  would include defining the feature set, design of the \noptics, the mechanical and  ergonomic design  of the packaging, developing the electronics that control the \nvarious compone nt and developing the software that allows the user to see the pictures, store them in \nmemory and download them to a  computer . \n12. Product engineering is an  engineering  discipline that deals with both design \nand manufacturing  aspects of a product.  \nThe job requires the product engineer to have a very good working knowledge of:  \nii. Statistical met hods and tools  \n33  \n iii. Manufacturing process  \niv. Software, hardware and systems implementation  \nv. Product reliability and qualification  \nvi. Physical analysis methods  \nvii. Computer -aided design  and simulation prog rams  \nviii. Specific technology  \nix. Strong product Knowledge  \nx. Strong analytic work methodology and problem solving skills  \nxi. Continuous Improvement Knowledge  \n6 Explain in detail about spiral model with a neat sketch and describe why this model comes under \nboth evolution ary and RAD models. APRIL/MAY -15, NOV/DEC 2017  \nREFER PART B Q1  \n7 Which process model is best suited for risk management? Discuss in detail with an example. Give its \nadvantages and disadvantages? NOV/DEC 2016,APRIL/MAY 2018  \nThere are two characteristics of  risk i.e. uncertainty and loss.  \n \nFollowing are the categories of the risk:  \n \n1. Project risk  \n1. If the project risk is real then it is probable that the project schedule will slip and the cost of the \nproject will increase.  \n2.", "mimetype": "text/plain", "start_char_idx": 42090, "end_char_idx": 46795, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "160e78ad-fb8d-42c7-9622-41486dfc6908": {"__data__": {"id_": "160e78ad-fb8d-42c7-9622-41486dfc6908", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "01e80f2f-e744-4056-b3f7-a2c0862f0815", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4ca71cd5892e654d7a8150060e6612d5298bf1a4793c4801a5b8fb95ddf3e0be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7fb867d-4499-454f-9938-9bacfa5f2256", "node_type": "1", "metadata": {}, "hash": "0e8d68ec7fb43c00e9903649f5253ca07d34618f7b8f5a2578343e8c2f5324a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Specific technology  \nix. Strong product Knowledge  \nx. Strong analytic work methodology and problem solving skills  \nxi. Continuous Improvement Knowledge  \n6 Explain in detail about spiral model with a neat sketch and describe why this model comes under \nboth evolution ary and RAD models. APRIL/MAY -15, NOV/DEC 2017  \nREFER PART B Q1  \n7 Which process model is best suited for risk management? Discuss in detail with an example. Give its \nadvantages and disadvantages? NOV/DEC 2016,APRIL/MAY 2018  \nThere are two characteristics of  risk i.e. uncertainty and loss.  \n \nFollowing are the categories of the risk:  \n \n1. Project risk  \n1. If the project risk is real then it is probable that the project schedule will slip and the cost of the \nproject will increase.  \n2. It identifies the potential schedule , resource, stakeholders and the requirements problems and their \nimpact on a software project.  \n2. Technical risk  \n\uf0b7 If the technical risk is real then the implementation becomes impossible.  \n\uf0b7 It identifies potential design, interface, verification and maintenan ce of the problem.  \n3. Business risk  \nIf the business risk is real then it harms the project or product.  \n \nThere are five sub -categories of the business risk:  \n \n1. Market risk - Creating an excellent system that no one really wants.  \n2. Strategic risk - Creatin g a product which no longer fit into the overall business strategy for companies.  \n3. Sales risk - The sales force does not understand how to sell a creating product.  \n4. Management risk - Loose a support of senior management because of a change in focus.  \n5. Budget risk - losing a personal commitment.  \n34  \n Other risk categories  \nThese categories suggested by Charette.  \n \n1. Known risks :  These risk are unwrapped after the project plan is evaluated.  \n2. Predictable risks :  These risks are estimated from previous projec t experience.  \n3. Unpredictable risks :  These risks are unknown and are extremely tough to identify in advance.  \nPrinciples of risk management  \nMaintain a global perspective - View software risks in the context of a system and the business problem \nplanned to solve.  \n \nTake a forward looking view \u2013 Think about the risk which may occur in the future and create future plans \nfor managing the future events.  \n \nEncourage open communication \u2013 Encourage all the stakeholders and users for suggesting risks at any \ntime.  \n \nIntegrate \u2013 A consideration of risk should be integrated into the software process.  \n \nEmphasize a continuous process \u2013 Modify the identified risk than the more information is known and add \nnew risks as better insight is achieved.  \n \nDevelop a shared product visi on \u2013 If all the stakeholders share the same vision of the software then it is \neasier for better risk identification.  \n \nEncourage teamwork \u2013 While conducting risk management activities pool the skills and experience of all \nstakeholders.  \nRisk Identification  \nIt is a systematic attempt to specify threats to the project plans.  \n \nTwo different types of risk:  \n \n1. Generic risks  \no These risks are a potential threat to each software project.  \n2.  Product -specific risks  \n- These risks are recognized by those with a clear unde rstanding of the technology, the people and the \nenvironment which is specific to the software that is to be built.  \n- A method for recognizing risks is to create item checklist.  \n \n35  \n 8 Consider 7 functions with their estimated lines of code. Average productivity  based on historical \ndata is 620 LOC/pm and  labour  rate is Rs. 8000  per mnth.  Find  the total  estimates  \nproject cost and effort?  F1 \u2013 2340 , F2 \u2013 5380, F3 \u2013 6800 , F4 \u20133350 , F5 -4950 , F6 -2140 , F7 \u2013 8400  \n  \nThere are many techniques that can be used to rigorously estimate or measure effortand cost \nfor a software project, such as:  \n-Function Point (FP)  \n-Source Lines of Code (SLOC).  \n-COnstructive COst MOdel (COCOMO)  \n -Delphi  \n SLOC Technique(Source Line of Code Technique) -The SLOC technique is an objecti ve \nmethod of estimating or calculating the size of the project.  \n-The project size helps determine the resources, effort, cost, and duration required to \ncomplete the project.  \n -It is also used to directly calculate the effort to be spent on a project.  \n -W e can use it when the programming language and the technology to be used are \npredefined.", "mimetype": "text/plain", "start_char_idx": 46024, "end_char_idx": 50395, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f7fb867d-4499-454f-9938-9bacfa5f2256": {"__data__": {"id_": "f7fb867d-4499-454f-9938-9bacfa5f2256", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "160e78ad-fb8d-42c7-9622-41486dfc6908", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1473cb945c74b2a5df2451845abc4076f8dc8968ddcfcd61d8171a7dfcc7a424", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f0c5977c-67f9-4f97-82b9-f8d1681f4813", "node_type": "1", "metadata": {}, "hash": "de241c306faa6f2a01dadc723be153de36b43780a84a6dca5df07c58eb86ac48", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-COnstructive COst MOdel (COCOMO)  \n -Delphi  \n SLOC Technique(Source Line of Code Technique) -The SLOC technique is an objecti ve \nmethod of estimating or calculating the size of the project.  \n-The project size helps determine the resources, effort, cost, and duration required to \ncomplete the project.  \n -It is also used to directly calculate the effort to be spent on a project.  \n -W e can use it when the programming language and the technology to be used are \npredefined.  \n-This technique includes the calculation of lines of codes(LOC), documentation of pages, \ninputs, outputs, and components of a software program.  \n Counting SLOC -The us e of SLOC techniques can be used in the case of the technology or \nlanguage  remains unchanged throughout the project.  \nGenerally, it can be used when you are using third -generation language, such as FORTRAN \nor COBOL.  \n-To count the SLOC the following must b e considered: \n The count includes: - \nThe SLOC delivered to client.  \n-The SLOC written only by the development team are counted -The declaration statements \nare counted as source lines of code  \nThe count excludes: -The code created by application generators.  \n -The comments inserted to improve the readability of program.  \n-Once, you get the numbers of line of code of SLOC, you can estimate or calculate the total \neffort and cost to complete the given project.  \nExample: -Assume estimated lines of code of a system is:  33,600 LOC -Average productivity \nfor system of this type is: 620 LOC/person -month - \nThere are 7 developers -Labor rate is: $ 8000per person -month \n Calculate the total effort \nand cost required to complete the above project  \nSolution+Way1=>  \n36  \n   Total Effort =Total LOC/Productivity = 33600/620=54.19 \u2248 54 person -months=> \n7developers  \n \nEffort = Tot al Effort/6= 54/7= 7months=> Total Cost=Total Effort * Labor Rate = 54 * \n8000\u2248 $43,2000+Way2=> Cost per LOC =Labor Rate/Productivity=8000/620=$12.9\u2248 $13  \n> Total Cost = Total LOC * Cost perLOC =33,600* 13=$436800  \n9 (i) What is the impact of reusability in soft ware development process?  \n(ii) Explain the component based software development model with a neat sketch. \nNOV/DEC  2017  \nComponent -based software engineering  (CBSE ) \n\uf0b7 It also called  components -based development  (CBD ), is a branch of software \nengineering that emphas izes the  separation of concerns  with respect to the wide -\nranging functionality available throughout a given  software system . \n\uf0b7  It is a reuse -based approach to defining, implementing and composing loosely \ncoupled independent components into systems.  \n\uf0b7 This practice aims to bring about an equally wide -ranging degree of benefits in bot h \nthe short -term and the long -term for the software itself and for organizations that \nsponsor such software.  \n\uf0b7 Software engineering practitioners regard components as part of the starting platform \nfor service -orientation .  \n\uf0b7 Components play this role, for example, in  web services , and more recently, \nin service -oriented architectures  (SOA), whereby a component is converted by the \nweb service into a  service  and subsequently inherits further characteristics beyond that \nof an ordinary component . \n\u2022 C O T S (C om m erci al  Off The Shelf ) software  com ponents, devel oped by vendors who offer them as  products \ncan  be us ed when  software  is to built.  \n\u2022 Provides interfaces targeted  functionality with well defined  \n\u2022 Incorporates model many of the characteristics of Sp iral model  \n\u2022 R e g a r d l e s s  of technology  to be  used,  it must follow  the s teps   like \u2013 Available  component\nb as ed products  are res earch ed  and evaluated for the current  application  \nCom ponent integration i s s u e s  is to dealt \n\u2013 A software  architecture  is desi gned  to accomm odate  the components.  \n\u2013 Com ponents  are i ntegrated i nto th e  archi tecture  \n\u2013 C om prehen sive   testing  is conducted  to ensure proper functionality.  \n\u2013 Component Based Software Engineering(CBSE) is a process that emphasis the \ndesign and construction of computer based system using reusable software \n\u201ccomponents\u201d.", "mimetype": "text/plain", "start_char_idx": 49915, "end_char_idx": 54046, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f0c5977c-67f9-4f97-82b9-f8d1681f4813": {"__data__": {"id_": "f0c5977c-67f9-4f97-82b9-f8d1681f4813", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7fb867d-4499-454f-9938-9bacfa5f2256", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "670d73a3e77d590234339bd9339b91db096c5372428468a74c35243cdb83996a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "af6c1554-9f7b-4f1a-8866-22b7d5c2177e", "node_type": "1", "metadata": {}, "hash": "afcb264d537fd8ca75c10f3f1db60d95dd20b5128503b67df021943f355e77bc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Provides interfaces targeted  functionality with well defined  \n\u2022 Incorporates model many of the characteristics of Sp iral model  \n\u2022 R e g a r d l e s s  of technology  to be  used,  it must follow  the s teps   like \u2013 Available  component\nb as ed products  are res earch ed  and evaluated for the current  application  \nCom ponent integration i s s u e s  is to dealt \n\u2013 A software  architecture  is desi gned  to accomm odate  the components.  \n\u2013 Com ponents  are i ntegrated i nto th e  archi tecture  \n\u2013 C om prehen sive   testing  is conducted  to ensure proper functionality.  \n\u2013 Component Based Software Engineering(CBSE) is a process that emphasis the \ndesign and construction of computer based system using reusable software \n\u201ccomponents\u201d.  \n37  \n  \u2022 It emerged from the failure of object -oriented development to support effective \nreuse. Single object classes are too detailed and specific.  \n \u2022 CBSE embodies the \u201cbuy , don\u2019t built\u201d philosophy.  \n \n \n \n\u2022 The p rocess begins when a software team establish requirements for a system \nto be built using conventional requirements elicitation techniques. An \narchitectural design is established , but rather than moving immediately into \nmore detailed tasks , the team exami nes requirements to determine what \nsubset is directly amenable to composition , rather than construction.  \n\u2022 For those requirements that can be addressed with available components the \nfollowing activities take place:  \n 1. Component qualification  \n 2. Component adaptation  \n3. Component composition  \n4. Component update  \n COMPONENT CHARACTERISTICS  \n1. Standardised  \n2. Independent  \n 3. Compassable  \n 4. Deployable  \n38  \n 5. Documented  \n \n10 (i) How function point analysis methodology is applied in estimation of software size \n?Expla in. Why FPA methodology is better than LOC methodology  ? \nIf LOC is simply a count of the number of lines then figure shown below contains 18 LOC . \n(ii) A line of code is any line of program text that is not a comment or blank line, regardless \nof the number of s tatements or fragments of statements on the line. This specifically includes \nall lines containing program header, declaration, and executable and non -executable \nstatements\u201d.  \nFunction Count  \nAlan Albrecht while working for IBM, recognized the problem in size  measurement in the \n1970s, and developed a technique (which he called Function Point Analysis), which \nappeared to be a solution to the size  \nmeasurement problem.  \nThe five functional units are divided in two categories:  \n(i) Data function types  \n# Internal Log ical Files (ILF): A user identifiable group of logical related data or control \ninformation maintained within the system.  \n# External Interface files (EIF): A user identifiable group of logically related data or control \ninformation referenced by the system, but maintained within another system. This means \nthat EIF counted for one system, may be an ILF in another system.  \nThe weighting factors are identified for all functional units and multiplied with \nthe functional units accordingly. The procedure for the cal culation of Unadjusted \nFunction Point (UFP) is given in table shown above.  \nhe procedure for the calculation of UFP in mathematical  \n(iii) form is given below:UFP = \u2211\u2211 Z ij w ij  \ni = 1 J = 1  \nWhere i indicate the row and j indicates the column of Table 1  \nW ij : It i s the entry of the i th row and j th column of the table 1  \nZij : It is the count of the number of functional units of Type i that have been \nclassified as having the complexity corresponding to column j.  \nOrganizations that use function point methods develop  a criterion for  \n39  \n determining whether a particular entry is Low, Average or High.  \nNonetheless, the determination of complexity is somewhat subjective.  \nFP = UFP * CAF  \nWhere CAF is complexity adjustment factor and is equal to [0.65 +  \n0.01 x \u03a3F i ]. The F i (i=1 to 14) are the degree of influence  \n(iv) An application has the following:10 low external inputs, 12 high external \noutputs, 20 low internal logical files, 15 high external interface files, 12 average \nexternal inquiries and a value adj ustment factor of 1.10 . What is the unadjusted and \nadjusted function point count ?", "mimetype": "text/plain", "start_char_idx": 53295, "end_char_idx": 57530, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "af6c1554-9f7b-4f1a-8866-22b7d5c2177e": {"__data__": {"id_": "af6c1554-9f7b-4f1a-8866-22b7d5c2177e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f0c5977c-67f9-4f97-82b9-f8d1681f4813", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5d83ce4054fbd49474bc4c5d58ed09b5fd7123dd7b25fb2994a85d33bb4e53a7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d485086a-deae-46f3-83f6-836210f8b21a", "node_type": "1", "metadata": {}, "hash": "f044474e51b412aa65849ed5705908cdc86656b12bed7dd362bd72a01c6fcd15", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Nonetheless, the determination of complexity is somewhat subjective.  \nFP = UFP * CAF  \nWhere CAF is complexity adjustment factor and is equal to [0.65 +  \n0.01 x \u03a3F i ]. The F i (i=1 to 14) are the degree of influence  \n(iv) An application has the following:10 low external inputs, 12 high external \noutputs, 20 low internal logical files, 15 high external interface files, 12 average \nexternal inquiries and a value adj ustment factor of 1.10 . What is the unadjusted and \nadjusted function point count ? APRIL/MAY  2017  \nSolution  \nUnadjusted function point counts may be calculated using  \nas: \n \nUFP = \u2211\u2211 Z ij w ij  \n           i = 1 J = 1  \nFP \n= 10 x 3 + 12 x 7 + 20 x 7 + 15 + 10 + 12  x 4 \n= 30 + 84 +140 + 150 + 48  \n= 452  \n= UFP x CAF  \n= 452 x 1.10 = 497.2.  \n11 What is a process model ? Describe the process model that you would choose to \nmanufacture a car. Explain giving suitable reasons. APRIL/MAY 2017  \nA structured set of activities requi red to develop a software system.  \n\u2022 Many different software processes but all involve:  \n\u2022Specification \u2013 defining what the system should do;  \nDesign and implementation \u2013 defining the organization of the system and  \nimplementing the system;  \nValidation \u2013 checki ng that it does what the customer wants;  \nEvolution \u2013 changing the system in response to changing customer needs.  \n\u2022 A software process model is an abstract representation of a process. It  \npresents a description of a process from some particular perspective  \nWhen we describe and discuss processes, we usually talk about the activities  \nin these processes such as specifying a data model, designing a user  \ninterface, etc. and the ordering of these activities.  \n\u2022 Process descriptions may also include:  \n\u2022Products, whi ch are the outcomes of a process activity;  \nRoles, which reflect the responsibilities of the people involved in the process;  \nPre- and post -conditions, which are statements that are true before and after a process \nactivity has been enacted or a product produ ced. \n12 Explain how breakdown structure is used in software engineering .Discuss how \nsoftware project scheduling helps in timely release of a product. APRIL/MAY 2018  \n40  \n A Work Breakdown Structure  includes dividing a large and complex project into simpler, \nmanageable and independent tasks. The root of this tree (structure) is labelled by the Project \nname itself. For constructing a work breakdown structure, each node is recursively \ndecomposed into smaller sub -activities, until at the leaf level, the activities becomes \nundividable and independent. It follows a Top -Down approach.  \nSteps:  \n3. Step -1: Identify the major activities of the project.  \n4. Step -2: Identify the sub -activities of the major activities.  \n5. Step -3: Repeat till undividable, simple and independent activitie s are created.  \n6. \n  \nConstruction of Work Breakdown Structure:  \nFirstly, the project managers and top level management identifies the main deliverables of the project. \nAfter this important step, these main deliverables are broke down into smaller higher -level t asks and \nthis complete process is done recursively to produce much smaller independent tasks. It depends on \nthe project manager and team that upto which level of detail they want to break down their project.  \nGenerally the lowest level tasks are the most si mplest and independent tasks and takes less than two \nweeks worth of work. Hence, there is no rule for upto which level we may build the work breakdown \nstructure of the project as it totally depends upon the type of project we are working on and the \nmanagem ent of the company. The efficiency and success of the whole project majorly depends on the \nquality of the Work Breakdown Structure of the project and hence, it implies its importance.  \nUses:  \n\uf0b7 It allows doing a precise cost estimation of each activity.  \n\uf0b7 It allows estimating the time that each activity will take more precisely.  \n\uf0b7 It allows easy management of the project.  \n\uf0b7 It helps in proper organization of the project by the top management.  \n \n13 Give detail explanation about agile process?", "mimetype": "text/plain", "start_char_idx": 57024, "end_char_idx": 61146, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d485086a-deae-46f3-83f6-836210f8b21a": {"__data__": {"id_": "d485086a-deae-46f3-83f6-836210f8b21a", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "af6c1554-9f7b-4f1a-8866-22b7d5c2177e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0d1254200ac6991b096686f931ca3391fcbedf31a0e58b1bad5bf8f46bac57d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8939d10d-1fb1-4adc-83f7-677621637a6b", "node_type": "1", "metadata": {}, "hash": "ce4ab078ae9c213b15d3dff51736eba38e7e05b94f208d3d7182ebd308bcc3a9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It depends on \nthe project manager and team that upto which level of detail they want to break down their project.  \nGenerally the lowest level tasks are the most si mplest and independent tasks and takes less than two \nweeks worth of work. Hence, there is no rule for upto which level we may build the work breakdown \nstructure of the project as it totally depends upon the type of project we are working on and the \nmanagem ent of the company. The efficiency and success of the whole project majorly depends on the \nquality of the Work Breakdown Structure of the project and hence, it implies its importance.  \nUses:  \n\uf0b7 It allows doing a precise cost estimation of each activity.  \n\uf0b7 It allows estimating the time that each activity will take more precisely.  \n\uf0b7 It allows easy management of the project.  \n\uf0b7 It helps in proper organization of the project by the top management.  \n \n13 Give detail explanation about agile process?  \nCombination of iterative and incremental process models  \n Focus of adaptability and customer satisfaction  \n Break into small incremental builds  \n iteration typically lasts 1 -3 weeks  \n Cross functional teams working  \n End of the iteration, a working product is displayed to the customer  \nAdvantage  \n Realistic appr oach  \n Promotes teamwork and cross training.  \n Functionality developed rapidly and demonstrated.  \n41  \n \n Resource requirements are minimum.  \n Suitable for fixed or changing requirements  \n Delivers early partial working solutions.  \n Good model for environments th at change steadily.  \n Minimal rules, documentation easily employed.  \n Little or no planning required.  \n Easy to manage.  \n Gives flexibility to developers.  \n Not suitable for handling complex dependencies.  \n Strict delivery management dictates the scope, fu nctionality to be  \ndelivered, and adjustments to meet the deadlines.  \n Depends heavily on customer interaction, so if customer is not clear,  \nteam can be driven in the wrong direction.  \n Transfer of technology to new team members may be quite  \nchallenging due  to lack of documentation.  \nAgile Framework  \n Rational Unified Process (1994),  \n Scrum (1995),  \n Extreme Programming (1996),  \n Adaptive Software Development,  \n Feature Driven Development,  \n Dynamic Systems Development Method (DSDM) (1995).  \n Rational Unifie d Process (1994),  \n Scrum (1995),  \n Extreme Programming (1996),  \n Adaptive Software Development,  \n Feature Driven Development,  \n Dynamic Systems Development Method (DSDM) (1995).  \n14 Describe in detail about Extreme programming ?  \nE x t r e m e  P r o g r a m m i n g  ( X P ) \n42  \n \uf0b7 Ma n a gem en t -P ra cti ce s  \nOn-Site Cu st om er:    Acentral  customer  contact  must alw ay s  be \nacce ssi ble  in order to clarify requirements and questions directly.  \nPlanning Gam e: Projects, in acco rd ance  with X P ,  r u n  iteratively \n(repeatedly) and incrementally (gradually build on e ach  other). The \ncontents  of the next step are planned  before  each iteration. All  project  \nmembers  (incl. the customer)  participate.  \nShort  Relea ses:  New deliveries  should  be m ade at short \nintervals. Con seq uen tl y , customers receive the required \nfunctions quicker  and can therefore  give feedback  on the \ndevelopment  quicke r. \n\uf0b7 T e a m-P r a c t i c e s \nMetaphor: Only a few clear metaphors should describe the system  \nbeing developed  so that the nitty-gritty  of the system  is clear to all of \nthe project  members.  \nCol l ecti v e Ownership: The whole team is responsible for the system, not \nindividuals.  E ac h developer  must have ac ce s s to all lines of code so that \neach developer  is able to take over the task of another  developer.  \n\uf0b7 Continuous  In tegra ti on :  All ch anges  to the system  are integrated  \nPromptly so that not too many dependencies between ch ange s occur. \nCoding  Standards:  Reg ard ing  the common  responsibility  for the code, \nthere should  be a given common  standard  for writing  the code. \nSustainable P a c e :  XP builds on the creativity of the individual      \nproject members. This creativity cannot be achieved if the project \nteam constantly  works  overtime.  Overtime  is to be avoided.", "mimetype": "text/plain", "start_char_idx": 60213, "end_char_idx": 64408, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8939d10d-1fb1-4adc-83f7-677621637a6b": {"__data__": {"id_": "8939d10d-1fb1-4adc-83f7-677621637a6b", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d485086a-deae-46f3-83f6-836210f8b21a", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "b8ad49c9b6e8012ba7d26da5e6788c644f5a4857615b29bc51c2331c3ac8c87a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f7b6ff9d-a81a-468e-a544-e05022f8f79f", "node_type": "1", "metadata": {}, "hash": "f016104dc65a98c90ede13782d71e575d3f494268c607bdf7de5ba7163617556", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Col l ecti v e Ownership: The whole team is responsible for the system, not \nindividuals.  E ac h developer  must have ac ce s s to all lines of code so that \neach developer  is able to take over the task of another  developer.  \n\uf0b7 Continuous  In tegra ti on :  All ch anges  to the system  are integrated  \nPromptly so that not too many dependencies between ch ange s occur. \nCoding  Standards:  Reg ard ing  the common  responsibility  for the code, \nthere should  be a given common  standard  for writing  the code. \nSustainable P a c e :  XP builds on the creativity of the individual      \nproject members. This creativity cannot be achieved if the project \nteam constantly  works  overtime.  Overtime  is to be avoided.  \n\uf0b7 D e s i g n \nWriting unit tests before programming and keepi ng  all of the tests \nrunning  at all times.  Th e  unit tests are automated  and eliminates  \ndefects e arl y , thus reducing  the co sts. \nStarting  with a simple  de sig n  just enough  to code the features at hand and \nredesigning when required.  \n \n\uf0b7 D es i g n :  User Stor ies \n43  \n \uf0b7  \n\uf0b7 Developm ent  \nPro g ram m in g  in pairs (called pair programm ing) , with two prog rammers  atone  screen ,  taking  \nturns to use  the keyboard. While one of them is at the keyboard, the other constantly reviews \nand provides  inputs. \nIntegrating and testing the whole  sy stem   s eve ral  times a d a y . \n\uf0b7 Pai r Pro g r am m i n g  \ntwo prog ram mers  work together  atone workstation.  \nOn e , the d r i v e r, writes  code while  the other, the o b s e r v e r  or n a v i g a t o r , reviews  e ach line of co d e  as it is \ntyped  in. \nTh e two prog rammers  switch  roles frequently.  \nWhile reviewing, the observer also co n si de rs the \"strategic \" direction of the work, com ing up \nwith ide as for improvements  and likely future  problems to ad d re s s . \nTh i s  frees the driver to focus all of their attention on the \"tactical\"  as p e c t s  of completing  the \ncurrent task, using the observer  as a safety net and  guide \n\uf0b7 Pai r Pro g r am m i n g  \nPai r programm ing i n c re as e s  the m an-hours required to deliver code com pared  to prog ramme rs  \nworking  individually  from up to between  15% and 1 0 0 % . \nH o w e v e r ,  the resulting  code h as about  15% fewer defects. \n\uf0b7 Production  \n44  \n Putting a minimal worki ng sy s tem  into the production  quickly  and upgrading    it \nwhenever  required.  \nK e e p i n g   the customer  involved  all the time and obtaining constant  feed back .  \n \nExtreme Programming \u2212 A way to handle the common shortcomings  \nSoftware Engineering involves \u2212  \n\uf0b7 Creativity  \n\uf0b7 Learning and improving through trials and errors  \n\uf0b7 Iterations  \nExtreme Programming builds on these activities and coding. It is the detailed (not the only ) \ndesign activity with multiple tight feedback loops through effective implementation, testing \nand refactoring continuously.  \nExtreme Programming is based on the following values \u2212  \n\uf0b7 Communication  \n\uf0b7 Simplicity  \n\uf0b7 Feedback  \n\uf0b7 Courage  \n\uf0b7 Respect  \nWhat is Extreme Programmin g? \nXP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development methodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self -organize. \nExtreme Programming provides specific core practices  where \u2212  \n\uf0b7 Each practice is simple and self -complete.  \n\uf0b7 Combination of practices produces more complex and emergent behavior.  \n45  \n Embrace Change  \nA key assumption of Extreme Programming is that the cost of changing a program can be \nheld mostly constant over time.", "mimetype": "text/plain", "start_char_idx": 63683, "end_char_idx": 67563, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f7b6ff9d-a81a-468e-a544-e05022f8f79f": {"__data__": {"id_": "f7b6ff9d-a81a-468e-a544-e05022f8f79f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8939d10d-1fb1-4adc-83f7-677621637a6b", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fe2d099d702594a91a3471976817b1ecfd52af385e4d6a489152daee790576a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913", "node_type": "1", "metadata": {}, "hash": "cfb23365acf21ca112d0fa507ca8240f91492d997066ae5fc6aa8a4f8f08ee18", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "XP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development methodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self -organize. \nExtreme Programming provides specific core practices  where \u2212  \n\uf0b7 Each practice is simple and self -complete.  \n\uf0b7 Combination of practices produces more complex and emergent behavior.  \n45  \n Embrace Change  \nA key assumption of Extreme Programming is that the cost of changing a program can be \nheld mostly constant over time.  \nThis can be achieved with \u2212  \n\uf0b7 Emphasis on continuous feedback from the customer  \n\uf0b7 Short iterations  \n\uf0b7 Design and redesign  \n\uf0b7 Coding and testing frequently  \n\uf0b7 Eliminating defects early, thus reducing costs  \n\uf0b7 Keeping the customer involved throughout the development  \n\uf0b7 Deliveri ng working product to the customer  \n \n15 Explain about Extreme Programming using nutshell.?  \nExtreme Programming involves \u2212  \n\uf0b7 Writing unit tests before programming and keeping all of the tests running at all times. \nThe unit tests are automated and eliminates d efects early, thus reducing the costs.  \n\uf0b7 Starting with a simple design just enough to code the features at hand and redesigning \nwhen required.  \n\uf0b7 Programming in pairs (called pair programming), with two programmers at one \nscreen, taking turns to use the keyboar d. While one of them is at the keyboard, the \nother constantly reviews and provides inputs.  \n\uf0b7 Integrating and testing the whole system several times a day.  \n\uf0b7 Putting a minimal working system into the production quickly and upgrading it \nwhenever required.  \n\uf0b7 Keepin g the customer involved all the time and obtaining constant feedback.  \nIterating facilitates the accommodating changes as the software evolves with the changing \nrequirements.  \n \n46  \n       UNIT \u2013 2 PART \u2013A \n \n \n \n \nS.NO  QUESTIONS  \n1 What is Software Prototyping? NOV/ DEC -10 , APR/MAY -11, MAY/JUNE -13 \nIt is a rapid software development for validating the  \nrequirements. It is to help customers & developers to understand the system requirements.  \n2 Define functional and non - Functional requirements. NOV/DEC -10 \nFunctional re quirements describe all the functionality or system services. It should \nbe clear how system should react to particular inputs and how particular systems behave in \nparticular situation. Non functional requirements define the system properties and constraint s. \nIt is divided in to product, organizational  & \nexternal requirements.  \n3 What is meant by functional requirement? APR/MAY -11 Functional requirements \ndescribe all the functionality or system services. It should be clear how system should react to \nparticul ar \ninputs and how particular systems behave in particular situation.  \n4 Name the metrics for specifying Non -functional requirements? NOV/DEC -11 \nSpeed, size, ease of use, reliability, robustness, portability  \n5 Draw  the DFD  for  the following  (i) External  entity (ii) Data items NOV/DEC -11 \nExternal entity  \nData items  \n47  \n 6 What do requirements processes involve? APR/MAY -12 \nIt involves  feasibility  study,  discovery,  analysis &validation of system  \nrequirements.  \n7 Define non -functional requirements. APR/MAY -12 \nNon functional requirements define the system properties and constraints.  It is divided in to \nproduct, organizational  & \nexternal requirements  \n8 Distinguish  between  the term  inception,  elicitation,  & elaboration with reference to \nrequirements?  NOV/DEC -12 \nInception \u2013 set of questions are asked to establish basic understanding of problem.  \nElicitation - collaborative requirements gathering & quality function deployment  \nElaboration \u2013 It focuses on developing a  refined technical   model   of   software   function , \nfeatures & constraints.  \n9 An SRS is traceable ?comment NOV/DEC -12,MAY/JUNE 2016  An SRS is correct if, and only if, \nevery requirement stated therein is one that the software shall meet. Traceability makes \nthis procedure easier and less prone  \nto error.  \n10 What is data dictionary? MAY/JUN -13 , APR/MAY 2016 ,  NOV/DEC 2016, APRIL/MAY 2017  \nIt is organized collection of all the data elements of the system with precise and rigorous \ndefinition so that user & system analyst will have a common understanding of inp uts, outputs,  \ncomponents of stores and intermediate calculations.", "mimetype": "text/plain", "start_char_idx": 66769, "end_char_idx": 71387, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913": {"__data__": {"id_": "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f7b6ff9d-a81a-468e-a544-e05022f8f79f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62102dbdab1daf92715a6aecd63e90f55cbb82e2fd053863e07bf8498313c25c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1563777f-7a75-49a6-84f3-caa1ea5d6419", "node_type": "1", "metadata": {}, "hash": "b784b42c925fbe93eea5465cb9c5fbf3671241f3046db8da53a803a3ce130d2e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Elicitation - collaborative requirements gathering & quality function deployment  \nElaboration \u2013 It focuses on developing a  refined technical   model   of   software   function , \nfeatures & constraints.  \n9 An SRS is traceable ?comment NOV/DEC -12,MAY/JUNE 2016  An SRS is correct if, and only if, \nevery requirement stated therein is one that the software shall meet. Traceability makes \nthis procedure easier and less prone  \nto error.  \n10 What is data dictionary? MAY/JUN -13 , APR/MAY 2016 ,  NOV/DEC 2016, APRIL/MAY 2017  \nIt is organized collection of all the data elements of the system with precise and rigorous \ndefinition so that user & system analyst will have a common understanding of inp uts, outputs,  \ncomponents of stores and intermediate calculations.  \n11 What are the benefits of prototyping?  \ni. Prototype  serves  as a basis  for deriving  system specification. ii. Design quality \ncan be improved.  \niii. System can be maintained easily.  \n iv. Develo pment efforts may get reduced.  \nv. System usability can be improved.  \n48  \n 12 What are the prototyping approaches in software process? MAY/JUNE 2016,APRIL/MAY 2018  \n \ni. Evolutionary prototyping \u2013 In this approach of system development, the initial prototype is \nprepared and it is then refined through number of stages to final  stage.  \nii. Throw -away prototyping \u2013 Using this approach a rough practical implementation of the \nsystem is produced. The requirement problems can be identified from this implementation. It is then \ndiscard ed.System is then developed using some  different  \nengineering paradigm.  \n13 List the characteristics of good SRS? APR/MAY 2016  \n \n\uf0b7 Correct  \n\uf0b7 Unambiguous  \n\uf0b7 Complete  \n\uf0b7 Consistent  \n\uf0b7 Ranked for importance and/or  stability  \n\uf0b7 Verifiable  \n\uf0b7 Modifiable  \n\uf0b7 Traceable  \n14 Classify  the following  as functional  / non-functional requirements for a banking \nsystem? NOV / DEC  2016  \n(a) Verifying bank  balance  \u2013 functional  requirements  \n(b) Withdrawing money from bank \u2013 functionalrequirements  \n(c) Completion of transaction in less than 1 sec \u2013 non-functional re quirements  \n(d) Extending system by providing more tellers for customers - \n non-functional requirements  \n49  \n 15 What is the linkage between Dataflow and ER diagram? APR/MAY 2016  \n \nAn ER diagram is the Entity Relationship Diagram, showing the relationship    between     different     \nentities     in     a     process.  A Data Flow diagram is a symbolic structure showing how the  flow  \nof data is used in different process  \n16 List the steps in user interface design? Golden rules of UI design APR/MAY 2015,  \nNOV/DEC2015  \nPlace the User in Control  \nReduce the User's Memory Load Make the Interface Consistent  \n17 How are requirements validated? APR/MAY 2015  Requirements validation: Have we got \nthe requirements right?  \nIn the validation phase, the work products produced as a consequ ence of requirements engineering are \nexamined for consistency, omissions, and ambiguity. The basic objective is to ensure that the SRS \nreflects the actual requirements accurately and  \nclearly.  \n18 What is a state transition diagram?  \nState transition diagram  is basically a collection of states and events. The events cause the \nsystem to change its state. It  also \nrepresents what actions are to be taken based on the transition.  \n19 What is DFD?  \nData Flow Diagram depicts the information flow and the transforms th at are applied on the \ndata as it moves from input to  \noutput.  \n20 What is waterfall model?  \nThe Waterfall Model was first Process Model to be introduced. It is also referred to as a linear -\nsequential life cycle model . \n50  \n  It is very simple to understand and us e. \nIn a waterfall model, each phase must be completed fully before the next phase can begin. This type \nof model is basically used for the for the project which is small and there are no uncertain \nrequirements.  \nIn this model the testing starts only after th e development is complete.  \nIn waterfall model phases do not overlap.  \n21 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is mainly used in database applications.  \n22 What is data modeling?  \nData m odeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing.", "mimetype": "text/plain", "start_char_idx": 70615, "end_char_idx": 74974, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1563777f-7a75-49a6-84f3-caa1ea5d6419": {"__data__": {"id_": "1563777f-7a75-49a6-84f3-caa1ea5d6419", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "31985293d096cb92fff8a0bdf16350aabe9ff4779eda3ba1d5e945b1050d619b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73383c8e-2ce9-4d11-acd6-66f1927b9f79", "node_type": "1", "metadata": {}, "hash": "16d3ffe83ee8193c19f5a072ef0c7e7169f5b7af0a5ee1affedceba3db3b8e7e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "20 What is waterfall model?  \nThe Waterfall Model was first Process Model to be introduced. It is also referred to as a linear -\nsequential life cycle model . \n50  \n  It is very simple to understand and us e. \nIn a waterfall model, each phase must be completed fully before the next phase can begin. This type \nof model is basically used for the for the project which is small and there are no uncertain \nrequirements.  \nIn this model the testing starts only after th e development is complete.  \nIn waterfall model phases do not overlap.  \n21 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is mainly used in database applications.  \n22 What is data modeling?  \nData m odeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing. The data model represents how data are related with  \none another.  \n23 What is requirement engineering?  \nRequirement engineering is  the process of establishing the  \nservices that the customer requires from the system and the constraints under which it operates and is \ndeveloped.  \n24 What are the various Rapid prototyping techniques?  April  \n/May 2015  \ni. Dynamic high level language  developmen t. \nii. Database programming.  \niii. Component and application  assembly.  \n25 What is data modeling?  \nData modeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing. The data model  represents how data  are related with  \none another.  \n51  \n 26 What  are the   various   types   of   traceability  in software engineering? April/may  2018  \ni v. Source traceability \u2013 These are basically the links from requirement to  stakeholders  \nv. Requirements traceability \u2013 These are links b etween dependant  requirements.  \nvi . Design traceability \u2013 These are links from  requirements  \nto design.  \n27 What is cardinality in data modeling?  \nCardinality in data modeling, cardinality specifies how  \nthe number of occurrences of one object is related to the nu mber of occurrences of another object.  \n28 What are the objectives of Analysis  modeling?  \ni. To describe what the customer  requires.  \nii. To establish a basis for the creation of software  design.  \niii. To devise a set of valid requirements after which the software can be  built.  \n29 How the limitations of waterfall model overcome? April /May  2015  \nThis type of model is basically used for the for the project which is small and there are no uncertain \nrequirements.Where no overlapping of  phases.  \nAt the end of each phase, a rev iew takes place to determine if the  \nproject is on the right path and whether or not to continue or discard the project.  \n30 What is feasibility study? NOV/DEC2015 , APR/MAY 2016  \nsoftware feasibility has four solid dimensions:  \nTechnology \u2014 Is a project techn ically feasible? Is it within the state of the art? Can defects be reduced \nto a level matching the application\u2019s needs?  \nFinance \u2014Is it \ufb01nancially feasible? Can development be completed  \n52  \n  at a cost the software organization, its client, or the market can afford?  \nTime \u2014Will the project\u2019s time -to-market beat the competition? Resources \u2014Does the organization \nhave the resources nee ded to succeed?  \nBefore starting any project the feasibility study team ought to carry initial architecture and design of \nthe high -risk requirements to the point at which it can answer these questions. In some cases, when \nthe team gets negative answers, a r eduction in requirements may be  \nnegotiated.  \n31 Define Quality function decelopment(QFD). NOV/DEC 2017  \nQuality Function Deployment ( QFD ) is a structured approach to defining customer needs or \nrequirements and translating them into specific plans to produce  products to meet those needs. The \n\u201cvoice of the customer\u201d is the term to describe  \nthese stated and unstated customer needs or requirements.  \n32 Differentiate between normal and exciting requirements ? APRIL/MAY 2017  \nNormal requirements  \n\uf0b7 The objective and g oal are stated for the system through  the meetings with the  customer.  \n\uf0b7 For the customer satisfaction these requirements should  be there.  \nExciting requirements  \n\uf0b7 These features are beyond the expectation of the  customer.  \n \n\uf0b7 The developer adds some additional fea tures or unexpected feature into the software to make \nthe customer more satisfied.  \nFor example, the mobile phone with standard features, but  the developer adds few additional \nfunctionalities like voice searching, multi -touch screen etc.", "mimetype": "text/plain", "start_char_idx": 74111, "end_char_idx": 78724, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73383c8e-2ce9-4d11-acd6-66f1927b9f79": {"__data__": {"id_": "73383c8e-2ce9-4d11-acd6-66f1927b9f79", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1563777f-7a75-49a6-84f3-caa1ea5d6419", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "38399bbbef53689e72749086a51e47f3c13f1fb8cf2bf47f56b5733e47edb0f4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "31c69716-dd50-4e06-9d48-9721e28311ce", "node_type": "1", "metadata": {}, "hash": "b1216547569308b121c719d9dd4d112d86a1720c3799ba1098fa46845ba7c058", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The \n\u201cvoice of the customer\u201d is the term to describe  \nthese stated and unstated customer needs or requirements.  \n32 Differentiate between normal and exciting requirements ? APRIL/MAY 2017  \nNormal requirements  \n\uf0b7 The objective and g oal are stated for the system through  the meetings with the  customer.  \n\uf0b7 For the customer satisfaction these requirements should  be there.  \nExciting requirements  \n\uf0b7 These features are beyond the expectation of the  customer.  \n \n\uf0b7 The developer adds some additional fea tures or unexpected feature into the software to make \nthe customer more satisfied.  \nFor example, the mobile phone with standard features, but  the developer adds few additional \nfunctionalities like voice searching, multi -touch screen etc. then the customer m ore exited about \nthat feature.  \n  \n53  \n 33 How do you design a software project for  reuse? (Nov/Dec  2007)  \n\uf0b7 A clear and well -defined product vision is an  essential foundation to  an \nsoftware  project.  \n\uf0b7 An evolutionary implementation strategy would be a  more pragmati c strategy  \nfor the company.  \n\uf0b7 There exist a need for continuous management support  and leadership  to \nensure success.  \n34 What are the standards for documentation? Briefly explain (Nov/Dec 2007)  \nIEEE Std 1028 -2008  \nThis standard defines five types of software reviews and procedures for  their  \nexecution. Review types include management reviews, technical reviews,  \ninspections, walk -throughs and audits. IEEE Std 1012 -2004  \nThis standard describes software verification and validation processes that are  \nused to determ ine if software products of an activity meets the requirements of the  \nactivity and to determine if software satisfies the user's needs for the intended  \nusage. The scope includes analysis, evaluation, review, inspection, assessment  \nand testing of both produ cts and processes.  \n35 What are context free questions? How it differs from meta questions?  \n(Nov/Dec 2009)  \nContext free questions are questions that can be  used regardless of the  project  \nunder consideration. They are general questions about  the nature of t he project  and \nthe environment in which the final product will be used.Meta questions are very  \ncomplex and detailed questions about the project model  \n54  \n  \n36  \n \nDefine behaviouralmodelling(Nov/Dec 2012)  \nAll behavioural models really do is describe the control structure of a system.  \nThis can be things like:  \n\uf0a7 Sequence of  operations  \n\uf0a7 Object states  \n\uf0a7 and Object  interactions  \nFurthermore, this modelling layer can also be called Dynamic Modelling. The  \nactivity of creating a behavioural model is commonly known as behaviour al \nmodelling. As well as this, a system should also only have one behavioural  \nmodel \u2013 much like functional modelling.  \n37 what are the types of prototypes  \n\u2022 Evolutionary prototyping \u2013 the initial prototype is prepared and it is then  refined  \nthrough number of  stages to final stage.  \n\u2022 Throw -away prototyping \u2013 a rough practical implementation of the system  is \nproduced. The requirement problems can be identified from  \nthis implementation  \n38 Define behaviouralmodelling(Nov/Dec 2012)  \nAll behavioural models really do is describe the control structure of a system.  \nThis can be things like:  \n\uf0a7 Sequence of  operations  \n\uf0a7 Object states  \n\uf0a7 and Object  interactions  \nFurthermore, this modelling layer can also be called Dynamic Modelling. The  \nactivity of creating a behavioural model is com monly known as behavioural  \nmodelling. As well as this, a system should also only have one behavioural  \nmodel \u2013 much like functional modelling.  \n39 What is the major distinction between user requirement and system  \nrequirement? (April/May 2008)  \nUser requireme nts may be a set of statements or use case scenarios presented  \nby the client in layman\u2019s terms of which the client can easily  \n elaborate and are  \nusually free of technical jargon. System requirements are built from the clients input  \nbeing what they have sp ecified in the user requirements.  \n55  \n 40 Which style of prototyping is most appropriate when the requirement are not  \nwell-understood? (April/May 2008)  \nUser Interface prototyping is most appropriate.This prototyping is used to prespecify  \nthe look and feel of u ser interface in an effective way.  \n41 Specify at least four questionnaire which supports to select the prototyping  \napproach. (Nov/Dec 2009)  \n\uf0b7 Prototype serves as a basis for deriving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be mainta ined easily.  \n\uf0b7 Development efforts may get reduced.", "mimetype": "text/plain", "start_char_idx": 77970, "end_char_idx": 82584, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "31c69716-dd50-4e06-9d48-9721e28311ce": {"__data__": {"id_": "31c69716-dd50-4e06-9d48-9721e28311ce", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73383c8e-2ce9-4d11-acd6-66f1927b9f79", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ce44e3fac3d7794966ac77ac063159d67b5b26480d2625891c83c87bce5921af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "99dc1d3a-ad27-4f99-9792-0d80f2a044a4", "node_type": "1", "metadata": {}, "hash": "9331020b994570103eac9bf37de3f3743b49d28953f16881bd2510c1f4ba713f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "System requirements are built from the clients input  \nbeing what they have sp ecified in the user requirements.  \n55  \n 40 Which style of prototyping is most appropriate when the requirement are not  \nwell-understood? (April/May 2008)  \nUser Interface prototyping is most appropriate.This prototyping is used to prespecify  \nthe look and feel of u ser interface in an effective way.  \n41 Specify at least four questionnaire which supports to select the prototyping  \napproach. (Nov/Dec 2009)  \n\uf0b7 Prototype serves as a basis for deriving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be mainta ined easily.  \n\uf0b7 Development efforts may get reduced.  \n\uf0b7 System usability can be  improved.  \n42 What is the purpose of domain analysis. (April/May 2010)  \nDomain analysis, or product line analysis, is the process of analysing related  \nsoftware systems in a domain to find their common and variable parts. It is a model  \nof wider business context for the system  \n43 what are the types of prototypes  \n\u2022 Evolutionary prototyping \u2013 the initial prototype is prepared and it is then  refined  \nthrough number of stages to final stage.  \n\u2022 Throw -away prototyping \u2013 a rough practical implementation of the system  is \nproduced. The requirement problems can be identified from  \nthis implementation  \n44 list two advantage of employing prototyping in software process?  \n\uf0b7 Prototype serves as a basis for der iving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be maintained  easily.  \n\uf0b7 Development efforts may get reduced.  \n\uf0b7 System usability can be  improved.  \n56  \n 45 State the different criteria applied to evaluate an effective modular system.  \n(May/June 2006)  \n\uf0b7 A system is considered modular if it consists of  discreet components so  that each \ncomponent can be implemented separately, and a change to one  component has  \nminimal impact on other components.  \n\uf0b7 Modularity is a clearly a desirable property in a  system . Modularity helps in  system \ndebugging. Isolating the system problem to a component is easier if  the system is \nmodular.   \n46 What is meant by structural analysis?  \nThe structural analysis is mapping of problem domain to flows and transformations. \nThe system  can be modeled by using Entity Relationship diagram, Data flow \ndiagram and Control flow  \ndiagrams.   \n47 What is the outcome of feasibility study?  \nThe outcome of feasibility study is the results obtained from the following questions: \nx Which system contribu tes to organizational objectives? x Whether the system can \nbe engineered? Is it within  the budget? x Whether the system can be integrated with  \nother  \nexisting system?   \n48 What are nonfunctional requirements?  \nNonfunctional requirements are constraints on t he services or functions offered by \nthe system such as timing  constraints,  \nconstraints on the development process, standards, etc\u2026   \n49 What are the advantages of evolutionary prototyping?  \ni. Fast delivery of the working system. ii. User is involved while developing the \nsystem. iii. More useful system can be delivered. iv. Specification,  design and \nimplementation work in co -ordinate  \nmanner.   \n50 What are the various Rapid prototyping techniques?  \ni. Dynamic  high level  language  development.  ii. Database   \n programming. iii. Component and application assembly.   \n \n \n \n \n57  \n  \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 Discuss any four process models with suitable application.  NOV/DEC -10 , \nAPR/MAY -11, NOV/DEC -12, MAY/JUN -13 \nA software process model is a standardised format for  \n\u2022 planning  \n\u2022 organising, and  \n\u2022 running a development project  \nHundreds of different models exist and are used, but many are minor variations \non a small number of basic models.  \n1.1. Plan ning with Models  \n(a ) SE projects usually live with a fixed financial budget. (An exception is \nmaintenance?) Additionally, time -to-market places a strong time \nconstraint. There will be other project constraints such as staff.", "mimetype": "text/plain", "start_char_idx": 81908, "end_char_idx": 85923, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "99dc1d3a-ad27-4f99-9792-0d80f2a044a4": {"__data__": {"id_": "99dc1d3a-ad27-4f99-9792-0d80f2a044a4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "31c69716-dd50-4e06-9d48-9721e28311ce", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4cccd09a2a1f7e00faefb291e4bde4d6ffbb13c46aa3f42284c0a36f6deb8111", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "84523f3d-015b-433e-914f-fcef694a1afa", "node_type": "1", "metadata": {}, "hash": "73b27ad7f3beb4d278f6dd140612b53db48f135dbb6d27f36956afa8df3a250e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "50 What are the various Rapid prototyping techniques?  \ni. Dynamic  high level  language  development.  ii. Database   \n programming. iii. Component and application assembly.   \n \n \n \n \n57  \n  \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 Discuss any four process models with suitable application.  NOV/DEC -10 , \nAPR/MAY -11, NOV/DEC -12, MAY/JUN -13 \nA software process model is a standardised format for  \n\u2022 planning  \n\u2022 organising, and  \n\u2022 running a development project  \nHundreds of different models exist and are used, but many are minor variations \non a small number of basic models.  \n1.1. Plan ning with Models  \n(a ) SE projects usually live with a fixed financial budget. (An exception is \nmaintenance?) Additionally, time -to-market places a strong time \nconstraint. There will be other project constraints such as staff.  \nProject planning is the art of sch eduling/constraint solving the project \nparameters, along various dimensions: time, money, staff \u2026 in order to optimize:  \n \u2022 project risk [low]  \n\u2022 profit [high]  \n\u2022customer satisfaction [high]  \n \u2022 Worker satisfaction [high]  \n\u2022 long/short -term company goals  \nProject parameters describe the whole project, but we must at least describe:  \n \u2022 resources needed (people, money, equipment, etc)  \n \u2022 dependency & timing of work (flow graph, work packages)  \n \u2022 rate of delivery (reports, code, etc)  \n \nIn addition to project member s, the following may need access to parts of the \nproject plan:  \n\u2022 Management  \n \u2022 Customers  \n58  \n \u2022 Subcontractors (outsourcing)  \n\u2022 Suppliers (e.g. licenses, strategic partners)  \n \u2022 Investors (long term investment)  \n\u2022 Banks (short term cash)  \n1.2. Project Visibilit y \nUnlike other engineers (e.g. civil, electronic, chemical \u2026 etc.) software \nengineers do not produce anything physical.  \nThis means that SE projects must produce additional deliverables (artifacts) \nwhich are visible, such as:  \n\u2022 Design documents/ prototypes   \n\u2022 Reports  \n\u2022 Project/status meetings  \n\u2022 Client surveys (e.g. satisfaction level)  \nA (software/system) process model is a description of the sequence of activities \ncarried out in an SE project, and the relative order of these activities.  \nIt provides a fixe d generic framework that can be tailored to a specific project. \nProject specific parameters will include:  \n \u2022 Size, (person -years)  \n\u2022 Budget,  \n Duration.  \n project plan = process model + project parameters  \nThere are hundreds of different process models to ch oose from, e.g:  \n\u2022 waterfall,  \n \u2022 code-and-fix  \n\u2022 spiral \n \u2022 rapid prototyping  \n \u2022 unified process (UP)  \n \u2022 agile methods, extreme programming (XP)  \n\u2022 COTS \u2026  \nBut most are minor variations on a small number of basic models . \nBy changing the process model, we ca n improve and/or tradeoff:  \n \u2022 Development speed (time to market)  \n59  \n \u2022 Product quality  \n Project visibility  \n \u2022 Administrative overhead  \n \u2022 Risk exposure  \n \u2022 Customer relations, etc.  \nNormally, a process model covers the entire lifetime of a product.  \nFrom birth of a commercial idea to final de -installation of last release i.e.  \nThe three main phases:  \n \u2022 design,  \n\u2022 build,  \n\u2022 maintain .  \nWe can sometimes combine process models  \ne.g. 1. waterfall inside evolutionary \u2013 onboard shuttle software  \n 2. Evolutionary inside waterfall \u2013 e.g. GUI prototyping  \nWe can also evolve the proc ess model together with the product to \naccount for product maturity, e.g. rapid prototyping \u2192 waterfall  \n2 Explain the execution of seven distinct functions accomplished in requirement \nengineering process / Explain briefly the requirement engineering proce ss with neat \nsketch and describe each process with an example.  APRIL/MAY -15 NOV/DEC -15, \nNOV/DEC 2017, APRIL/MAY  2017  \nIntroduction to requirement engineering  \niv. The process of collecting the software requirement from the client then understand, \nevaluate and do cument it is called as requirement engineering.  \nv. Requirement engineering constructs a bridge for design and construction.  \nRequirement engineering consists of seven different tasks as follow:  \n \n1. Inception  \n\uf0b7 Inception is a task where the requirement engineerin g asks a set of questions to \nestablish a software process.  \n\uf0b7 In this task, it understands the problem and evaluates with the proper solution.  \n\uf0b7 It collaborates with the relationship between the customer and the developer.  \n\uf0b7 The developer and customer decide the overall scope and the nature of the question.  \n2.", "mimetype": "text/plain", "start_char_idx": 85098, "end_char_idx": 89561, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "84523f3d-015b-433e-914f-fcef694a1afa": {"__data__": {"id_": "84523f3d-015b-433e-914f-fcef694a1afa", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "99dc1d3a-ad27-4f99-9792-0d80f2a044a4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5e51bf906d5d9c6067852301dba86be43778c26e276bc012a008c51d01f28a05", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73afbf76-da3b-4e43-8d47-d567d3bce4d5", "node_type": "1", "metadata": {}, "hash": "b180bfa216cbf71f58ea09b3160e5d23059223186f1f295873ab0ec81eaecde7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "APRIL/MAY -15 NOV/DEC -15, \nNOV/DEC 2017, APRIL/MAY  2017  \nIntroduction to requirement engineering  \niv. The process of collecting the software requirement from the client then understand, \nevaluate and do cument it is called as requirement engineering.  \nv. Requirement engineering constructs a bridge for design and construction.  \nRequirement engineering consists of seven different tasks as follow:  \n \n1. Inception  \n\uf0b7 Inception is a task where the requirement engineerin g asks a set of questions to \nestablish a software process.  \n\uf0b7 In this task, it understands the problem and evaluates with the proper solution.  \n\uf0b7 It collaborates with the relationship between the customer and the developer.  \n\uf0b7 The developer and customer decide the overall scope and the nature of the question.  \n2. Elicitation  \n60  \n Elicitation means to find the requirements from anybody.  \nThe requirements are difficult because the  following problems occur in elicitation . \n \nProblem of scope:  The customer give the unnecessary t echnical detail rather than \nclarity of the overall system objective.  \n \nProblem of understanding:  Poor understanding between the customer and the \ndeveloper regarding various aspect of the project like capability, limitation of the \ncomputing environment.  \n \nProblem of volatility:  In this problem, the requirements change from time to time \nand it is difficult while developing the project.  \n \n3. Elaboration  \n\uf0b7 In this task, the information taken from user during inception and elaboration and are \nexpanded and refined in elaboration.  \n\uf0b7 Its main task is developing pure model of software using functions, feature and \nconstraints of a software.  \n4. Negotiation  \n\uf0b7 In negotiation task, a software engineer decides the how will the   project be achieved \nwith limited business resources.  \n\uf0b7 To create rough guesses of development and access the impact of the requirement on \nthe project cost and delivery time.  \n5. Specification  \n\uf0b7 In this task, the requirement engineer constructs a final work product.  \n\uf0b7 The work product is in the form of software requi rement specification.  \n\uf0b7 In this task, formalize the requirement of the proposed software such as informative, \nfunctional and behavioral.  \n\uf0b7 The requirement are formalize in both graphical and textual formats.  \n6. Validation  \n\uf0b7 The work product is built as an output  of the requirement engineering and that is \naccessed for the quality through a validation step.  \n\uf0b7 The formal technical reviews from the software engineer, customer and other \nstakeholders helps for the primary requirements validation mechanism.  \n7. Requirement  management  \n\uf0b7 It is a set of activities that help the project team to identify, control and track the \nrequirements and changes can be made to the requirements at any time of the ongoing \nproject.  \n\uf0b7 These tasks start with the identification and assign a unique i dentifier to each of the \nrequirement.  \n61  \n \uf0b7 After finalizing the requirement traceability table is developed.  \n\uf0b7 The examples of traceability table are the features, sources, dependencies, subsystems \nand interface of the requirement  \n3 What is data dictionary? Expl ain. How to select the appropriate  prototyping\n approach? APR/MAY -11, APR/MAY -12, NOV/DEC2015  \nIs a reference work of data about data (metadata), one that is compiled by  \nthe systems analyst to guide them through the analysis and design.  \nIs the information you  see in the data dictionary.  \n\u2022 It is where the systems analyst goes to define or look up information about  \nentities, attributes and relationships on the ERD (Entity Relationship Design).  \nImportance of a Data Dictionary  \nAvoid duplication  \n\u2022 Allows better com munication between organizations who shares the same  \ndatabase.  \n\u2022 Makes maintenance straightforward  \n\u2022 It is valuable for their capacity to cross -referencing data items.  \nUses of Data Dictionary  \nValidates the date flow diagram for completeness and accuracy  \n\u2022 Provides starting point for developing screen and reports.  \n\u2022 Determine the contents of data stored files  \n\u2022 Develop the logic for data flow diagram processes.  \nThe Data Repository  \n \n4 How does the analysis modeling help to capture unambiguous & consistent \nrequirements? Discuss several methods for requirements validation? NOV/DEC -11 \nData modeling is a  process  used to define and analyze data  requirements  needed to support \nthe business processes  within the scope of corresponding information systems in \norganizations. Therefore, the process of data modeling involves professional data modelers \nworking closely with business stakeholders, as well as potential users of the information \nsystem.  \nThere are three different types of data models produced while pr ogressing from \nrequirements to the actual database to be used for the information system.", "mimetype": "text/plain", "start_char_idx": 88764, "end_char_idx": 93608, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73afbf76-da3b-4e43-8d47-d567d3bce4d5": {"__data__": {"id_": "73afbf76-da3b-4e43-8d47-d567d3bce4d5", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "84523f3d-015b-433e-914f-fcef694a1afa", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e79f502118a27ebf8fe2178318d0659172c36be969ca6768ab29401531c0f5f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b16dbabf-14bc-4c5b-8e4a-40b81cf29048", "node_type": "1", "metadata": {}, "hash": "08901eb58ed3a9cd98ffa02b7e7bcdbdd4feaae3c7c3c4bceb7ed0afe01f54b5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Uses of Data Dictionary  \nValidates the date flow diagram for completeness and accuracy  \n\u2022 Provides starting point for developing screen and reports.  \n\u2022 Determine the contents of data stored files  \n\u2022 Develop the logic for data flow diagram processes.  \nThe Data Repository  \n \n4 How does the analysis modeling help to capture unambiguous & consistent \nrequirements? Discuss several methods for requirements validation? NOV/DEC -11 \nData modeling is a  process  used to define and analyze data  requirements  needed to support \nthe business processes  within the scope of corresponding information systems in \norganizations. Therefore, the process of data modeling involves professional data modelers \nworking closely with business stakeholders, as well as potential users of the information \nsystem.  \nThere are three different types of data models produced while pr ogressing from \nrequirements to the actual database to be used for the information system.[2] The data \nrequirements are initially recorded as a  conceptual data model  which is essentially a set of \ntechnology independent specifications about the data and is used to discuss initial \nrequirements with the business stakeholders. The  conceptual model  is then translated into \na logical data model , which documents structures of the data that can be implemented in \ndatabases. Implementation of one conceptual data model may require multiple logical data \nmodels. The last step in data modeling is transforming the logical data model to a  physical \ndata model  that organizes the data into tables, and accounts for access, performance and \n62  \n storage details. Data modeling defines not just data elements, but also their structures and \nthe relationships b etween them.[3] \nData modeling techniques and methodologies are used to model data in a standard, \nconsistent, predictable manner in order to manage it as a resource. The use of dat a modeling \nstandards is strongly recommended for all projects requiring a standard means of defining \nand analyzing data within an organization, e.g., using data modeling:  \n\uf0b7 to assist business analysts, programmers, testers, manual writers, IT package \nselecto rs, engineers, managers, related organizations and clients to understand and use \nan agreed semi -formal model the concepts of the organization and how they relate to \none another  \n\uf0b7 to manage data as a resource  \n\uf0b7 for the integration of information systems  \n\uf0b7 for des igning databases/data warehouses (aka data repositories)  \nData modeling may be performed during various types of projects and in multiple phases of \nprojects. Data models are progressive; there is no such thing as the final data model for a \nbusiness or appli cation. Instead a data model should be considered a living document that \nwill change in response to a changing business. The data models should ideally be stored in \na repository so that they can be retrieved, expanded, and edited over time.    \n\uf0b7 Strategic dat a modeling: This is part of the creation of an information systems strategy, \nwhich defines an overall vision and architecture for information systems.  Information \ntechnology engineering  is a methodology that embraces this approach.  \n\uf0b7 Data modeling during systems analysis: In  systems analysis  logical data mo dels are created \nas part of the development of new databases.  \nData modeling is also used as a technique for detailing business  requirements  for specific  databases . \nIt is sometimes called  database modeling  because a  data model  is eventually implemented in a \ndatabase.  \n \n5 Explain prototyping in t he software process. APRIL/MAY -15 MAY/JUNE 2016  \nThe prototyping model  is applied when detailed  information  related to input and output \nrequirements of the system is not available. In this model, it is assumed that all the \nrequirements may not be known at the start of the development of the system. It is usually \nused when a system does not exist or in case of a lar ge and complex system where there is no \nmanual process to determine the requirements. This model allows the users to interact and \nexperiment with a working model of the system known as  prototype.  The prototype gives the \nuser an actual feel of the system.  \nAt any stage, if the user is not satisfied with the prototype, it can be discarded and an entirely new \nsystem can be developed. Generally, prototype can be prepared by the approaches listed below.  \n\u2022 By creating main user interfaces without any substantial c oding so that users can get a feel of how \nthe actual system will appear.  \n\u2022 By abbreviating a version of the system that will perform limited subsets of functions.  \n\u2022 By using system components to illustrate the functions that will be included in the system to be \ndeveloped .  \n63  \n  Using the prototype, the client can get an actual feel of the system. So, this case of model is \nbeneficial in the case when requirements cannot be freezed initially.", "mimetype": "text/plain", "start_char_idx": 92648, "end_char_idx": 97605, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b16dbabf-14bc-4c5b-8e4a-40b81cf29048": {"__data__": {"id_": "b16dbabf-14bc-4c5b-8e4a-40b81cf29048", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73afbf76-da3b-4e43-8d47-d567d3bce4d5", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "dd3e1693c3191fd3fb2e2391f427f0a25a35054185d7686e234eda5e0990d5e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ec67c4d3-66b9-4f24-9c58-57113ad812ea", "node_type": "1", "metadata": {}, "hash": "3932fd50a631362a49ff6b463ef9bae9bd4debd3e53873c5466b34944c34cfb0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This model allows the users to interact and \nexperiment with a working model of the system known as  prototype.  The prototype gives the \nuser an actual feel of the system.  \nAt any stage, if the user is not satisfied with the prototype, it can be discarded and an entirely new \nsystem can be developed. Generally, prototype can be prepared by the approaches listed below.  \n\u2022 By creating main user interfaces without any substantial c oding so that users can get a feel of how \nthe actual system will appear.  \n\u2022 By abbreviating a version of the system that will perform limited subsets of functions.  \n\u2022 By using system components to illustrate the functions that will be included in the system to be \ndeveloped .  \n63  \n  Using the prototype, the client can get an actual feel of the system. So, this case of model is \nbeneficial in the case when requirements cannot be freezed initially.  \n This prototype is developed based on the currently known requirements.  Development of the \nprototype obviously undergoes design, coding, and testing,   but each of these phases is not done \nvery formally or thoroughly.   \nBy using this prototype, the client can get an actual feel of the system, because the interactions with \nthe p rototype can enable the client to better understand the requirements of the desired system . \n \n6 Explain the functional & behavioral model for software  \n requirements  process?  NOV/DEC -12, MAY/JUN - 13,NOV/DEC 2013  \n functional requirement  specifies something that the application or system should do. \nOften, this is defined as a behavior of the system that takes input and provides output. For \nexample, a traveler fills out a form in an airline's mobile application with his/her name and \npassport details (input), s ubmits the form, and the application generates a boarding pass \nwith the traveler's details (output).  \nNon-functional requirements , sometimes also called quality requirements, describe how \nthe system should be, as opposed to what it should do. Non -functional  requirements of a \nsystem include performance (e.g., response time), maintainability and scalability, among \nmany others. In the airline application example, the requirement that the application must \ndisplay the boarding pass after a maximum of five seconds  from the time the traveler \npresses the 'submit' button would be a non -functional requirement.  \n \n7 Explain metrics for specifying non -functional requirements? IEEE standarad \nsoftware requirement document? MAY/JUN - 13 \nAccording to IEEE standard 729, a requi rement is defined as follows:  \n\uf0b7 A condition or capability needed by a user to solve a problem or achieve an objective  \n\uf0b7 A condition or capability that must be met or possessed by a system or system component to \nsatisfy a contract, standard, specification or ot her formally imposed documents  \n\uf0b7 A documented representation of a condition or capability as in 1 and 2.  \nA software requirement can be of 3 types:  \n\uf0b7 Functional requirements  \n\uf0b7 Non-functional requirements  \n\uf0b7 Domain requirements  \nFunctional Requirements:  These are the requirements that the end user specifically demands as \nbasic facilities that the system should offer. All these functionalities need to be necessarily \nincorporated into the system as a part of the contract. These are represented or stated in the form of \ninput to be given to the system, the operation performed and the output expected. They are basically \nthe requirements stated by the user which one can see directly in the final product, unlike the non -\nfunctional requirements.  \nFor example, in a hospital manag ement system, a doctor should be able to retrieve the information \nof his patients. Each high -level functional requirement may involve several interactions or dialogues \nbetween the system and the outside world. In order to accurately describe the functional  \nrequirements, all scenarios must be enumerated.  \nThere are many ways of expressing functional requirements e.g., natural language, a structured or \n64  \n formatted language with no rigorous syntax and formal specification language with proper syntax.  \nNon-function al requirements:  These are basically the quality constraints that the system must \nsatisfy according to the project contract. The priority or extent to which these factors are \nimplemented varies from one project to other. They are also called non -behavioral  requirements.  \nThey basically deal with issues like:  \n\uf0b7 Portability  \n\uf0b7 Security  \n\uf0b7 Maintainability  \n\uf0b7 Reliability  \n\uf0b7 Scalability  \n\uf0b7 Performance  \n\uf0b7 Reusability  \n\uf0b7 Flexibility  \nNFR\u2019s are classified into following types:  \n\uf0b7 Interface constraints  \n\uf0b7 Performance constraints: response time, s ecurity, storage space, etc.  \n\uf0b7 Operating constraints  \n\uf0b7 Life cycle constraints: maintainability, portability, etc.", "mimetype": "text/plain", "start_char_idx": 96714, "end_char_idx": 101529, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ec67c4d3-66b9-4f24-9c58-57113ad812ea": {"__data__": {"id_": "ec67c4d3-66b9-4f24-9c58-57113ad812ea", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b16dbabf-14bc-4c5b-8e4a-40b81cf29048", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1539dc9a528c2231bc272b2ad98a2bbe266a29ecebffafadfb9f9f35998e327c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "564f3a27-50c9-4436-b690-b44ba03eb60f", "node_type": "1", "metadata": {}, "hash": "41b58e4646a82369594ff53e9e2fd90ed623a72db2bb303d74513524475ad33a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "There are many ways of expressing functional requirements e.g., natural language, a structured or \n64  \n formatted language with no rigorous syntax and formal specification language with proper syntax.  \nNon-function al requirements:  These are basically the quality constraints that the system must \nsatisfy according to the project contract. The priority or extent to which these factors are \nimplemented varies from one project to other. They are also called non -behavioral  requirements.  \nThey basically deal with issues like:  \n\uf0b7 Portability  \n\uf0b7 Security  \n\uf0b7 Maintainability  \n\uf0b7 Reliability  \n\uf0b7 Scalability  \n\uf0b7 Performance  \n\uf0b7 Reusability  \n\uf0b7 Flexibility  \nNFR\u2019s are classified into following types:  \n\uf0b7 Interface constraints  \n\uf0b7 Performance constraints: response time, s ecurity, storage space, etc.  \n\uf0b7 Operating constraints  \n\uf0b7 Life cycle constraints: maintainability, portability, etc.  \n\uf0b7 Economic constraints  \nThe process of specifying non -functional requirements requires the knowledge of the functionality \nof the system, as well as t he knowledge of the context within which the system will operate.  \nDomain requirements:  Domain requirements are the requirements which are characteristic of a \nparticular category or domain of projects. The basic functions that a system of a specific domain \nmust necessarily exhibit come under this category. For instance, in academic software that maintains \nrecords of a school or college, the functionality of being able to access the list of faculty and list of \nstudents of each grade is a domain requirement. T hese requirements are therefore identified from \nthat domain model and are not user specific.  \n \n \n \n8 What is requirements elicitation ? Explain various activities performed in it with \nwatch system that facilitates to set time and alarm as an example? NOV/DEC 2016, \nAPRIL/MAY  2017, APRIL/MAY 2018  \nRequirements  elicitation  is perhaps the most difficult, most error -prone and most communication \nintensive software development. It can be successful only through an effective customer -developer \npartnership. It is needed  to know what the users really need.  \nThere are a number of requirements elicitation methods. Few of them are listed below \u2013 \n1. Interviews  \n2. Brainstorming Sessions  \n3. Facilitated Application Specification Technique (FAST)  \n4. Quality Function Deployment (QFD)  \n5. Use Case Approach  \nThe success of an elicitation technique used depends on the maturity of the analyst, developers, \nusers and the customer involved.  \n1. Interviews:  \nObjective of conducting an interview is to understand the customer\u2019s expectations from the \nsoftware.  \nIt is impossible to interview every stakeholder hence representatives from groups are selected based \n65  \n on their expertise and credibility.  \nInterviews maybe be open ended or structured.  \n1. In open ended interviews there is no pre -set agenda. Context free question s may be asked to \nunderstand the problem.  \n2. In structured interview, agenda of fairly open questions is prepared. Sometimes a proper \nquestionnaire is designed for the interview.  \n2. Brainstorming Sessions:  \n\uf0b7 It is a group technique  \n\uf0b7 It is intended to generate lo ts of new ideas hence providing a platform to share views  \n\uf0b7 A highly trained facilitator is required to handle group bias and group conflicts.  \n\uf0b7 Every idea is documented so that everyone can see it.  \n\uf0b7 Finally a document is prepared which consists of the list of requirements and their priority if \npossible.  \n3. Facilitated Application Specification Technique:  \nIt\u2019s objective is to bridge the expectation gap \u2013 difference between what the developers think they \nare supposed to build and what customers think they are goi ng to get.  \nA team oriented approach is developed for requirements gathering.  \nEach attendee is asked to make a list of objects that are - \n1. Part of the environment that surrounds the system  \n2. Produced by the system  \n3. Used by the system  \nEach participant prepares hi s/her list, different lists are then combined, redundant entries are \neliminated, team is divided into smaller sub -teams to develop mini -specifications and finally a draft \nof specifications is written down using all the inputs from the meeting.  \n4. Quality F unction Deployment:  \nIn this technique customer satisfaction is of prime concern, hence it emphasizes on the requirements \nwhich are valuable to the customer.  \n3 types of requirements are identified \u2013 \n\uf0b7 Normal  requirements  \u2013 In this the objective and goals of t he proposed software are \ndiscussed with the customer.", "mimetype": "text/plain", "start_char_idx": 100633, "end_char_idx": 105222, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "564f3a27-50c9-4436-b690-b44ba03eb60f": {"__data__": {"id_": "564f3a27-50c9-4436-b690-b44ba03eb60f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ec67c4d3-66b9-4f24-9c58-57113ad812ea", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "504b40fec89ea933378344346ef339877a572f054fe24b0a3aec0d2e9626d9dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3", "node_type": "1", "metadata": {}, "hash": "b60f7a9e6bc8795660282369c48ba3202aff9cdb5c1c8261fca6f59b468e340a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A team oriented approach is developed for requirements gathering.  \nEach attendee is asked to make a list of objects that are - \n1. Part of the environment that surrounds the system  \n2. Produced by the system  \n3. Used by the system  \nEach participant prepares hi s/her list, different lists are then combined, redundant entries are \neliminated, team is divided into smaller sub -teams to develop mini -specifications and finally a draft \nof specifications is written down using all the inputs from the meeting.  \n4. Quality F unction Deployment:  \nIn this technique customer satisfaction is of prime concern, hence it emphasizes on the requirements \nwhich are valuable to the customer.  \n3 types of requirements are identified \u2013 \n\uf0b7 Normal  requirements  \u2013 In this the objective and goals of t he proposed software are \ndiscussed with the customer. Example \u2013 normal requirements for a result management system \nmay be entry of marks, calculation of results etc  \n\uf0b7 Expected  requirements  \u2013 These requirements are so obvious that the customer need not \nexplic itly state them. Example \u2013 protection from unauthorised access.  \n\uf0b7 Exciting  requirements  \u2013 It includes features that are beyond customer\u2019s expectations and \nprove to be very satisfying when present. Example \u2013 when an unauthorised access is detected, it \nshould backup and shutdown all processes.  \nThe major steps involved in this procedure are \u2013 \n1. Identify all the stakeholders, eg. Users, developers, customers etc  \n2. List out all requirements from customer.  \n3. A value indicating degree of importance is assigned to each req uirement.  \n4. In the end the final list of requirements is categorised as \u2013 \n\uf0b7 It is possible to achieve  \n\uf0b7 It should be deferred and the reason for it  \n\uf0b7 It is impossible to achieve and should be dropped off  \n5. Use Case Approach:  \nThis technique combines text and pictu res to provide a better understanding of the requirements.  \nThe use cases describe the \u2018what\u2019, of a system and not \u2018how\u2019. Hence they only give a functional \nview of the system.  \nThe components of the use case deign includes three major things \u2013 Actor, Use cas es, use case \n66  \n diagram.  \n1. Actor  \u2013 It is the external agent that lies outside the system but interacts with it in some way. \nAn actor maybe a person, machine etc. It is represented as a stick figure. Actors can be primary \nactors or secondary actors.  \n\uf0b7 Primary acto rs \u2013 It requires assistance from the system to achieve a goal.  \n\uf0b7 Secondary actor \u2013 It is an actor from which the system needs assistance.  \n2. Use cases  \u2013 They describe the sequence of interactions between actors and the system. They \ncapture who(actors) do what(i nteraction) with the system. A complete set of use cases specifies \nall possible ways to use the system.  \n3. Use case diagram  \u2013 A use case diiagram graphically represents what happens when an \nactor interacts with a system. It captures the functional aspect of t he system.  \n\uf0b7 A stick figure is used to represent an actor.  \n\uf0b7 An oval is used to represent a use case.  \n\uf0b7 A line is used to represent a relationship between an actor and a use case  \n \n \n9 What is the purpose of data flow diagrams? What are the notations used for the  \nsame. Explain by constructing a context flow diagram level -0 DFD and level -1 DFD \nfor a library management system? NOV/DEC 2016  \nIn Software engineering DFD(data flow diagram) can be drawn to represent the system of different \nlevels of abstraction. Higher level DFDs are partitioned into low levels -hacking more information \nand functional elements. Levels in DFD are numbered 0, 1, 2 or beyond. Here, we will see mainly 3 \nlevels in data flow diagram, which are: 0 -level DFD, 1 -level DFD, and 2 -level DFD.  \n0-level  DFD:  \nIt is also known as context diagram.It\u2019s designed to be an abstraction view, showing the system as a \nsingle process with its relationship to external entities. It represent the entire system as single bubble \nwith input and output data indicated by in coming/outgoing arrows.  \n \n1-level  DFD:  \nIn 1-level DFD, context diagram is decomposed into multiple bubbles/processes.in this level we \nhighlight the main functions of the system and breakdown the high level process of 0 -level DFD \ninto subprocesses.", "mimetype": "text/plain", "start_char_idx": 104373, "end_char_idx": 108634, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3": {"__data__": {"id_": "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "564f3a27-50c9-4436-b690-b44ba03eb60f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "971f11800e73bd72cabe5f3bdf6d9c64d840301626ac8c1d5fd56fb2a026ed67", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "371aba88-da90-4d25-9654-7dbdfe3f2c1e", "node_type": "1", "metadata": {}, "hash": "19b21a23dd151c13207690fd98d11c7f591d465f2056a04b5704c9742f1672e4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Higher level DFDs are partitioned into low levels -hacking more information \nand functional elements. Levels in DFD are numbered 0, 1, 2 or beyond. Here, we will see mainly 3 \nlevels in data flow diagram, which are: 0 -level DFD, 1 -level DFD, and 2 -level DFD.  \n0-level  DFD:  \nIt is also known as context diagram.It\u2019s designed to be an abstraction view, showing the system as a \nsingle process with its relationship to external entities. It represent the entire system as single bubble \nwith input and output data indicated by in coming/outgoing arrows.  \n \n1-level  DFD:  \nIn 1-level DFD, context diagram is decomposed into multiple bubbles/processes.in this level we \nhighlight the main functions of the system and breakdown the high level process of 0 -level DFD \ninto subprocesses.  \n \n67  \n \n \n2-level  DFD:  \n2-level DFD goes one step deeper into parts of 1 -level DFD.It can be used to plan or record \nthe specific/necessary detail about the system\u2019s functioning.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n68  \n  \n \n \n \n10 Consider the process of ordering a pizza over the phone. Draw the us e case diagram \nand also sketch the activity diagram representing each step of the process, from the \nmoment you pick up the phone to the point where you start eating the pizza. Include \nactivities that others need to perform. Add exception handling to the ac tivity \ndiagram you developed. Consider at least two exceptions.(Ex : Delivery person wrote \ndown wrong address, deliver person brings wrong pizza). NOV/DEC 2017  \n \n \n69  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n70  \n  \n \n11 Explain the feasibility studies. What are the outcomes? Does it have implicit or \nexplicit effects on software requirement  \ncollection. APRIL/MAY 2017  \nA feasibility study is carried out to select the best system that meets perfo rmance requirements.  \nThe main aim of the feasibility study activity is to determine whether it would be financially and \ntechnically feasible to develop the product. The feasibility study activity involves the analysis of \nthe problem and collection of all r elevant information relating to the product such as the different \ndata items which would be input to the system, the processing required to be carried out on these \ndata, the output data required to be produced by the system as well as various constraints o n the \nbehaviour of the system.  \n \n \nTechnical Feasibility  \nThis is concerned with specifying equipment and software that will successfully satisfy the user \nrequirement. The technical needs of the system may vary considerably, but might include :  \n\u2022 The facility  to produce outputs in a given time.  \n\u2022 Response time under certain conditions.  \n\u2022 Ability to process a certain volume of transaction at a particular speed.  \n\u2022 Facility to communicate data to distant locations.  \nIn examining technical feasibility, configuratio n of the system is given more importance than the \nactual make of hardware. The configuration should give the complete picture about the system\u2019s \nrequirements:  \nHow many workstations are required, how these units are interconnected so that they could operate  \nand communicate smoothly.  \nWhat speeds of input and output should be achieved at particular quality of printing.  \n \n \nEconomic Feasibility  \nEconomic analysis is the most frequently used technique for evaluating the effectiveness of a \nproposed system. More comm only known as Cost / Benefit analysis, the procedure is to determine \nthe benefits and savings that are expected from a proposed system and compare them with costs. If \nbenefits outweigh costs, a decision is taken to design and implement the system. Otherwis e, further \njustification or alternative in the proposed system will have to be made if it is to have a chance of \nbeing approved. This is an outgoing effort that improves in accuracy at each phase of the system \nlife cycle.  \n \n \nOperational Feasibility  \nThis is mainly related to human organizational and political aspects. The points to be considered \nare: \n\u2022 What changes will be brought with the system?  \n\u2022 What organizational structure are disturbed?  \n71  \n \u2022 What new skills will be required? Do the existing staff members have these skills? If not, can \nthey be trained in due course of time?  \nThis feasibility study is carried out by a small group of people who are familiar with information \nsystem technique and are skilled in system analysis and design process.  \nProposed projec ts are beneficial only if they can be turned into information system that will meet \nthe operating requirements of the organization. This test of feasibility asks if the system will work \nwhen it is developed and installed.", "mimetype": "text/plain", "start_char_idx": 107846, "end_char_idx": 112526, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "371aba88-da90-4d25-9654-7dbdfe3f2c1e": {"__data__": {"id_": "371aba88-da90-4d25-9654-7dbdfe3f2c1e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e764b5e9f0f7f78964da5dabd153cb31b662185ca7271ebe2f66a562e9cb60ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7072d991-c0d7-4229-826e-93ba7378a855", "node_type": "1", "metadata": {}, "hash": "dfd0fb11e583a248c16772a1dc6de150e2c645ceaf67f7a8452f8063eefda7a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This is an outgoing effort that improves in accuracy at each phase of the system \nlife cycle.  \n \n \nOperational Feasibility  \nThis is mainly related to human organizational and political aspects. The points to be considered \nare: \n\u2022 What changes will be brought with the system?  \n\u2022 What organizational structure are disturbed?  \n71  \n \u2022 What new skills will be required? Do the existing staff members have these skills? If not, can \nthey be trained in due course of time?  \nThis feasibility study is carried out by a small group of people who are familiar with information \nsystem technique and are skilled in system analysis and design process.  \nProposed projec ts are beneficial only if they can be turned into information system that will meet \nthe operating requirements of the organization. This test of feasibility asks if the system will work \nwhen it is developed and installed.  \n \n \n \n \n \n12 What is SRS?Explain in de tail about various component of an SRS.  \nThe output of the requirements phase of the software development process is  Software \nRequirements Specification (SRS)  (also known as  requirements  document).  This document lays \na foundation for software engineering ac tivities and is created when entire requirements are elicited \nand analyzed. SRS is a formal document, which acts as a representation of software that enables \nthe users to review whether it (SRS) is according to their requirements. In addition, it includes user \nrequirements for a system as well as detailed specifications of the system requirements.  \nIEEE  defines software requirements specification as, 'a document that clearly and precisely \ndescribes each of the essential requirements (functions, performance, design constraints and quality \nattributes) of the software and the external interfaces. Each requirement is defined in such a way that \nits achievement can be objectively verified by a prescribed method, for example, inspection, \ndemonstration, analysis or t est.' Note that requirements specification can be in the form of a \nwritten  document, a mathematical model, a collection of graphical models, a prototype,  and so on.  \nEssentially, what passes from requirements analysis activity to the specification activity is the \nknowledge acquired about the system. The need for maintaining a requirements document is that the \nmodeling activity essentially focuses on the problem structure and not its structural behavior. While \nin SRS, performance constraints, design constrain ts, and standard compliance recovery are clearly \nspecified. This  information  helps in developing a proper des ign of the system. Various other \npurposes served by SRS are listed below.  \n1. Feedback:  Provides a feedback, which ensures to the user that the organization (which \ndevelops the software) understands the issues or problems to be solved and the software behavior  \nnecessary to address those problems.  \n2. Decompose problem into components:  Organizes the information and divides the problem \ninto its component parts in an orderly manner.  \n3. Validation:  Uses validation strategies applied to the requirements to acknowledge that  \nrequirements are stated properly.  \n4. Input to design:  Contains sufficient detail in the functional system requirements to devise a \ndesign solution.  \n5. Basis for agreement between the  user and  the organization:  Provides a complete \ndescription of the functions to  be performed by the system. In addition, it helps the users to \ndetermine whether the specified requirements are accomplished.  \n6. Reduce the development effort:  Enables developers to consider user requirements before \nthe designing of the system commences. As a result, 'rework' and inconsistencies in the later stages \ncan be reduced.  \n7. Estimating costs and schedules:  Determines the requirements of the system and thus \nenables the developer to have a 'rough' estimate of the total cost and schedule of the project.  \nSRS is used by various individuals in the organization. System customers need SRS to specify and \n72  \n verify whether requirements meet the desired needs. In addition, SRS enables the managers to plan \nfor the system development processes. System engineers need a r equirements document to \nunderstand what system is to be developed. These engineers also require this document to develop \nvalidation tests for the required system. Lastly, requirements document is needed by system \nmaintenance engineers to use the requiremen t and the relationship between its parts.  \nCharacteristics of SRS  \nSoftware requirements specification should be accurate, complete, efficient, and of high quality, so \nthat it does not affect the entire project plan. An SRS is said to be of high quality when  the \ndeveloper and user easily understand the prepared document. Other characteristics of SRS are \ndiscussed below.  \n1. Correct:  SRS is correct when all user requirements are stated in the requirements \ndocument. The stated requirements should be according to th e desired system.", "mimetype": "text/plain", "start_char_idx": 111638, "end_char_idx": 116657, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7072d991-c0d7-4229-826e-93ba7378a855": {"__data__": {"id_": "7072d991-c0d7-4229-826e-93ba7378a855", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "371aba88-da90-4d25-9654-7dbdfe3f2c1e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "59f7c91c310c7f8f10f122916d573d568bdc95c7fafb77294c6279a60330e150", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0", "node_type": "1", "metadata": {}, "hash": "1075970934fecd38579d7cfdbab5c5a779d2d13f1bd866ac0eb0b25fbc38c8fc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In addition, SRS enables the managers to plan \nfor the system development processes. System engineers need a r equirements document to \nunderstand what system is to be developed. These engineers also require this document to develop \nvalidation tests for the required system. Lastly, requirements document is needed by system \nmaintenance engineers to use the requiremen t and the relationship between its parts.  \nCharacteristics of SRS  \nSoftware requirements specification should be accurate, complete, efficient, and of high quality, so \nthat it does not affect the entire project plan. An SRS is said to be of high quality when  the \ndeveloper and user easily understand the prepared document. Other characteristics of SRS are \ndiscussed below.  \n1. Correct:  SRS is correct when all user requirements are stated in the requirements \ndocument. The stated requirements should be according to th e desired system. This implies that each \nrequirement is examined to ensure that it (SRS) represents user requirements. Note that there is no \nspecified tool or procedure to assure the correctness of SRS. Correctness ensures that all specified \nrequirements a re performed correctly.  \n2. Unambiguous:  SRS is unambiguous when every stated requirement has only one \ninterpretation. This implies that each requirement is uniquely interpreted. In case there is a term used \nwith multiple meanings, the requirements document sh ould specify the meanings in the SRS so that \nit is clear and easy to understand.  \n3. Complete:  SRS is complete when the requirements clearly define what the software is \nrequired to do. This includes all the requirements related to performance, design and funct ionality.  \n4. Ranked for importance/stability:  All requirements are not equally important, hence each \nrequirement is identified to make differences among other requirements. For this, it is essential to \nclearly identify each requirement. Stability implies the probability of changes in the requirement in \nfuture.  \n5. Modifiable:  The requirements of the user can change, hence requirements document should \nbe created in such a manner that those changes can be modified easily, consistently maintaining the \nstructure and s tyle of the SRS.  \n6. Traceable:  SRS is traceable when the source of each requirement is clear and facilitates the \nreference of each requirement in future. For this, forward tracing and backward tracing are used. \nForward tracing implies that each requirement sh ould be traceable to design and code elements. \nBackward tracing implies defining each requirement explicitly referencing its source.  \n7. Verifiable:  SRS is verifiable when the specified requirements can be verified with a cost -\neffective process to check whethe r the final software meets those requirements. The requirements \nare verified with the help of reviews. Note that unambiguity is essential for verifiability.  \n8. Consistent:  SRS is consistent when the subsets of individual requirements defined do not \nconflict w ith each other. For example, there can be a case when different requirements can use \ndifferent terms to refer to the same object. There can be logical or temporal conflicts between the \nspecified requirements and some requirements whose logical or temporal characteristics are not \nsatisfied. For instance, a requirement states that an event 'a' is to occur before another event 'b'. But \nthen another set of requirements states (directly or indirectly by transitivity) that event 'b' should \noccur before event 'a'.  \nStructure of SRS  \nThe requirements document is devised in a manner that is easier to write, review, and maintain. It is \norganized into independent sections and each section is organized into modules or units. Note that \nthe level of detail to be included in  the SRS depends on the type of the system to be developed and \nthe process model chosen for its development. For example, if a system is to be developed by an \nexternal contractor, then critical system specifications need to be precise and detailed. Similar ly, \n73  \n when flexibility is required in the requirements and where an in -house development takes place, \nrequirements documents can be less detailed.  \nSince the requirements document serves as a foundation for subsequent software development \nphases, it is import ant to develop the document in the prescribed manner. For this, certain guidelines \nare followed while preparing SRS. These guidelines are listed below.  \n1. Functionality:  It should be separate from implementation.  \n2. Analysis model:  It should be developed accordi ng to the desired behavior of a system. This \nshould include data and functional response of a system to various inputs given to it.  \n3. Cognitive model:  It should be developed independently of design or implementation \nmodel.", "mimetype": "text/plain", "start_char_idx": 115741, "end_char_idx": 120562, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0": {"__data__": {"id_": "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7072d991-c0d7-4229-826e-93ba7378a855", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "8017b308972112b43aa7685e0181c1ad7f0b5ed99031ee9d5ab1cd85692da219", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ad683f83-3cba-44bc-af68-d626fc046445", "node_type": "1", "metadata": {}, "hash": "e341e86b35e8a954b2e01f6875af3303fb35dbd0fb8d8d8fe79155975a7a74cf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For example, if a system is to be developed by an \nexternal contractor, then critical system specifications need to be precise and detailed. Similar ly, \n73  \n when flexibility is required in the requirements and where an in -house development takes place, \nrequirements documents can be less detailed.  \nSince the requirements document serves as a foundation for subsequent software development \nphases, it is import ant to develop the document in the prescribed manner. For this, certain guidelines \nare followed while preparing SRS. These guidelines are listed below.  \n1. Functionality:  It should be separate from implementation.  \n2. Analysis model:  It should be developed accordi ng to the desired behavior of a system. This \nshould include data and functional response of a system to various inputs given to it.  \n3. Cognitive model:  It should be developed independently of design or implementation \nmodel. This model expresses a system as pe rceived by the users.  \n4. The content and structure  of the  specification:  It should be flexible enough to \naccommodate changes.  \n5. Specification:  It should be robust. That is, it should be tolerant towards incompleteness and \ncomplexity.  \nThe information to be inclu ded in SRS depends on a number of factors, for example, the type of \nsoftware being developed and the approach used in its development. If software is developed using \nthe iterative development process, the requirements document will be less detailed as comp ared to \nthat of the software developed for critical systems. This is because specifications need to be very \ndetailed and accurate in these systems. A number of standards have been suggested to develop a \nrequirements document. However, the most widely used standard is by IEEE, which acts as a \ngeneral framework. This general framework can be customized and adapted to meet the needs of a \nparticular organization.  \nEach SRS fits a certain pattern; thus, it is essential to standardize the structure of the requirem ents \ndocument to make it easier to understand. For this IEEE standard is used for SRS to organize \nrequirements for different projects, which provides different ways of structuring SRS. Note that in \nall requirements documents, the first two sections are the  same.  \nThis document comprises the following sections.  \n1. Introduction:  This provides an overview of the entire information described in SRS. This \ninvolves purpose and the scope of SRS, which states the functions to be performed by the system. In \naddition, it  describes definitions, abbreviations, and the acronyms used. The references used in SRS \nprovide a list of documents that is referenced in the document.  \n2. Overall description:  It determines the factors which affect the requirements of the system. \nIt provides  a brief description of the requirements to be defined in the next section called 'specific \nrequirement'. It comprises the following sub -sections.  \n3. Product perspective:  It determines whether the product is an independent product or an \nintegral part of the l arger product. It determines the interface with hardware, software, system, and \ncommunication. It also defines memory constraints and operations utilized by the user.  \n4. Product functions:  It provides a summary of the functions to be performed by the software . \nThe functions are organized in a list so that they are easily understandable by the user:  \n5. User characteristics:  It determines general characteristics of the users.  \n6. Constraints:  It provides the genera1 description of the constraints such as regulatory \npolicies, audit functions, reliability requirements, and so on.  \n7. Assumption and dependency:  It provides a list of assumptions and factors that affect the \nrequirements as stated in this document.  \n8. Apportioning of requirements:  It determines the requirements that  can be delayed until \nrelease of future versions of the system.  \n9. Specific requirements:  These determine all requirements in detail so that the designers can \ndesign the system in accordance with them. The requirements include description of every input and \noutput of the system and functions performed in response to the input provided. It comprises the \n74  \n following subsections.  \n10. External interface:  It determines the interface of the software with other systems, which \ncan include interface with  operating system  and so on. External interface also specifies  the \ninteraction of the software with users, hardware, or other software. The characteristics of each user \ninterface of the software product are specified in SRS. For the hardware interface, SRS specifies the \nlogical characteristics of each interface among  the software and hardware components. If the \nsoftware is to be executed on the existing hardware, then characteristics such as memory restrictions \nare also specified.", "mimetype": "text/plain", "start_char_idx": 119646, "end_char_idx": 124524, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ad683f83-3cba-44bc-af68-d626fc046445": {"__data__": {"id_": "ad683f83-3cba-44bc-af68-d626fc046445", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f66508c77706d5c2aa400fbdc2135d06065a9ddcfc1bae3b61e2dd367e0c0231", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3020acea-f8c9-4c84-af0e-018801cbd300", "node_type": "1", "metadata": {}, "hash": "052383752765f9497847683ba645ed40e4b11dd78953a92d44e0be74353aba51", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "9. Specific requirements:  These determine all requirements in detail so that the designers can \ndesign the system in accordance with them. The requirements include description of every input and \noutput of the system and functions performed in response to the input provided. It comprises the \n74  \n following subsections.  \n10. External interface:  It determines the interface of the software with other systems, which \ncan include interface with  operating system  and so on. External interface also specifies  the \ninteraction of the software with users, hardware, or other software. The characteristics of each user \ninterface of the software product are specified in SRS. For the hardware interface, SRS specifies the \nlogical characteristics of each interface among  the software and hardware components. If the \nsoftware is to be executed on the existing hardware, then characteristics such as memory restrictions \nare also specified.  \n11. Functions:  It determines the functional capabilities of the system. For each functional \nrequirement, the accepting and processing of inputs in order to generate outputs are specified. This \nincludes validity checks on inputs, exact sequence of operations, relationship of inputs to output, and \nso on.  \n12. Performance requirements:  It determines the performance constraints of the software \nsystem. Performance requirement is of two types: static requirements and dynamic \nrequirements.  Static requirements  (also known as  capacity requirements)  do not impose \nconstraints on the execution characteristics of t he system. These include requirements like number \nof terminals and users to be supported.  Dynamic requirements  determine the constraints on the \nexecution of the behavior of the system, which includes response time (the time between the start \nand ending of an operation under specified conditions) and throughput (total amount of work done \nin a given time).  \n13. Logical  database  of requirements:  It determines logical requirements to be stored in the \ndatabase. This includes type of information used, frequency of usage, data entities and relationships \namong them, and so on.  \n14. Design constraint:  It determines all design constraints that are imposed by standards, \nhardware limitations, and so on. Standard compliance determines requirements for the system, \nwhich are in compliance with the specified standards. These standards can include accounting \nprocedures and report format. Hardware limit ations implies when the software can operate on \nexisting hardware or some pre -determined hardware. This can impose restrictions while developing \nthe software design. Hardware limitations include hardware configuration of the machine and \noperating system to  be used.  \n15. Software system attributes:  It provide attributes such as reliability, availability, \nmaintainability and portability. It is essential to describe all these attributes to verify that they are \nachieved in the final system.  \n16. Organizing Specific Requi rements:  It determines the requirements so that they can be \nproperly organized for optimal understanding. The requirements can be organized on the basis of \nmode of operation, user classes, objects, feature, response, and functional hierarchy.  \n17. Change manage ment process:  It determines the change management process in order to \nidentify, evaluate, and update SRS to reflect changes in the project scope and requirements.  \n18. Document approvals:  These provide information about the approvers of the SRS document \nwith th e details such as approver's name, signature, date, and so on.  \n19. Supporting information:  It provides information such as table of contents, index, and so \non. This is necessary especially when SRS is prepared for large and complex projects.  \n \n \n  \n13 What is r equirement engineering? State its process and explain requirement elicitation \nproblem. (April/May 2008)  \nRequirement Engineering  \nThe process to gather the software requirements from client, analyze and document them is known \n75  \n as requirement engineering.  \nThe goal of requirement engineering is to develop and maintain sophisticated and descriptive \n\u2018System Requirements Specification\u2019 document.  \nRequirement Engineering Process  \nIt is a four step process, which includes \u2013 \n\uf0b7 Feasibility Study  \n\uf0b7 Requirement Gathering  \n\uf0b7 Softw are Requirement Specification  \n\uf0b7 Software Requirement Validation  \nLet us see the process briefly - \nFeasibility study  \nWhen the client approaches the organization for getting the desired product developed, it comes up \nwith rough idea about what all functions the  software must perform and which all features are \nexpected from the software.  \nReferencing to this information, the analysts does a detailed study about whether the desired \nsystem and its functionality are feasible to develop.  \nThis feasibility study is focu sed towards goal of the organization.", "mimetype": "text/plain", "start_char_idx": 123582, "end_char_idx": 128510, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3020acea-f8c9-4c84-af0e-018801cbd300": {"__data__": {"id_": "3020acea-f8c9-4c84-af0e-018801cbd300", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ad683f83-3cba-44bc-af68-d626fc046445", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "aa62d66d333e186728e52f3c6b56798a63490f2a56d2c102a023da445ea499f4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ffd91dc4-ddd5-446a-94d4-ff98779c3baf", "node_type": "1", "metadata": {}, "hash": "e31a45569cd6f6e14d243a33d4fa0334072c45fd01a960224623bfbe19796663", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "(April/May 2008)  \nRequirement Engineering  \nThe process to gather the software requirements from client, analyze and document them is known \n75  \n as requirement engineering.  \nThe goal of requirement engineering is to develop and maintain sophisticated and descriptive \n\u2018System Requirements Specification\u2019 document.  \nRequirement Engineering Process  \nIt is a four step process, which includes \u2013 \n\uf0b7 Feasibility Study  \n\uf0b7 Requirement Gathering  \n\uf0b7 Softw are Requirement Specification  \n\uf0b7 Software Requirement Validation  \nLet us see the process briefly - \nFeasibility study  \nWhen the client approaches the organization for getting the desired product developed, it comes up \nwith rough idea about what all functions the  software must perform and which all features are \nexpected from the software.  \nReferencing to this information, the analysts does a detailed study about whether the desired \nsystem and its functionality are feasible to develop.  \nThis feasibility study is focu sed towards goal of the organization. This study analyzes whether the \nsoftware product can be practically materialized in terms of implementation, contribution of project \nto organization, cost constraints and as per values and objectives of the organizatio n. It explores \ntechnical aspects of the project and product such as usability, maintainability, productivity and \nintegration ability.  \nThe output of this phase should be a feasibility study report that should contain adequate comments \nand recommendations fo r management about whether or not the project should be undertaken.  \nRequirement Gathering  \nIf the feasibility report is positive towards undertaking the project, next phase starts with gathering \nrequirements from the user. Analysts and engineers communicate  with the client and end -users to \nknow their ideas on what the software should provide and which features they want the software to \ninclude.  \nSoftware Requirement Specification  \nSRS is a document created by system analyst after the requirements are collected  from various \nstakeholders.  \nSRS defines how the intended software will interact with hardware, external interfaces, speed of \noperation, response time of system, portability of software across various platforms, \nmaintainability, speed of recovery after cras hing, Security, Quality, Limitations etc.  \nThe requirements received from client are written in natural language. It is the responsibility of \nsystem analyst to document the requirements in technical language so that they can be \ncomprehended and useful by th e software development team.  \nSRS should come up with following features:  \n76  \n \uf0b7 User Requirements are expressed in natural language.  \n\uf0b7 Technical requirements are expressed in structured language, which is used inside the \norganization.  \n\uf0b7 Design description should be w ritten in Pseudo code.  \n\uf0b7 Format of Forms and GUI screen prints.  \n\uf0b7 Conditional and mathematical notations for DFDs etc.  \nSoftware Requirement Validation  \nAfter requirement specifications are developed, the requirements mentioned in this document are \nvalidated. Us er might ask for illegal, impractical solution or experts may interpret the requirements \nincorrectly. This results in huge increase in cost if not nipped in the bud. Requirements can be \nchecked against following conditions - \n\uf0b7 If they can be practically impl emented  \n\uf0b7 If they are valid and as per functionality and domain of software  \n\uf0b7 If there are any ambiguities  \n\uf0b7 If they are complete  \n\uf0b7 If they can be demonstrated  \nRequirement Elicitation Process  \nRequirement elicitation process can be depicted using the folloiwng diag ram: \n \n\uf0b7 Requirements gathering - The developers discuss with the client and end users and know \ntheir expectations from the  software.  \n\uf0b7 Organizing Requirements - The developers prioritize and arrange the requirements in \norder of importance, urgency and convenience.  \n\uf0b7 Negotiation & discussion - If requirements are ambiguous or there are some conflicts in \nrequirements of various sta keholders, if they are, it is then negotiated and discussed with \nstakeholders. Requirements may then be prioritized and reasonably compromised.  \nThe requirements come from various stakeholders. To remove the ambiguity and conflicts, \nthey are discussed for c larity and correctness. Unrealistic requirements are compromised \nreasonably.  \n\uf0b7 Documentation - All formal & informal, functional and non -functional requirements are \ndocumented and made available for next phase processing.  \nRequirement Elicitation Techniques  \nRequirements Elicitation is the process to find out the requirements for an intended software \nsystem by communicating with client, end users, system users and others who have a stake in the \nsoftware system development.  \nThere are various ways to discover req uirements  \n77  \n Interviews  \nInterviews are strong medium to collect requirements. Organization may conduct several types of \ninterviews such as:  \n\uf0b7 Structured (closed) interviews, where every single information to gather is decided in \nadvance, they follow pattern and  matter of discussion firmly.  \n\uf0b7 Non-structured (open) interviews, where information to gather is not decided in advance, \nmore flexible and less biased.", "mimetype": "text/plain", "start_char_idx": 127488, "end_char_idx": 132739, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ffd91dc4-ddd5-446a-94d4-ff98779c3baf": {"__data__": {"id_": "ffd91dc4-ddd5-446a-94d4-ff98779c3baf", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3020acea-f8c9-4c84-af0e-018801cbd300", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "055a7a3243dcf551e9e93e6ddc86ded3bcb58acad7f4c9a6d399704fa0277e66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c", "node_type": "1", "metadata": {}, "hash": "d4ae2717f79de734e3d4da8f653874827fbeda95226520f1ce6c1f52e4b5e38d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Unrealistic requirements are compromised \nreasonably.  \n\uf0b7 Documentation - All formal & informal, functional and non -functional requirements are \ndocumented and made available for next phase processing.  \nRequirement Elicitation Techniques  \nRequirements Elicitation is the process to find out the requirements for an intended software \nsystem by communicating with client, end users, system users and others who have a stake in the \nsoftware system development.  \nThere are various ways to discover req uirements  \n77  \n Interviews  \nInterviews are strong medium to collect requirements. Organization may conduct several types of \ninterviews such as:  \n\uf0b7 Structured (closed) interviews, where every single information to gather is decided in \nadvance, they follow pattern and  matter of discussion firmly.  \n\uf0b7 Non-structured (open) interviews, where information to gather is not decided in advance, \nmore flexible and less biased.  \n\uf0b7 Oral interviews  \n\uf0b7 Written interviews  \n\uf0b7 One-to-one interviews which are held between two persons across the tab le. \n\uf0b7 Group interviews which are held between groups of participants. They help to uncover any \nmissing requirement as numerous people are involved.  \n \n14 what is prototyping .explain its types types.(Nov/Dec 2009)  \nA prototype is a model version of a product. It\u2019s used as an early, inexpensive sample of a product \nthat helps to test its features or identify defects so improvements can be made to its final version.  \nPrototypes provides the opportunity to gather valuable feedback from stakeholders, partners or \ncustomers about the product. This information can be used to build a product that meets their \nrequirements.  \nFollowing are a few advantages of prototyping  \n\uf0b7 Collect feedback from users/ stakeholders about the functionality of the product before the \npublic release    \n\uf0b7 Reveal areas for improvement and help identify faults and usability issues before the public \nrelease. Help reduce unnecessary costs.   \n\uf0b7 Improve team efficiency and collaboration  \n\uf0b7 Allow the user to interact with a working model of their product  \n\uf0b7 Help conver t an abstract idea into a tangible product in a cost -effective way  \n\uf0b7 Identify if your product idea is a weak one and cost you heavily before actually moving \nforward with it  \nPrototyping Types  \nPrototyping methods and prototyping techniques can be categorized a s low -fidelity prototypes and \nhigh-fidelity prototypes.  \nBased on the resources available to you and the purpose for prototyping, the prototyping method \nyou choose can be either be low -fidelity or high -fidelity.  \nLow-Fidelity Prototypes  \nLow-fidelity prototyp es represent a simple and incomplete version of the final product. In a low -\nfidelity prototype, not all visual features and content elements are conveyed.  \n78  \n While it doesn\u2019t take much time or effort to translate a broad concept to a low -fidelity prototype, i t \ncan be used to gather user feedback during the early stage.  \nLow-fidelity prototyping methods  \nWireframes  \nWireframes are used to represent the basic structure of a website/ web page/ app. It serves as a \nblueprint, highlighting the layout of key elements on  a page and its functionality.   \nWith Creately, you can  create clickable wireframes  by adding links to the wireframe elements, that \nwill allow your users to navigate from one interface to the ot her \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n79  \n UNIT \u2013 3PART \u2013A \n \n \n \n \n \n \nS.NO  QUESTIONS  \n1 What are the primary interaction styles and state their advantages?  NOV/DEC -10 \n1. Direct manipulation - Easiest to grasp with immediate feedback , Difficult to  \nprogram  \n2. Menu selection  - User effort and errors minimized, large numbers and \ncombinations of choices a  problem  \n3. Form fill -in - Ease of use, simple data entry, Tedious, takes a lot of screen  space  \n4. Command language - Easy to program and process, Difficult to master for \ncasual  users \n5. Natural  language  - Great  for casual  users,  Tedious  for \nexpert users.  \n2 List the architectural  models  that can be developed. NOV/DEC -10 \nData -centered architectures, Data flow architectures, Call and return \narchitectures  \nObject -oriented architectures, Lay ered architectures.  \n3 What is meant by real time system design? APR/MAY -11 \n \n \nA real -time system is a software system where the correct functioning of the system  \ndepends on the results produced by the system and the time at which these \nresults  are \nproduced . \n4 List four design principles of a good design?", "mimetype": "text/plain", "start_char_idx": 131808, "end_char_idx": 136369, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c": {"__data__": {"id_": "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ffd91dc4-ddd5-446a-94d4-ff98779c3baf", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0388b7a7b7f53777ed16aad8d1cb230d55c14d66d775cf28b2958ad3c9be0ef6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b", "node_type": "1", "metadata": {}, "hash": "5eba136ef06752b4bcf3a37de9e679710822967714a7f4ed6c12143715fb5e0b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Form fill -in - Ease of use, simple data entry, Tedious, takes a lot of screen  space  \n4. Command language - Easy to program and process, Difficult to master for \ncasual  users \n5. Natural  language  - Great  for casual  users,  Tedious  for \nexpert users.  \n2 List the architectural  models  that can be developed. NOV/DEC -10 \nData -centered architectures, Data flow architectures, Call and return \narchitectures  \nObject -oriented architectures, Lay ered architectures.  \n3 What is meant by real time system design? APR/MAY -11 \n \n \nA real -time system is a software system where the correct functioning of the system  \ndepends on the results produced by the system and the time at which these \nresults  are \nproduced . \n4 List four design principles of a good design? APR/MAY - \n11APRIL/MAY 2018  \n80  \n  o Process should not suffer from tunnel  vision.  \no It should be traceable to the analysis  model  \no It should not reinvent the  wheel  \no It should exhibit uniformity &  integration.  \n5 List out design methods. APR/MAY -12 \nArchitectural design , data design , modular design.  \n6 Define data acquisition APR/MAY -12,MAY/JUN -13 \nCollect data from sensors for subsequent processing and analysis.  \n7 How do you apply modularization criteria for a monolit hic software NOV/DEC -12 \nModularity is achieved to various extents by different modularization approaches. Code \nbased modularity allows developers to reuse and repair parts of the application, but \ndevelopment tools are required to perform these maintenance functions .Object based \nmodularity provides the application as a collection of separate executable files which \nmay be independently maintained and replaced without redeploying  the \nentire application.  \n8 What is the design quality attributes \u2018FURPS\u2019 meant?  \nNOV/DEC -12, NOV/DEC2015, NOV/DEC2017  \nFURPS is an acronym representing a model for classifying software   quality   \nattributes    ( functional and non- functional  requirements ) \nFunctionality, Usability, Reliability, Performance and Supportab ility model.  \n81  \n 9 Define data abstraction? MAY/JUN -13 \nData abstraction is a named collection of data that describes the data  object.  \nEg:- Door attribute \u2013 door type, swing direction, weight  \n10 What are the elements of design model?  \ni. Data design  \nii. Architectural  design  \niii. Interface design  \niv. Component -level  design  \n11 What is the benefit of modular design?  \nChanges made during testing and maintenance becomes manageable and they do not \naffect other modules.  \n12 Name the commonly used architectural styles.  \ni. Data centere d architecture. ii. Data flow architecture.  \niii. Call   and return   architecture.  iv. Object -oriented architecture. v. Layered  \narchitecture.  \n13 What is a cohesive module?  \nA cohesive module performs only \u201cone task\u201d in software  \nprocedure with little intera ction with other modules. In other words cohesive module \nperforms only one thing.  \n82  \n 14 What are the different types of Cohesion?  \ni. Coincidentally cohesive \u2013The modules in which the set I \\of tasks are related with \neach other loosely then such modules are calle d coincidentally  cohesive.  \nii. Logically cohesive \u2013 A module that performs the tasks that are logically related \nwith each other is called logically cohesive.  \ni i i. Temporal cohesion \u2013 The module in which the tasks need to be executed in some \nspecific time span is called temporal cohesive.  \ni v. Procedural cohesion \u2013 When processing elements of a module are related with \nprocedural  cohesive.  \nv. Communicational cohesion \u2013 When the processing elements of a module share \nthe data then such module is called  \ncommunicational cohesive.  \n15 What is Coupling?What are the various types of coupling APRIL/MAY -15, \nCoupling is the measure of interconnection among modules in a program structure. It \ndepends on the interface complexity between modules.  \ni. Data coupling \u2013 The data coupling is possibl e by parameter passing or data  \ninteraction.  \nii . Control coupling \u2013 The modules share related control data in control  coupling.  \niii . Common coupling \u2013 The common data or a global data is shared among modules. \niv. Content coupling \u2013 Content coupling occurs when one m odule makes use of data or \ncontrol  information  \nmaintained in another module.  \n83  \n 16 What are the common activities in design process?", "mimetype": "text/plain", "start_char_idx": 135597, "end_char_idx": 139967, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b": {"__data__": {"id_": "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e0687df0c0ab5d4ae253bd890086873f2939b9c3cace9a078c8af625147453f0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eea8d6e7-9125-4c8f-be4a-f13c35dd0708", "node_type": "1", "metadata": {}, "hash": "a8d5ce08d72e97f7fc9d05d1bea646e70e81e4cb747888a7312ac6dcd10a3159", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "v. Communicational cohesion \u2013 When the processing elements of a module share \nthe data then such module is called  \ncommunicational cohesive.  \n15 What is Coupling?What are the various types of coupling APRIL/MAY -15, \nCoupling is the measure of interconnection among modules in a program structure. It \ndepends on the interface complexity between modules.  \ni. Data coupling \u2013 The data coupling is possibl e by parameter passing or data  \ninteraction.  \nii . Control coupling \u2013 The modules share related control data in control  coupling.  \niii . Common coupling \u2013 The common data or a global data is shared among modules. \niv. Content coupling \u2013 Content coupling occurs when one m odule makes use of data or \ncontrol  information  \nmaintained in another module.  \n83  \n 16 What are the common activities in design process?  \ni. System structuring \u2013 The system is subdivided into principle subsystems \ncomponents and communications between these subsystem s are identified.  \nii. Control modeling \u2013 A model of control relationships between different parts of \nthe system is established.  \niii. Modular decomposition \u2013 The identified subsystems  are \ndecomposed into modules  \n17 What are the benefits of horizontal partitioning?  \ni. Software that is easy to test. \nii. Software that is easier to  maintain.  \niii. Propagation of fewer sideeffects. iv. Software that is easier to  extend.  \n18 What is vertical partitioning? What are the advantages?  \nVertical partitioning often called factoring suggests t hat the control and work should \nbe distributed top -down in program structure.  \ni. These are easy to maintain changes.  \n ii. They reduce the change impact and error propagation  \n19 If a module has logical cohesion, what kind of coupling is this module likely  to have?  \nAPR/MAY 2016  \n \nIf a module has logical cohesion, then content coupling can be done. In content \ncoupling one module can make use of data or  \ncontrol information maintained in another  \n84  \n 20 Write the best practices for \"coding\u201d? APR/MAY 2015,  NOV/DEC20 15 \n \nBest coding practices are a set of informal rules that the software  development  community \nhas learned over time which can help improve the quality of software. \"The first 90% of the \ncode accounts for the first 90% of the development time. The remaining 10% of the code \naccounts for the other 90% of the development time.\" The size of a project or program has a \nsignificant e ffect on error rates, programmer productivity, and the amount of  \nmanagement needed.  \n21 What architectural styles are preferred for the following system? Why? \nNOV/DEC2016  \n(a) Networking \u2013 Data centered  Architecture  \n(b) Web based systems \u2013 Call and return  architect ure \n(c) Banking system - Data centered  Architecture.  \n22 What is DFD?  \nData Flow Diagram depicts the information flow and the  \ntransforms that are applied on the data as it moves from input to output.  \n23 Name the commonly used architectural styles . \ni. Data cent ered architecture. ii. Data flow architecture.  \niii. Call and return architecture. iv. Object -oriented architecture. v. Layered architecture.  \n24 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is  mainly used in database applications.  \n85  \n 25 What UI design patters are used for the following? NOV/DEC  2016, APRIL/MAY \n2017, APRIL/MAY 2018  \n(a) Page layout \u2013 interface  design  \n(b) Tables - Design  \n(c) Navigation through menus and web pages \u2013 design  \n(d) Shopping cart \u2013 interf ace design, task  analysis  \n26 What are the various elements of data design?  \ni. Data object \u2013 The data objects are identified and relationship among various data \nobjects can be represented using ERD or data  dictionaries.  \nii. Databases \u2013 Using software design model , the data models are translated into data \nstructures and data bases at the application  level.  \ni i i. Data warehouses \u2013 At the business level  useful  \ninformation is identified from various databases and the data warehouses are created.  \n27 List the guidelines for data design.  \ni. Apply systematic analysis on  data.  \nii. Identify data structures and related  operations.  \niii. Establish data  dictionary.  \niv. Use information hiding in the design of data structure.  \nv. Apply a library of useful data structures and  operations.  \n28 What is a Real  time system?", "mimetype": "text/plain", "start_char_idx": 139143, "end_char_idx": 143524, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "eea8d6e7-9125-4c8f-be4a-f13c35dd0708": {"__data__": {"id_": "eea8d6e7-9125-4c8f-be4a-f13c35dd0708", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1484188a36d1b749d2241b485fa1942ad48ecd726715817b9df3808d9e5b511e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4356756-edb8-4cae-8303-9b552d0cb3ac", "node_type": "1", "metadata": {}, "hash": "5338172b48a8f0e4688a58b864f40bc29dbc238b5e26f8a5bbc0beb01a5dbd95", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "i. Data object \u2013 The data objects are identified and relationship among various data \nobjects can be represented using ERD or data  dictionaries.  \nii. Databases \u2013 Using software design model , the data models are translated into data \nstructures and data bases at the application  level.  \ni i i. Data warehouses \u2013 At the business level  useful  \ninformation is identified from various databases and the data warehouses are created.  \n27 List the guidelines for data design.  \ni. Apply systematic analysis on  data.  \nii. Identify data structures and related  operations.  \niii. Establish data  dictionary.  \niv. Use information hiding in the design of data structure.  \nv. Apply a library of useful data structures and  operations.  \n28 What is a Real  time system?  \nReal time system is a software system in which the correct functionalities of the \nsystem are dependent upon results produced by the system and the time at which these \nresults are produced  \n29 How do you describe software interface? April /May  2015  \n86  \n  Software interface - the languages and codes that the applications use to communicate with \neach other and also with the hardware.  \nThree types of interface may have to be defined  \n\u2022 Procedural  interfaces;  \n\u2022 Data structures that are  exchanged;  \n\u2022 Data repres entations.  \nThe interface describes the behavior of a software component that is obtained by \nconsidering only the interactions of that interface and by hiding all other interactions.  \n30 Explain the qualitative criteria for measuring independence? NOV/DEC -11 \n1. Cohesion: Cohesion is a qualitative indication of the degree to which a module focuses on \njust one thing.  \n2. Coupling: Coupling is the measure of interconnection  among  \nmodules in a program structure. It depends on the interface complexity between modules  \n31 What is the purpose of a petrinet ? APRIL/MAY 2017  \nA Petri net, also known as a place/transition (PT) net, is one of several \nmathematical modeling languages  for the description of distributed systems. It is a class of \ndiscrete event dynamic system.  Petri nets offer a graphical notation  for stepwise processes \nthat \ninclude choice, iteration, and concurrent execution  \n32 What is vertical partitioning?  \nVertical partitioning often called factoring suggests that the control and work should be \ndistributed top -down in program structure.  \n87  \n 33 What are the benefits of horizontal partitionin g? \ni. Software that is easy to test. ii. Software that is easier to maintain. iii. Propagation of \nfewer side effects. iv. Software that is easier to extend.  \n34 What are data acquisition systems?  \n Systems that collect data from sensors for subsequent proc essing and analysis are termed as \ndata acquisition systems. Data collection processes and processing processes may have \ndifferent  \nperiods and deadlines.  \n35 What is interface design?  \nThe interface design describes how the software communicates  \nwithin itsel f, with systems that interoperate with it, and with humans who use it.  \n36 What are the elements of design model?  \nData design  \nii. Architectural  design  \niii. Interface design  \niv. Component -level  design  \n37 What is coupling?  \nCoupling is the measure of interconnection amon g modules in a program structure. It \ndepends on the interface complexity between modules.  \n38 Define design process . \nDesign process is a sequence of steps carried through which the requirements are translated \ninto a system or software model.  \n88  \n 39 What is Tr ansform mapping?  \nThe transform mapping is a set of design steps applied on the DFD  \nin order to map the transformed flow characteristics into specific architectural style.  \n40 What is component level design?  \nThe component level design transforms structural elements of the  \nsoftware architecture into a procedural description of software components.  \n41 What are the objectives of Analysis modeling?  \ni. To describe what the customer requires. ii. To establish a basis  \n for the creation of software design. iii. To  devise a set of valid  \nrequirements after which the software can be built.  \n42 What are the various types of coupling?  \niData coupling \u2013 The data coupling is possible by \nparameter passing or data interaction.  \nii. Control coupling  \u2013 \nThe modules share related con trol data in control coupling.  \niii. Common coupling  \u2013 \nThe common data or a global data is shared among modules.  \niv. Content coupling \u2013 Content coupling occurs \nwhen one module makes use of data or control information maintained in another  module.  \n43 What does modal ity in data modeling indicates?  \nModality indicates whether or not a particular data object must participate in the \nrelationship.", "mimetype": "text/plain", "start_char_idx": 142757, "end_char_idx": 147479, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e4356756-edb8-4cae-8303-9b552d0cb3ac": {"__data__": {"id_": "e4356756-edb8-4cae-8303-9b552d0cb3ac", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eea8d6e7-9125-4c8f-be4a-f13c35dd0708", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fbea3915c54bc62fb213e58b0d2a5ea21a7190271b1d714c2aef7498a16dd101", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "471b361c-eb0b-45d8-8153-818941ad81e9", "node_type": "1", "metadata": {}, "hash": "a29ea089461af109210a8945a5dac83dc1cdf696da63c4e4f2d1a94467d39bea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "41 What are the objectives of Analysis modeling?  \ni. To describe what the customer requires. ii. To establish a basis  \n for the creation of software design. iii. To  devise a set of valid  \nrequirements after which the software can be built.  \n42 What are the various types of coupling?  \niData coupling \u2013 The data coupling is possible by \nparameter passing or data interaction.  \nii. Control coupling  \u2013 \nThe modules share related con trol data in control coupling.  \niii. Common coupling  \u2013 \nThe common data or a global data is shared among modules.  \niv. Content coupling \u2013 Content coupling occurs \nwhen one module makes use of data or control information maintained in another  module.  \n43 What does modal ity in data modeling indicates?  \nModality indicates whether or not a particular data object must participate in the \nrelationship.  \n89  \n 44 What does Level0 DFD represent?  \nLevel 0 DFD is called as \u201efundamental system model\u201f or \u201econtext model\u201f. In the context \nmode l the entire software system is represented by a single bubble with input and output \nindicated by  \nincoming and outgoing arrows.  \n45 What are the elements of design model?  \ni. Data design ii. Architectural design iii. Interface design iv. Component -level des ign \n46 What is data modeling?  \nData modeling is the basic step in the analysis modeling. In data modeling the data objects \nare examined independently of processing. The data model represents how data are related \nwith  \none another.  \n47 What is a data object?  \nData object is a collection of attributes that act as an aspect,  \n characteristic,quality, or descriptor of the object  \n48 What are attributes?  \nAttributes are the one, which defines the properties of data object.  \n49 What is cardinality in data modeling?  \nCardinality in data modeling, cardinality specifies how the number of occurrences of one \nobject is related to the number of \noccurrences of another object.  \n50 What is ERD?  \nEntity Relationship Diagram is the graphical representation of the object relationsh ip pair. \nIt is mainly used in database applications  \n  \n \n \n \n90  \n PART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 Explain the core activities involved in User Interface design process with necessary \nblock diagrams MAY/JUNE 2016 ,NOV/DEC2015,  NOV/DEC 2017  \nUser interface is the front -end application view to which user interacts in order to use the software. \nUser can manipulate and control the software as well as hardware by means of user interface. \nToday, user interface is found at almost every place where digital technology exists, r ight from \ncomputers, mobile phones, cars, music players, airplanes, ships etc.  \nUser interface is part of software and is designed such a way that it is expected to provide the user \ninsight of the software. UI provides fundamental platform for human -compute r interaction.  \nUI can be graphical, text -based, audio -video based, depending upon the underlying hardware and \nsoftware combination. UI can be hardware or software or a combination of both.  \nThe software becomes more popular if its user interface is:  \n\uf0b7 Attract ive \n\uf0b7 Simple to use  \n\uf0b7 Responsive in short time  \n\uf0b7 Clear to understand  \n\uf0b7 Consistent on all interfacing screens  \nUI is broadly divided into two categories:  \n\uf0b7 Command Line Interface  \n\uf0b7 Graphical User Interface  \nCommand Line Interface (CLI)  \nCLI has been a great tool of intera ction with computers until the video display monitors came into \nexistence. CLI is first choice of many technical users and programmers. CLI is minimum interface \na software can provide to its users.  \nCLI provides a command prompt, the place where the user ty pes the command and feeds to the \nsystem. The user needs to remember the syntax of command and its use. Earlier CLI were not \nprogrammed to handle the user errors effectively.  \nA command is a text -based reference to set of instructions, which are expected to be executed by \nthe system. There are methods like macros, scripts that make it easy for the user to operate.  \nCLI uses less amount of computer resource as compared to GUI.  \nCLI Elements  \n91  \n \n \nA text -based command line interface can have the following elements:  \n\uf0b7 Command Prompt  - It is text -based notifier that is mostly shows the context in which the \nuser is working. It is generated by the software system.  \n\uf0b7 Curs or - It is a small horizontal line or a vertical bar of the height of line, to represent \nposition of character while typing. Cursor is mostly found in blinking state. It moves as the \nuser writes or deletes something.", "mimetype": "text/plain", "start_char_idx": 146635, "end_char_idx": 151199, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "471b361c-eb0b-45d8-8153-818941ad81e9": {"__data__": {"id_": "471b361c-eb0b-45d8-8153-818941ad81e9", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4356756-edb8-4cae-8303-9b552d0cb3ac", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "b28f84dc407ed8de90f61b1efaac968cad231fb0edc000da53aa1f53e6f3fb31", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea", "node_type": "1", "metadata": {}, "hash": "4e64e53caecf5b9dc61cc27bdb6ee22f174df5b47eb9e70b110feb06113316e6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The user needs to remember the syntax of command and its use. Earlier CLI were not \nprogrammed to handle the user errors effectively.  \nA command is a text -based reference to set of instructions, which are expected to be executed by \nthe system. There are methods like macros, scripts that make it easy for the user to operate.  \nCLI uses less amount of computer resource as compared to GUI.  \nCLI Elements  \n91  \n \n \nA text -based command line interface can have the following elements:  \n\uf0b7 Command Prompt  - It is text -based notifier that is mostly shows the context in which the \nuser is working. It is generated by the software system.  \n\uf0b7 Curs or - It is a small horizontal line or a vertical bar of the height of line, to represent \nposition of character while typing. Cursor is mostly found in blinking state. It moves as the \nuser writes or deletes something.  \n\uf0b7 Command  - A command is an executable in struction. It may have one or more parameters. \nOutput on command execution is shown inline on the screen. When output is produced, \ncommand prompt is displayed on the next line.  \nGraphical User Interface  \nGraphical User Interface provides the user graphical m eans to interact with the system. GUI can be \ncombination of both hardware and software. Using GUI, user interprets the software.  \nTypically, GUI is more resource consuming than that of CLI. With advancing technology, the \nprogrammers and designers create com plex GUI designs that work with more efficiency, accuracy \nand speed.  \nGUI Elements  \nGUI provides a set of components to interact with software or hardware.  \nEvery graphical component provides a way to work with the system. A GUI system has following \nelements such as:  \n92  \n \n \n\uf0b7 Window  - An area where contents of application are displayed. Contents in a window can \nbe displayed in the form of icons or lists, if the window represents file structure. It is easier \nfor a user to navigate in the file system in an exploring window. Windows can be \nminimized, resized or maximized to the size of screen. They can be moved anywhere on \nthe screen. A window may contain another wi ndow of the same application, called child \nwindow.  \n\uf0b7 Tabs  - If an application allows executing multiple instances of itself, they appear on the \nscreen as separate windows.  Tabbed Document Interface  has come up to open multiple \ndocuments in the same window. T his interface also helps in viewing preference panel in \napplication. All modern web -browsers use this feature.  \n\uf0b7 Menu  - Menu is an array of standard commands, grouped together and placed at a visible \nplace (usually top) inside the application window. The men u can be programmed to appear \nor hide on mouse clicks.  \n\uf0b7 Icon - An icon is small picture representing an associated application. When these icons \nare clicked or double clicked, the application window is opened. Icon displays application \nand programs installe d on a system in the form of small pictures.  \n\uf0b7 Cursor  - Interacting devices such as mouse, touch pad, digital pen are represented in GUI \nas cursors. On screen cursor follows the instructions from hardware in almost real -time. \nCursors are also named pointers in GUI systems. They are used to select menus, windows \nand other application features.  \nApplication specific GUI components  \nA GUI of an application contains one or more of the listed GUI elements:  \n\uf0b7 Application Window  - Most application windows uses the const ructs supplied by \noperating systems but many use their own customer created windows to contain the \ncontents of application.  \n\uf0b7 Dialogue Box  - It is a child window that contains message for the user and request for \nsome action to be taken. For Example: Applica tion generate a dialogue to get confirmation \n93  \n from user to delete a file.  \n\uf0b7 ext-Box - Provides an area for user to type and enter text -based data.  \n\uf0b7 Buttons  - They imitate real life buttons and are used to submit inputs to the software.  \n \n\uf0b7 Radio -button  - Displays available options for selection. Only one can be selected among \nall offered.  \n\uf0b7 Check -box - Functions similar to list -box. When an option is s elected, the box is marked \nas checked. Multiple options represented by check boxes can be selected.  \n\uf0b7 List-box - Provides list of available items for selection. More than one item can be \nselected.", "mimetype": "text/plain", "start_char_idx": 150330, "end_char_idx": 154675, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea": {"__data__": {"id_": "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "471b361c-eb0b-45d8-8153-818941ad81e9", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e48ac81b2c7c0e441f857e5d70a85f71fdb2a06497534e69e12ab24be975a53d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b6750083-b00d-4023-aa7d-371978f91439", "node_type": "1", "metadata": {}, "hash": "347331480b074bbb387e3f7e71f1baf756ab35c564ac18ac742f0fa50273e283", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Dialogue Box  - It is a child window that contains message for the user and request for \nsome action to be taken. For Example: Applica tion generate a dialogue to get confirmation \n93  \n from user to delete a file.  \n\uf0b7 ext-Box - Provides an area for user to type and enter text -based data.  \n\uf0b7 Buttons  - They imitate real life buttons and are used to submit inputs to the software.  \n \n\uf0b7 Radio -button  - Displays available options for selection. Only one can be selected among \nall offered.  \n\uf0b7 Check -box - Functions similar to list -box. When an option is s elected, the box is marked \nas checked. Multiple options represented by check boxes can be selected.  \n\uf0b7 List-box - Provides list of available items for selection. More than one item can be \nselected.  \n \nOther impressive GUI components are:  \n\uf0b7 Sliders  \n\uf0b7 Combo -box \n\uf0b7 Data -grid \n\uf0b7 Drop -down list  \n\uf0b7  \n94  \n \n \n \n2 Explain the various modular decomposition and control styles commonly used in any \norganizational model. MAY/JUNE 2016  \nModular decomposition  \nAnother structural level where sub -systems are decomposed into modules. \u25cf Two modular \ndecomposition models covered \u2022 An object model where the system is decomposed into interacting \nobject; \u2022 A pipeline or data -flow model where the system is decomposed into functional modules \nwhich transform inputs to outputs. \u25cf If possible, decisions about concurrency sh ould be delayed \nuntil modules are implemented  \nModular decomposition styles  \nStyles of decomposing sub -systems into modules. \u25cf No rigid distinction between system \norganisation and modular decomposition.  \nSub-systems and modules  \nA sub -system is a system in its  own right whose operation is independent of the services provided \nby other sub -systems. \u25cf A module is a system component that provides services to other \ncomponents but would not normally be considered as a separate system  \nControl styles  \nAre concerned with  the control flow between sub -systems. Distinct from the system \ndecomposition model.  \n95  \n  \u25cf Centralised control \u2022 One sub -system has overall responsibility for control and starts and stops \nother sub -systems.  \n \u25cf Event -based control \u2022 Each sub -system can respond  to externally generated events from other \nsub-systems or the system\u2019s environment.  \nCentralised control  \nA control sub -system takes responsibility for managing the execution of other sub -systems.  \n \u25cf Call -return model  \n \u2022 Top -down subroutine model where contr ol starts at the top of a subroutine hierarchy and moves \ndownwards. Applicable to sequential systems.  \n \u25cf Manager model  \n \u2022 Applicable to concurrent systems.  \n\uf0b7 One system component controls the stopping, starting and coordination of other system \nprocesses. Ca n be implemented in sequential systems as a case statement.  \nEvent -driven systems  \nDriven by externally generated events where the timing of the event is outwith the control \nof the subsystems which process the event.  \n \u25cf Two principal event -driven models  \n \u2022 Broadcast models. An event is broadcast to all subsystems. Any sub -system which can \nhandle the event may do so;  \n \u2022 Interrupt -driven models. Used in real -time systems where interrupts are detected by an \ninterrupt handler and passed to some other component fo r processing  \n. \u25cf Other event driven models include spreadsheets and production systems.  \n3 Discuss the process of translating the analysis model in to a software design, List the golden \nrules of user interface design NOV/DEC2015  \nThe process of implementation of a softwa re may be define as a process of translation old software \nto new software with a new developed software who have extra functions and making it \noperational without any interruption in an organization functioning system. The time period which \nstarts from the  acceptance of the tested design to its satisfactory operated it covers all the time \nperiod. The software implementation is a very big operation and for the implementation of a \nsoftware better planning is must require. The planning of implementation of sof tware should be \nimplemented from a short point and after the success it implemented on whole area. For the \nimplementation of a new software a good knowledge is must require and some requirement of a \nsystem are hardware, file conversion actions and some per sonal needs of software.  \nActivities involved in software implementation  \nWhen old software and new software is modified and implemented then it contains three basic \nactions.  \n1. Personal training  - For the implementation of new software, the training of users a nd \noperators is necessary part. The training activity plays a major part in operating and \nmaintaining the software by user. Thus we can say that operators and user both require \n96  \n training.", "mimetype": "text/plain", "start_char_idx": 153910, "end_char_idx": 158696, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b6750083-b00d-4023-aa7d-371978f91439": {"__data__": {"id_": "b6750083-b00d-4023-aa7d-371978f91439", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "834648ec46c47459407f994576c66219611465bccad7812a6253fc202258eb40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "abbb2bcb-0df0-4143-a14c-7895a15e889e", "node_type": "1", "metadata": {}, "hash": "73bd3e6a24d32a5067ec4b0639feb73a3c02c81258857361139fb5a5057890ea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The software implementation is a very big operation and for the implementation of a \nsoftware better planning is must require. The planning of implementation of sof tware should be \nimplemented from a short point and after the success it implemented on whole area. For the \nimplementation of a new software a good knowledge is must require and some requirement of a \nsystem are hardware, file conversion actions and some per sonal needs of software.  \nActivities involved in software implementation  \nWhen old software and new software is modified and implemented then it contains three basic \nactions.  \n1. Personal training  - For the implementation of new software, the training of users a nd \noperators is necessary part. The training activity plays a major part in operating and \nmaintaining the software by user. Thus we can say that operators and user both require \n96  \n training.  \no Software operator training  - Most software run smoothly depends on th e \ncomputer user. The training of computer operator gives the satisfaction that he can \ndo every action and data entry. In the process of training a list of problem can be \nfigured out and solution can be provided to then so that they can solve their \nproblems  on their base and build the knowledge about this. If they get unusual \nproblem they can contact the concerned person. With the help of training they \nbecome friendly with software and solve can their problem easily.  \no User training  - User training helps the u ser in operating the system in efficient \nway. During the training a manual is given to every user so that they can \nunderstand the problem and solved it. The content of training is about the use of \ndata that how they can edit, add, query and delete the reco rds. If a user have not \nsufficient capability of working on system then many kind of errors and problems \ncan occur.  \n2. Conversion  - With the help of conversion process a old software can be replaced with new \nsoftware. The process of conversion is useful in on ly that case where new software is fully \ntested and report is positive. It involves many kinds of actions which are:  \no From old to new software system all files and data base converted.  \no Providing the user training of the each staff of the organization which has the right \nof using new software.  \no Conversion of forms. This may involve discarding old data.  \no Converting administration. In the process of converting administration process the \nrole of each member is divided according the needs and the responsibility is also \ndivided according to their job regarding new software.  \n3. Post implementation Review  - After the process of implementation and conversion of \nsoftware some reviews are taken by the user and the experts. This is the normal process of \ngetting the following points:  \no What is the working of a software system?  \no How it has been accepted by the user?  \no Area of updating  \nPerformance of a software measured with the help of a post implementation review. It \nhelps in deciding that software gets the specification with how mu ch efficiency.  \nTypes of implementation  \nWe have three types of implementation method which are given below:  \n1. Fresh implementation  - Fresh implementation of software may be defined as a process \nwhere a manual record are replaced with new software. During the process of fresh \nimplementation some problems come in the form of conversion of files, user training, \naccurate system of files etc.  \n2. Replacement implementation  - When an old software is replaced with a new software \nimplementation that the name of this proce ss is Replacement implementation. This process \nis very difficult and a proper planning is needed for this, otherwise many problems can \narise.  \n97  \n 3. Modified implementation  - When an old software is replaced by new software with some \nalteration then this process is called modified implementation. We can easily handle this \ntype of implementation because area of modification is not so large in files.  \n \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, described by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent com mands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback.", "mimetype": "text/plain", "start_char_idx": 157808, "end_char_idx": 162603, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "abbb2bcb-0df0-4143-a14c-7895a15e889e": {"__data__": {"id_": "abbb2bcb-0df0-4143-a14c-7895a15e889e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b6750083-b00d-4023-aa7d-371978f91439", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ea2d6c1d79ce683617c29501ede00e1bf24a895b575bc21dc387872972b86082", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "908c1dc9-6dfa-4a90-aab0-5c3163538fe9", "node_type": "1", "metadata": {}, "hash": "c50412281b878e96e89888dad7064d8b4dc2e290cf08224aa7fe5e80ab147178", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We can easily handle this \ntype of implementation because area of modification is not so large in files.  \n \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, described by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent com mands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback. For frequent and minor actions, the response must be modest, while for \ninfrequent and major actions, the response must be more substantial.  \n\uf0b7 Design dialog to yield closure  - Sequences of actions should be organized into groups \nwith a beginning, middle, and end. The informative feedback at the completion of a group \nof actions gives the operators the satisfaction of accomplishment, a sense of relief , the \nsignal to drop contingency plans and options from their minds, and this indicates that the \nway ahead is clear to prepare for the next group of actions.  \n\uf0b7 Offer simple error handling  - As much as possible, design the system so the user will not \nmake a s erious error. If an error is made, the system should be able to detect it and offer \nsimple, comprehensible mechanisms for handling the error.  \n\uf0b7 Permit easy reversal of actions  - This feature relieves anxiety, since the user knows that \nerrors can be undone. E asy reversal of actions encourages exploration of unfamiliar \noptions. The units of reversibility may be a single action, a data entry, or a complete group \nof actions.  \n\uf0b7 Support internal locus of control  - Experienced operators strongly desire the sense that \nthey are in charge of the system and that the system responds to their actions. Design the \nsystem to make users the initiators of actions rather than the responders.  \n\uf0b7 Reduce short -term memory load  - The limitation of human information processing in \nshort -term memory requires the displays to be kept simple, multiple page displays be \nconsolidated, window -motion frequency be reduced, and sufficient training time be \nallotted for codes, mnemonics, and sequences of actions.  \n \n4 Explain the basic concepts of softwa re design APR/MAY -11 , NOV/DEC 2017  \nSoftware design is a process to transform user requirements into some suitable form, \nwhich helps the programmer in software coding and implementation.  \nFor assessing user requirements, an SRS (Software Requirement Specifi cation) document \nis created whereas for coding and implementation, there is a need of more specific and \ndetailed requirements in software terms. The output of this process can directly be used \n98  \n into implementation in programming languages.  \nSoftware design i s the first step in SDLC (Software Design Life Cycle), which moves the \nconcentration from problem domain to solution domain. It tries to specify how to fulfill \nthe requirements mentioned in SRS.  \nSoftware Design Levels  \nSoftware design yields three levels of  results:  \n\uf0b7 Architectural Design - The architectural design is the highest abstract version of the \nsystem. It identifies the software as a system with many components interacting with each \nother. At this level, the designers get the idea of proposed solution  domain.  \n\uf0b7 High -level Design - The high -level design breaks the \u2018single entity -multiple component\u2019 \nconcept of architectural design into less -abstracted view of sub -systems and modules and \ndepicts their interaction with each other. High -level design focuses on  how the system along \nwith all of its components can be implemented in forms of modules. It recognizes modular \nstructure of each sub -system and their relation and interaction among each other.  \n\uf0b7 Detailed Design - Detailed design deals with the implementation part of what is seen as a \nsystem and its sub -systems in the previous two designs. It is more detailed towards modules \nand their implementations. It defines logical structure of each module and their interfaces to \ncommunicate with other modules.  \nModularizat ion \nModularization is a technique to divide a software system into multiple discrete and independent \nmodules, which are expected to be capable of carrying out task(s) independently. These modules \nmay work as basic constructs for the entire software. Design ers tend to design modules such that \nthey can be executed and/or compiled separately and independently.", "mimetype": "text/plain", "start_char_idx": 161730, "end_char_idx": 166550, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "908c1dc9-6dfa-4a90-aab0-5c3163538fe9": {"__data__": {"id_": "908c1dc9-6dfa-4a90-aab0-5c3163538fe9", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "abbb2bcb-0df0-4143-a14c-7895a15e889e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "aa176b66552dd242d974c2210589f45afab9762d5b7f3ea1f37e91c700789665", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b13c1f4e-ef5e-4017-9132-7cf57795c300", "node_type": "1", "metadata": {}, "hash": "dc7c6eb49eeca7222d48a9af1d962535c6ff8f66367b76f969c00138477a7dcc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "High -level design focuses on  how the system along \nwith all of its components can be implemented in forms of modules. It recognizes modular \nstructure of each sub -system and their relation and interaction among each other.  \n\uf0b7 Detailed Design - Detailed design deals with the implementation part of what is seen as a \nsystem and its sub -systems in the previous two designs. It is more detailed towards modules \nand their implementations. It defines logical structure of each module and their interfaces to \ncommunicate with other modules.  \nModularizat ion \nModularization is a technique to divide a software system into multiple discrete and independent \nmodules, which are expected to be capable of carrying out task(s) independently. These modules \nmay work as basic constructs for the entire software. Design ers tend to design modules such that \nthey can be executed and/or compiled separately and independently.  \nModular design unintentionally follows the rules of \u2018divide and conquer\u2019 problem -solving strategy \nthis is because there are many other benefits attached  with the modular design of a software.  \nAdvantage of modularization:  \n\uf0b7 Smaller components are easier to maintain  \n\uf0b7 Program can be divided based on functional aspects  \n\uf0b7 Desired level of abstraction can be brought in the program  \n\uf0b7 Components with high cohesion can b e re-used again  \n\uf0b7 Concurrent execution can be made possible  \n\uf0b7 Desired from security aspect  \nConcurrency  \nBack in time, all software are meant to be executed sequentially. By sequential execution we mean \nthat the coded instruction will be executed one after anoth er implying only one portion of program \nbeing activated at any given time. Say, a software has multiple modules, then only one of all the \nmodules can be found active at any time of execution.  \nIn software design, concurrency is implemented by splitting the software into multiple independent \nunits of execution, like modules and executing them in parallel. In other words, concurrency \nprovides capability to the software to execute more than one part of code in parallel to each other.  \n99  \n It is necessary for the pro grammers and designers to recognize those modules, which can be made \nparallel execution.  \nExample  \nThe spell check feature in word processor is a module of software, which runs along side the word \nprocessor itself.  \nDesign Verification  \nThe output of software design process is design documentation, pseudo codes, detailed logic \ndiagrams, process diagrams, and detailed description of all functional or non -functional \nrequirements.  \nThe next phase, which is the implementation of software, depends on all outputs ment ioned above.  \nIt is then becomes necessary to verify the output before proceeding to the next phase. The early \nany mistake is detected, the better it is or it might not be detected until testing of the product. If the \noutputs of design phase are in formal n otation form, then their associated tools for verification \nshould be used otherwise a thorough design review can be used for verification and validation.  \nBy structured verification approach, reviewers can detect defects that might be caused by \noverlooking some conditions. A good design review is important for good software design, \naccuracy and quality.  \n \n5 Explain clearly the concept of coupling & cohesion? For each type of coupling give an \nexample of two components coupled  in that way?  \nAPRIL/MAY 2015, APR IL/MAY 2017,  APRIL/MAY  2018  \nDescribe the concept of cohesion and coupling. State the difference b/w cohesion and \ncoupling with a suitable example.  \n(April/May Apr/May 2008)  \nCoupling and Cohesion  \nWhen a software program is modularized, its tasks are divided into several modules based on some \ncharacteristics. As we know, modules are set of instructions put together in order to achieve some \ntasks. They are though, considered as single entity but may refer to each other to work together. \nThere are measures by wh ich the quality of a design of modules and their interaction among them \ncan be measured. These measures are called coupling and cohesion.  \nCohesion  \nCohesion is a measure that defines the degree of intra -dependability within elements of a module. \nThe greater  the cohesion, the better is the program design.  \nThere are seven types of cohesion, namely \u2013 \n\uf0b7 Co-incidental cohesion - It is unplanned and random cohesion, which might be the result \nof breaking the program into smaller modules for the sake of modularization . Because it is \nunplanned, it may serve confusion to the programmers and is generally not -accepted.  \n\uf0b7 Logical cohesion - When logically categorized elements are put together into a module, it \nis called logical cohesion.", "mimetype": "text/plain", "start_char_idx": 165629, "end_char_idx": 170370, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b13c1f4e-ef5e-4017-9132-7cf57795c300": {"__data__": {"id_": "b13c1f4e-ef5e-4017-9132-7cf57795c300", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "908c1dc9-6dfa-4a90-aab0-5c3163538fe9", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62355cebffd58476903a0a1bcc3db9d56c93e79808bf2ae5ab37aa65eb71736f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4878e34e-60dc-42fd-b295-149174ce612d", "node_type": "1", "metadata": {}, "hash": "f85d09e0235bf27b73617b00ed4abd394aed191b2aa1fc5ae4cbb633fa96e60b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "They are though, considered as single entity but may refer to each other to work together. \nThere are measures by wh ich the quality of a design of modules and their interaction among them \ncan be measured. These measures are called coupling and cohesion.  \nCohesion  \nCohesion is a measure that defines the degree of intra -dependability within elements of a module. \nThe greater  the cohesion, the better is the program design.  \nThere are seven types of cohesion, namely \u2013 \n\uf0b7 Co-incidental cohesion - It is unplanned and random cohesion, which might be the result \nof breaking the program into smaller modules for the sake of modularization . Because it is \nunplanned, it may serve confusion to the programmers and is generally not -accepted.  \n\uf0b7 Logical cohesion - When logically categorized elements are put together into a module, it \nis called logical cohesion.  \n10\n0  \n \uf0b7 Temporal Cohesion - When elements of m odule are organized such that they are processed \nat a similar point in time, it is called temporal cohesion.  \n\uf0b7 Procedural cohesion - When elements of module are grouped together, which are executed \nsequentially in order to perform a task, it is called proced ural cohesion.  \n\uf0b7 Communicational cohesion - When elements of module are grouped together, which are \nexecuted sequentially and work on same data (information), it is called communicational \ncohesion.  \n\uf0b7 Sequential cohesion - When elements of module are grouped be cause the output of one \nelement serves as input to another and so on, it is called sequential cohesion.  \n\uf0b7 Functional cohesion - It is considered to be the highest degree of cohesion, and it is highly \nexpected. Elements of module in functional cohesion are gr ouped because they all \ncontribute to a single well -defined function. It can also be reused.  \nCoupling  \nCoupling is a measure that defines the level of inter -dependability among modules of a program. It \ntells at what level the modules interfere and interact w ith each other. The lower the coupling, the \nbetter the program.  \nThere are five levels of coupling, namely - \n\uf0b7 Content coupling - When a module can directly access or modify or refer to the content of \nanother module, it is called content level coupling.  \n\uf0b7 Commo n coupling - When multiple modules have read and write access to some global \ndata, it is called common or global coupling.  \n\uf0b7 Control coupling - Two modules are called control -coupled if one of them decides the \nfunction of the other module or changes its flow o f execution.  \n\uf0b7 Stamp coupling - When multiple modules share common data structure and work on \ndifferent part of it, it is called stamp coupling.  \n\uf0b7 Data coupling - Data coupling is when two modules interact with each other by means of \npassing data (as parameter).  If a module passes data structure as parameter, then the \nreceiving module should use all its components.  \nIdeally, no coupling is considered to be the best.  \n \n6 Write short notes on Architectural & component design. MAY/JUN -15,NOV/DEC2015  \nThe architecture of a system describes its major components, their relationships (structures), and \nhow they interact with each other. Software architecture and design includes several contributory \nfactors such as Business strategy, quality attributes, human dynamics, desig n, and IT environment.  \n10\n1  \n \n \nWe can segregate Software Architecture and Design into two distinct phases: Software \nArchite cture and Software Design. In  Architecture , nonfunctional decisions are cast and separated \nby the functional requirements. In Design, functional requirements are accomplished.  \nSoftware Architecture  \nArchitecture serves as a  blueprint for a system . It provid es an abstraction to manage the system \ncomplexity and establish a communication and coordination mechanism among components.  \n\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attrib utes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions about the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the over all success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elements and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavio ral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork t ogether to fulfill the requirement of the system.", "mimetype": "text/plain", "start_char_idx": 169502, "end_char_idx": 174322, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4878e34e-60dc-42fd-b295-149174ce612d": {"__data__": {"id_": "4878e34e-60dc-42fd-b295-149174ce612d", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b13c1f4e-ef5e-4017-9132-7cf57795c300", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "39d30d6fd2270f8a081a8e5f80c6235af5ac43dc5ba7cc584f863d614aeac27f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90edd788-6a51-465d-ac7f-43cdb03858bd", "node_type": "1", "metadata": {}, "hash": "2934a4e45092d0e41bbaadb6c31899182e15697056a6d0092778136433d6e2f0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attrib utes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions about the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the over all success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elements and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavio ral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork t ogether to fulfill the requirement of the system. The obje ctives of having a design plan are as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n10\n2  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including deta iled design, coding, integration, and testing.  \nIt comes before the detailed design, coding, integration, and testing and after the domain analysis, \nrequirements analysis, and risk analysis.  \nGoals of Architecture  \nThe primary goal of the architecture is to i dentify requirements that affect the structure of the \napplication. A well -laid architecture reduces the business risks associated with building a technical \nsolution and builds a bridge between business and technical requirements.  \nSome of the other goals ar e as follows \u2212  \n\uf0b7 Expose the structure of the system, but hide its implementation details.  \n\uf0b7 Realize all the use -cases and scenarios.  \n\uf0b7 Try to address the requirements of various stakeholders.  \n\uf0b7 Handle both functional and quality requirements.  \n\uf0b7 Reduce the goal of ow nership and improve the organization\u2019s market position.  \n\uf0b7 Improve quality and functionality offered by the system.  \n\uf0b7 Improve external confidence in either the organization or system.  \nLimitations  \nSoftware architecture is still an emerging discipline within soft ware engineering. It has the \nfollowing limitations \u2212  \n\uf0b7 Lack of tools and standardized ways to represent architecture.  \n\uf0b7 Lack of analysis methods to predict whether architecture will result in an implementation \nthat meets the requirements.  \n\uf0b7 Lack of awareness of the importance of architectural design to software development.  \n\uf0b7 Lack of understanding of the role of software architect and poor communication among \nstakeholders.  \n\uf0b7 Lack of understanding of the design process, design experience and evaluation of design.  \nRole of Software Architect  \nA Software Architect provides a solution that the technical team can create and design for the \nentire application. A software architect should have expertise in the fol lowing areas \u2212  \nDesign Expertise  \n\uf0b7 Expert in software design, including diverse methods and approaches such as object -\noriented design, event -driven design, etc.  \n\uf0b7 Lead the development team and coordinate the development efforts for the integrity of the \ndesign.  \n10\n3  \n \uf0b7 Should be able to review design proposals and tradeoff among themselves . \nComponent -based architecture  \nComponent -based architecture focuses on the decomposition of the design into individual \nfunctional or logical components that represent well -defined commu nication interfaces containing \nmethods, events, and properties. It provides a higher level of abstraction and divides the problem \ninto sub -problems, each associated with component partitions.  \nThe primary objective of component -based architecture is to ensu re component reusability . A \ncomponent encapsulates functionality and behaviors of a software element into a reusable and self -\ndeployable binary unit. There are many standard component frameworks such as COM/DCOM, \nJavaBean, EJB, CORBA, .NET, web services, a nd grid services. These technologies are widely \nused in local desktop GUI application design such as graphic JavaBean components, MS ActiveX \ncomponents, and COM components which can be reused by simply drag and drop operation.  \nComponent -oriented software d esign has many advantages over the traditional object -oriented \napproaches such as \u2212  \n\uf0b7 Reduced time in market and the development cost by reusing existing components.  \n\uf0b7 Increased reliability with the reuse of the existing components.  \nWhat is a Component?  \nA comp onent is a modular, portable, replaceable, and reusable set of well -defined functionality \nthat encapsulates its implementation and exporting it as a higher -level interface.  \nA component is a software object, intended to interact with other components, encap sulating \ncertain functionality or a set of functionalities. It has an obviously defined interface and conforms \nto a recommended behavior common to all components within an architecture.", "mimetype": "text/plain", "start_char_idx": 173330, "end_char_idx": 178470, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "90edd788-6a51-465d-ac7f-43cdb03858bd": {"__data__": {"id_": "90edd788-6a51-465d-ac7f-43cdb03858bd", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4878e34e-60dc-42fd-b295-149174ce612d", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "6cd7323574544b7ce12abec9e6eb961a1ba73855cdf0054ed5658ee8e43f3f15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "63e5606f-f066-432c-8d9e-545a8360819e", "node_type": "1", "metadata": {}, "hash": "731e9fd4e8083b261f15b085e90849ad50b86261ccd7dfb214f75f7f4c87c033", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These technologies are widely \nused in local desktop GUI application design such as graphic JavaBean components, MS ActiveX \ncomponents, and COM components which can be reused by simply drag and drop operation.  \nComponent -oriented software d esign has many advantages over the traditional object -oriented \napproaches such as \u2212  \n\uf0b7 Reduced time in market and the development cost by reusing existing components.  \n\uf0b7 Increased reliability with the reuse of the existing components.  \nWhat is a Component?  \nA comp onent is a modular, portable, replaceable, and reusable set of well -defined functionality \nthat encapsulates its implementation and exporting it as a higher -level interface.  \nA component is a software object, intended to interact with other components, encap sulating \ncertain functionality or a set of functionalities. It has an obviously defined interface and conforms \nto a recommended behavior common to all components within an architecture.  \nA software component can be defined as a unit of composition with a co ntractually specified \ninterface and explicit context dependencies only. That is, a software component can be deployed \nindependently and is subject to composition by third parties.  \nViews of a Component  \nA component can have three different views \u2212 object -oriented view, conventional view, and \nprocess -related view.  \nObject -oriented view  \nA component is viewed as a set of one or more cooperating classes. Each problem domain class \n(analysis) and infrastructure class (design) are explained to identify all attributes  and operations \nthat apply to its implementation. It also involves defining the interfaces that enable classes to \ncommunicate and cooperate.  \nConventional view  \nIt is viewed as a functional element or a module of a program that integrates the processing logi c, \nthe internal data structures that are required to implement the processing logic and an interface that \nenables the component to be invoked and data to be passed to it.  \nProcess -related view  \nIn this view, instead of creating each component from scratch, t he system is building from existing \ncomponents maintained in a library. As the software architecture is formulated, components are \n10\n4  \n selected from the library and used to populate the architecture.  \n\uf0b7 A user interface (UI) component includes grids, buttons refe rred as controls, and utility \ncomponents expose a specific subset of functions used in other components.  \n\uf0b7 Other common types of components are those that are resource intensive, not frequently \naccessed, and must be activated using the just -in-time (JIT) app roach.  \n\uf0b7 Many components are invisible which are distributed in enterprise business applications \nand internet web applications such as Enterprise JavaBean (EJB), .NET components, and \nCORBA components.  \nCharacteristics of Components  \n\uf0b7 Reusability  \u2212 Components are usually designed to be reused in different situations in \ndifferent applications. However, some components may be designed for a specific task.  \n\uf0b7 Replaceable  \u2212 Components may be freely substituted with other similar components.  \n\uf0b7 Not context s pecific  \u2212 Components are designed to operate in different environments and \ncontexts.  \n\uf0b7 Extensible  \u2212 A component can be extended from existing components to provide new \nbehavior.  \n\uf0b7 Encapsulated  \u2212 A A component depicts the interfaces, which allow the caller to u se its \nfunctionality, and do not expose details of the internal processes or any internal variables \nor state.  \n\uf0b7 Independent  \u2212 Components are designed to have minimal dependencies on other \ncomponents.  \nPrinciples of Component\u2212Based Design  \nA component -level des ign can be represented by using some intermediary representation (e.g. \ngraphical, tabular, or text -based) that can be translated into source code. The design of data \nstructures, interfaces, and algorithms should conform to well -established guidelines to he lp us \navoid the introduction of errors.  \n\uf0b7 The software system is decomposed into reusable, cohesive, and encapsulated component \nunits.  \n\uf0b7 Each component has its own interface that specifies required ports and provided ports; each \ncomponent hides its detailed im plementation.  \n\uf0b7 A component should be extended without the need to make internal code or design \nmodifications to the existing parts of the component.  \n\uf0b7 Depend on abstractions component do not depend on other concrete components, which \nincrease difficulty in ex pendability.  \n\uf0b7 Connectors connected components, specifying and ruling the interaction among \ncomponents. The interaction type is specified by the interfaces of the components.  \n\uf0b7 Components interaction can take the form of method invocations, asynchronous \ninvoca tions, broadcasting, message driven interactions, data stream communications, and \nother protocol specific interactions.  \n\uf0b7 For a server class, specialized interfaces should be created to serve major categories of \n10\n5  \n clients.", "mimetype": "text/plain", "start_char_idx": 177506, "end_char_idx": 182489, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "63e5606f-f066-432c-8d9e-545a8360819e": {"__data__": {"id_": "63e5606f-f066-432c-8d9e-545a8360819e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90edd788-6a51-465d-ac7f-43cdb03858bd", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1bca58a9c685b44a834715982b1b2db307be52bb06590fa1559fb9c733f4cb96", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d70c5e94-a178-4781-9306-72327ddac925", "node_type": "1", "metadata": {}, "hash": "a356e394c2fa007baec66b413f7897ade720af18300a17c0a6f399764717181d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 The software system is decomposed into reusable, cohesive, and encapsulated component \nunits.  \n\uf0b7 Each component has its own interface that specifies required ports and provided ports; each \ncomponent hides its detailed im plementation.  \n\uf0b7 A component should be extended without the need to make internal code or design \nmodifications to the existing parts of the component.  \n\uf0b7 Depend on abstractions component do not depend on other concrete components, which \nincrease difficulty in ex pendability.  \n\uf0b7 Connectors connected components, specifying and ruling the interaction among \ncomponents. The interaction type is specified by the interfaces of the components.  \n\uf0b7 Components interaction can take the form of method invocations, asynchronous \ninvoca tions, broadcasting, message driven interactions, data stream communications, and \nother protocol specific interactions.  \n\uf0b7 For a server class, specialized interfaces should be created to serve major categories of \n10\n5  \n clients. Only those operations that are releva nt to a particular category of clients should be \nspecified in the interface.  \n\uf0b7 A component can extend to other components and still offer its own extension points. It is \nthe concept of plug -in based architecture. This allows a plugin to offer another plugin API. \n \n7 Bring out the necessity of Real -time system design process with appropriate \nexample? APR/MAY -12, MAY/JUNE -13, APRIL/MAY -15 \nSystems Design  \nIt is a process of planning a new business system or replacing an existing system by \ndefining its components o r modules to satisfy the specific requirements. Before planning, \nyou need to understand the old system thoroughly and determine how computers can best \nbe used in order to operate efficiently.  \nSystem Design focuses on  how to accomplish the objective of the system . \nSystem Analysis and Design (SAD) mainly focuses on \u2212  \n\uf0b7 Systems  \n\uf0b7 Processes  \n\uf0b7 Technology  \nWhat is a System?  \nThe word System is derived from Greek word Systema, which means an organized \nrelationship between any set of components to achieve some common cause  or objective.  \nA system is \u201can orderly grouping of interdependent components linked together according \nto a plan to achieve a specific goal.\u201d  \nConstraints of a System  \nA system must have three basic constraints \u2212  \n\uf0b7 A system must have some  structure and behavio r which is designed to achieve a \npredefined objective.  \n\uf0b7 Interconnectivity  and interdependence  must exist among the system components.  \n\uf0b7 The objectives of the organization  have a  higher priority  than the objectives of \nits subsystems.  \nFor example, traffic manag ement system, payroll system, automatic library system, human \nresources information system.  \nProperties of a System  \nA system has the following properties \u2212  \nOrganization  \n10\n6  \n Organization implies structure and order. It is the arrangement of components that helps to \nachieve predetermined objectives.  \nInteraction  \nIt is defined by the manner in which the components operate with each other.  \nFor example, in an organization, purchasing department must interact with production \ndepartment and payroll with personnel department.  \nInterdependence  \nInterdependence means how the components of a system depend on one another. For \nproper functi oning, the components are coordinated and linked together according to a \nspecified plan. The output of one subsystem is the required by other subsystem as input.  \nIntegration  \nIntegration is concerned with how a system components are connected together. It m eans \nthat the parts of the system work together within the system even if each part performs a \nunique function.  \nCentral Objective  \nThe objective of system must be central. It may be real or stated. It is not uncommon for \nan organization to state an objectiv e and operate to achieve another.  \nThe users must know the main objective of a computer application early in the analysis for \na successful design and conversion.  \nElements of a System  \nThe following diagram shows the elements of a system \u2212  \n \n10\n7  \n Outputs and Inputs  \n\uf0b7 The main aim of a system is to produce an output which is useful for its user.  \n\uf0b7 Inputs are the information that enters into the system for processing.  \n\uf0b7 Output is the outcome of processing.  \nProcessor(s)  \n\uf0b7 The processor is the element of a system that involves the actual transformation of \ninput into output.  \n\uf0b7 It is th e operational component of a system. Processors may modify the input either \ntotally or partially, depending on the output specification.  \n\uf0b7 As the output specifications change, so does the processing. In some cases, input is \nalso modified to enable the proces sor for handling the transformation.  \nControl  \n\uf0b7 The control element guides the system.  \n\uf0b7 It is the decision \u2013making subsystem that controls the pattern of activities governing \ninput, processing, and output.", "mimetype": "text/plain", "start_char_idx": 181498, "end_char_idx": 186408, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d70c5e94-a178-4781-9306-72327ddac925": {"__data__": {"id_": "d70c5e94-a178-4781-9306-72327ddac925", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "63e5606f-f066-432c-8d9e-545a8360819e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "9a6c603604feeb5574268409feb105a7e3b6bf73cf83a492060aa0d1aff2789b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eb04d43a-74bd-444d-a83e-40b0b31571ab", "node_type": "1", "metadata": {}, "hash": "0a26b7751d05cdf2aff9a9d51527098f3cf0104ccff9af6b3aee7765f7e0d7f3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Inputs are the information that enters into the system for processing.  \n\uf0b7 Output is the outcome of processing.  \nProcessor(s)  \n\uf0b7 The processor is the element of a system that involves the actual transformation of \ninput into output.  \n\uf0b7 It is th e operational component of a system. Processors may modify the input either \ntotally or partially, depending on the output specification.  \n\uf0b7 As the output specifications change, so does the processing. In some cases, input is \nalso modified to enable the proces sor for handling the transformation.  \nControl  \n\uf0b7 The control element guides the system.  \n\uf0b7 It is the decision \u2013making subsystem that controls the pattern of activities governing \ninput, processing, and output.  \n\uf0b7 The behavior of a computer System is controlled by the Operating System and \nsoftware. In order to keep system in balance, what and how much input is needed \nis determined by Output Specifications.  \nFeedback  \n\uf0b7 Feedback provides the control in a dynamic system.  \n\uf0b7 Positive feedback is routine in nature that encourages the performance of the \nsystem.  \n\uf0b7 Negative feedback is informational in nature that provides the controller with \ninformation for action.  \nEnvironment  \n\uf0b7 The environment is the \u201csupersystem\u201d within which an organization operates.  \n\uf0b7 It is the source of external eleme nts that strike on the system.  \n\uf0b7 It determines how a system must function. For example, vendors and competitors \nof organization\u2019s environment, may provide constraints that affect the actual \nperformance of the business.  \nBoundaries and Interface  \n\uf0b7 A system shoul d be defined by its boundaries. Boundaries are the limits that \nidentify its components, processes, and interrelationship when it interfaces with \nanother system.  \n10\n8  \n \uf0b7 Each system has boundaries that determine its sphere of influence and control.  \n\uf0b7 The knowledge of  the boundaries of a given system is crucial in determining the \nnature of its interface with other systems for successful design.  \nTypes of Systems  \nThe systems can be divided into the following types \u2212  \nPhysical or Abstract Systems  \n\uf0b7 Physical systems are tangible entities. We can touch and feel them.  \n\uf0b7 Physical System may be static or dynamic in nature. For example, desks and chairs \nare the physical parts of computer center which are static. A programmed computer \nis a dynamic system in which programs, data, and applications can change \naccording to the user's needs.  \n\uf0b7 Abstract systems are non -physical entities or conceptual that may be formulas, \nrepresentation  or model of a real system.  \nOpen or Closed Systems  \n\uf0b7 An open system must interact with its environment. It receives inputs from and \ndelivers outputs to the outside of the system. For example, an information system \nwhich must adapt to the changing environment al conditions.  \n\uf0b7 A closed system does not interact with its environment. It is isolated from \nenvironmental influences. A completely closed system is rare in reality.  \nAdaptive and Non Adaptive System  \n\uf0b7 Adaptive System responds to the change in the environment i n a way to improve \ntheir performance and to survive. For example, human beings, animals.  \n\uf0b7 Non Adaptive System is the system which does not respond to the environment. \nFor example, machines.  \nPermanent or Temporary System  \n\uf0b7 Permanent System persists for long ti me. For example, business policies.  \n\uf0b7 Temporary System is made for specified time and after that they are demolished. \nFor example, A DJ system is set up for a program and it is dissembled after the \nprogram.  \nNatural and Manufactured System  \n\uf0b7 Natural systems are  created by the nature. For example, Solar system, seasonal \nsystem.  \n\uf0b7 Manufactured System is the man -made system. For example, Rockets, dams, trains.  \nDeterministic or Probabilistic System  \n\uf0b7 Deterministic system operates in a predictable manner and the interact ion between \n10\n9  \n system components is known with certainty. For example, two molecules of \nhydrogen and one molecule of oxygen makes water.  \n\uf0b7 Probabilistic System shows uncertain behavior. The exact output is not known. For \nexample, Weather forecasting, mail deliv ery. \nSocial, Human -Machine, Machine System  \n\uf0b7 Social System is made up of people. For example, social clubs, societies.  \n\uf0b7 In Human -Machine System, both human and machines are involved to perform a \nparticular task. For example, Computer programming.  \n\uf0b7 Machine Syst em is where human interference is neglected. All the tasks are \nperformed by the machine. For example, an autonomous robot.  \nMan\u2013Made Information Systems  \n\uf0b7 It is an interconnected set of information resources to manage data for particular \norganization, under D irect Management Control (DMC).", "mimetype": "text/plain", "start_char_idx": 185683, "end_char_idx": 190418, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "eb04d43a-74bd-444d-a83e-40b0b31571ab": {"__data__": {"id_": "eb04d43a-74bd-444d-a83e-40b0b31571ab", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d70c5e94-a178-4781-9306-72327ddac925", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "af1713175d7bcf335daed6c26006f2eee7eddc32ea79f576da13e4fa8e3a641c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62fdce68-032b-4fb6-8416-eb8e80f6355c", "node_type": "1", "metadata": {}, "hash": "3719e432b59877befc059aff52e9e49c4241793aea578a61652a765e0ac79e04", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For example, two molecules of \nhydrogen and one molecule of oxygen makes water.  \n\uf0b7 Probabilistic System shows uncertain behavior. The exact output is not known. For \nexample, Weather forecasting, mail deliv ery. \nSocial, Human -Machine, Machine System  \n\uf0b7 Social System is made up of people. For example, social clubs, societies.  \n\uf0b7 In Human -Machine System, both human and machines are involved to perform a \nparticular task. For example, Computer programming.  \n\uf0b7 Machine Syst em is where human interference is neglected. All the tasks are \nperformed by the machine. For example, an autonomous robot.  \nMan\u2013Made Information Systems  \n\uf0b7 It is an interconnected set of information resources to manage data for particular \norganization, under D irect Management Control (DMC).  \n\uf0b7 This system includes hardware, software, communication, data, and application for \nproducing information according to the need of an organization.  \nMan-made  information systems are divided into three types \u2212  \n\uf0b7 Formal Information System  \u2212 It is based on the flow of information in the form \nof memos, instructions, etc., from top level to lower levels of management.  \n\uf0b7 Informal Information System  \u2212 This is employee ba sed system which solves the \nday to day work related problems.  \n\uf0b7 Computer Based System  \u2212 This system is directly dependent on the computer for \nmanaging business applications. For example, automatic library system, railway \nreservation system, banking system, e tc. \n \n8 What is structured design? Illustrate the structured design process from DFD to structured \nchart with a case study. NOV/DEC 2016,  \nStructured Analysis is a development method that allows the analyst to understand the system and \nits activities in a lo gical way.  \nIt is a systematic approach, which uses graphical tools that analyze and refine the objectives of an \nexisting system and develop a new system specification which can be easily understandable by \nuser.  \nIt has following attributes \u2212  \n\uf0b7 It is graphic which specifies the presentation of application.  \n\uf0b7 It divides the processes so that it gives a clear picture of system flow.  \n\uf0b7 It is logical rather than physical i.e., the elements of system do not depend on vendor o r \nhardware.  \n11\n0  \n \uf0b7 It is an approach that works from high -level overviews to lower -level details.  \nStructured Analysis Tools  \nDuring Structured Analysis, various tools and techniques are used for system development. They \nare \u2212  \n\uf0b7 Data Flow Diagrams  \n\uf0b7 Data Dictionary  \n\uf0b7 Decision Trees  \n\uf0b7 Decision Tables  \n\uf0b7 Structured English  \n\uf0b7 Pseudocode  \n \nData Flow Diagrams (DFD) or Bubble Chart  \nIt is a technique developed b y Larry Constantine to express the requirements of system in a \ngraphical form.  \n\uf0b7 It shows the flow of data between various functions of system and specifies how the \ncurrent system is implemented.  \n\uf0b7 It is an initial stage of design phase that functionally divid es the requirement specifications \ndown to the lowest level of detail.  \n\uf0b7 Its graphical nature makes it a good communication tool between user and analyst or \nanalyst and system designer.  \n\uf0b7 It gives an overview of what data a system processes, what transformation s are performed, \nwhat data are stored, what results are produced and where they flow.  \n11\n1  \n Basic Elements of DFD  \nDFD is easy to understand and quite effective when the required design is not clear and the user \nwants a notational language for communication. Howe ver, it requires a large number of iterations \nfor obtaining the most accurate and complete solution.  \nThe following table shows the symbols used in designing a DFD and their significance \u2212  \nSymbol Name  Symbol  Meaning  \nSquare  \n Source or Destination of Data  \nArrow  \n Data flow  \nCircle  \n Process transforming data flow  \nOpen Rectangle  \n Data Store  \nTypes of DFD  \nDFDs are of two types: Physical DFD and Logical DFD. The following table lists the points that \ndifferentiate a physical DFD from a logical DFD.  \nPhysical DFD  Logical DFD  \nIt is implementation dependent . It shows which functions are performed.  It is implementation independent. It focuses only on the flow of data between \nprocesses.  \nIt provides low level details of hardware, software, files, and people.  It explains events of systems and data required by e ach event.  \nIt depicts how the current system operates and how a system will be implemented.  It shows how business operates; not how the system can be implemented.  \n11\n2  \n Context Diagram  \nA context diagram helps in understanding the entire system by one DFD which  gives the overview \nof a system.", "mimetype": "text/plain", "start_char_idx": 189641, "end_char_idx": 194249, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "62fdce68-032b-4fb6-8416-eb8e80f6355c": {"__data__": {"id_": "62fdce68-032b-4fb6-8416-eb8e80f6355c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "eb04d43a-74bd-444d-a83e-40b0b31571ab", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "325c34d816948c15b0bb11df7f1500f22ce97b10e6f866dd4c16fbd9c321971b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "78358f6b-7a4e-4985-b1c2-e1a0faa4c691", "node_type": "1", "metadata": {}, "hash": "3155e992a3f8a7a16e37681e36e7a30dc9ff052f63feaabdd4b4aaefa514ede8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The following table lists the points that \ndifferentiate a physical DFD from a logical DFD.  \nPhysical DFD  Logical DFD  \nIt is implementation dependent . It shows which functions are performed.  It is implementation independent. It focuses only on the flow of data between \nprocesses.  \nIt provides low level details of hardware, software, files, and people.  It explains events of systems and data required by e ach event.  \nIt depicts how the current system operates and how a system will be implemented.  It shows how business operates; not how the system can be implemented.  \n11\n2  \n Context Diagram  \nA context diagram helps in understanding the entire system by one DFD which  gives the overview \nof a system. It starts with mentioning major processes with little details and then goes onto giving \nmore details of the processes with the top -down approach.  \nThe context diagram of mess management is shown below.  \n \nData Dictionary  \nA data dictionary is a structured repository of data elements in the system. It stores the descriptions \nof all DFD data elements that i s, details and definitions of data flows, data stores, data stored in \ndata stores, and the processes.  \nA data dictionary improves the communication between the analyst and the user. It plays an \nimportant role in building a database. Most DBMSs have a data d ictionary as a standard feature. \nFor example, refer the following table \u2212  \nSr.No.  Data Name  Description  \n1 ISBN  ISBN Number  \n2 TITLE  title \n3 SUB  Book Subjects  \n11\n3  \n 4 ANAME  Author Name  15 \nDecision Trees  \nDecision trees are a method fo r defining complex relationships by describing decisions and \navoiding the problems in communication. A decision tree is a diagram that shows alternative \nactions and conditions within horizontal tree framework. Thus, it depicts which conditions to \nconsider first, second, and so on.  \nDecision trees depict the relationship of each condition and their permissible actions. A square \nnode indicates an action and a circle indicates a condition. It forces analysts to consider the \nsequence of decisions and identifies the actual decision that must be made.  \n \nThe major limitation of a decision tree is that it lacks information in its format to descri be what \nother combinations of conditions you can take for testing. It is a single representation of the \nrelationships between conditions and actions.  \nFor example, refer the following decision tree \u2212  \n \n11\n4  \n Decision Tables  \nDecision tables are a method of describing the complex logical relationship in a precise manner \nwhich is easily understandable.  \n\uf0b7 It is useful in situations where the resulting actions depend on the occurrence of one or \nseveral combinations of independent conditions.  \n\uf0b7 It is a matrix containing row or columns for defining  a problem and the actions.  \nComponents of a Decision Table  \n\uf0b7 Condition Stub  \u2212 It is in the upper left quadrant which lists all the condition to be \nchecked.  \n\uf0b7 Action Stub  \u2212 It is in the lower left quadrant which outlines all the action to be carried out \nto meet such condition.  \n\uf0b7 Condition Entry  \u2212 It is in upper right quadrant which pro vides answers to questions asked \nin condition stub quadrant.  \n\uf0b7 Action Entry  \u2212 It is in lower right quadrant which indicates the appropriate action \nresulting from the answers to the conditions in the condition entry quadrant.  \nThe entries in decision table are  given by Decision Rules which define the relationships between \ncombinations of conditions and courses of action. In rules section,  \n\uf0b7 Y shows the existence of a condition.  \n\uf0b7 N represents the condition, which is not satisfied.  \n\uf0b7 A blank - against action states it  is to be ignored.  \n\uf0b7 X (or a check mark will do) against action states it is to be carried out.  \n \n11\n5  \n 9 (a) Describe golden rules for interface design  NOV/DEC  2016  \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, d escribed by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent commands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are  very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback.", "mimetype": "text/plain", "start_char_idx": 193532, "end_char_idx": 198173, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "78358f6b-7a4e-4985-b1c2-e1a0faa4c691": {"__data__": {"id_": "78358f6b-7a4e-4985-b1c2-e1a0faa4c691", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62fdce68-032b-4fb6-8416-eb8e80f6355c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "2956aefbf950b9a1a8258d096691dcb1830eb646ab6c5ae6fe7b29a3b7b005c7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "647fb88d-c014-48c8-876e-b1463adba515", "node_type": "1", "metadata": {}, "hash": "08624dcaabd6471105485cc7662bd782d218dacd08004dbf9257adc00650de75", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "11\n5  \n 9 (a) Describe golden rules for interface design  NOV/DEC  2016  \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, d escribed by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent commands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are  very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback. For frequent and minor actions, the response must be modest, while for \ninfrequent and major actions, the response must be more su bstantial.  \n\uf0b7 Design dialog to yield closure  - Sequences of actions should be organized into groups \nwith a beginning, middle, and end. The informative feedback at the completion of a group \nof actions gives the operators the satisfaction of accomplishment, a s ense of relief, the \nsignal to drop contingency plans and options from their minds, and this indicates that the \nway ahead is clear to prepare for the next group of actions.  \n\uf0b7 Offer simple error handling  - As much as possible, design the system so the user wil l not \nmake a serious error. If an error is made, the system should be able to detect it and offer \nsimple, comprehensible mechanisms for handling the error.  \n\uf0b7 Permit easy reversal of actions  - This feature relieves anxiety, since the user knows that \nerrors ca n be undone. Easy reversal of actions encourages exploration of unfamiliar \noptions. The units of reversibility may be a single action, a data entry, or a complete group \nof actions.  \n\uf0b7 Support internal locus of control  - Experienced operators strongly desire t he sense that \nthey are in charge of the system and that the system responds to their actions. Design the \nsystem to make users the initiators of actions rather than the responders.  \n(b) Reduce short -term memory load  - The limitation of human information processi ng in short -\nterm memory requires the displays to be kept simple, multiple page displays be consolidated, \nwindow -motion frequency be reduced, and sufficient training time be allotted for codes, \nmnemonics, and sequences of actions   \nRefer class notes  \n10 What  is software architecture ? Describe in detail different types of software architectural \nstyles with illustrations. APRIL/MAY 2017, APRIL/MAY 2018  \nThe architecture of a system describes its major components, their relationships (structures), and \nhow they i nteract with each other. Software architecture and design includes several contributory \nfactors such as Business strategy, quality attributes, human dynamics, design, and IT environment.  \n11\n6  \n \n \nWe can segregate Software Architecture and Design into two distinct phases: Software \nArchitecture and Software Design. In  Architecture , nonfunctional decisions are cast and separated \nby the functional requirements. In Design, functional requirements are accomplished.  \nSoftware Architecture  \nArchitecture serves as a  blueprint for a system . It provides an abstraction to manage the system \ncomplexity and establish a communication and coordina tion mechanism among components.  \n\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attributes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions abou t the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the overall success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elem ents and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavioral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork together to fulfill the requirement of the system. The objectives of having a design plan are  as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n11\n7  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including detailed design, coding, integration, and testing.", "mimetype": "text/plain", "start_char_idx": 197334, "end_char_idx": 202167, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "647fb88d-c014-48c8-876e-b1463adba515": {"__data__": {"id_": "647fb88d-c014-48c8-876e-b1463adba515", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "78358f6b-7a4e-4985-b1c2-e1a0faa4c691", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5d8a3f909251ca6f911f7aaa9bb5b6ef51e84b1d663971a6430d2c85b053fec1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3531adac-7db6-4632-8bbb-6279d07252eb", "node_type": "1", "metadata": {}, "hash": "e46ec613ef05d7fe329d9575767432841015f2c54983a14f9daebe216ed45b99", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These decisions \ncomprise of \u2212  \no Selection of structural elem ents and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavioral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork together to fulfill the requirement of the system. The objectives of having a design plan are  as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n11\n7  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including detailed design, coding, integration, and testing.  \nIt comes before the detailed design, coding, integration, and testing and after the domain analysis, \nrequirements analysis, and risk analysis.  \n \nGoals of Architecture  \nThe primary goal of the architecture is to identify requirements that affect the structure of the \napplication. A well -laid architecture reduces the business risks associated with building a technical \nsolut ion and builds a bridge between business and technical requirements.  \nSome of the other goals are as follows \u2212  \n\uf0b7 Expose the structure of the system, but hide its implementation details.  \n\uf0b7 Realize all the use -cases and scenarios.  \n\uf0b7 Try to address the requirements of various stakeholders.  \n\uf0b7 Handle both functional and quality requirements.  \n\uf0b7 Reduce the goal of ownership and improve the organization\u2019s market position.  \n\uf0b7 Improve quality and functionality offered by the system.  \n\uf0b7 Improve external confidence in either the organi zation or system.  \nLimitations  \nSoftware architecture  is still an emerging discipline within software engineering. It has the \nfollowing limitations \u2212  \n\uf0b7 Lack of tools and standardized ways to represent architecture.  \n\uf0b7 Lack of analysis methods to predict whether architecture will result in an implementation \nthat m eets the requirements.  \n\uf0b7 Lack of awareness of the importance of architectural design to software development.  \n\uf0b7 Lack of understanding of the role of software architect and poor communication among \n11\n8  \n stakeholders.  \n\uf0b7 Lack of understanding of the design process, desi gn experience and evaluation of design.  \n \n11 What is the purpose of DFD ?What are the compoenets of DFD? Construct DFD for the \nfollowing system..  \nAn online shopping system for xyz provides many services and  \nbenefits to its members and staffs. APRIL/MAY 201 8 \nstructure chart is a chart derived from Data Flow Diagram. It represents the system in more detail \nthan DFD. It breaks down the entire system into lowest functional modules, describes functions \nand sub -functions of each module of the system to a greater detail than DFD.  \nStructure chart represents hierarchical structure of modules. At each layer a specific task is \nperformed.  \nHere are the symbols used in construction of structure charts - \n\uf0b7 Module  - It represents process or subroutine or task. A control modul e branches to more \nthan one sub -module. Library Modules are re -usable and invokable from any \nmodule.\n  \n\uf0b7 Condition  - It is represented by small d iamond at the base of module. It depicts that control \nmodule can select any of sub -routine based on some \ncondition.\n  \n\uf0b7 Jump  - An arrow is show n pointing inside the module to depict that the control will jump \n11\n9  \n in the middle of the sub -module.\n  \n\uf0b7 Loop  - A curved arrow represents loop in the module. All sub -modules covered by loop \nrepeat execution of \nmodule.\n  \n\uf0b7 Data flow  - A directed arrow with empty circle at the end represents data \nflow.\n  \n\uf0b7 Control flow  - A directed arrow with filled circle at the end represents control \nflow.\n  \n12\n0  \n HIPO Diagram  \nHIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to \nanalyze the system and provide the means of documentation. HIPO model was  developed by IBM \nin year 1970.  \nHIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO \ndiagram in order to obtain high -level view of system functions. It decomposes functions into sub -\nfunctions in a hierarchical manner. It depicts the functions performed by system.  \nHIPO diagrams are good for documentation purpose. Their graphical representation makes it easier \nfor designers and managers to get the pictorial idea of the system structure.  \n \nIn contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a \nmodule, HIPO does not provide any information about data flow or control f low.", "mimetype": "text/plain", "start_char_idx": 201276, "end_char_idx": 206063, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3531adac-7db6-4632-8bbb-6279d07252eb": {"__data__": {"id_": "3531adac-7db6-4632-8bbb-6279d07252eb", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "647fb88d-c014-48c8-876e-b1463adba515", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "86627f033a93e2951cd70ff76dd9c37751bef3d22d99c4974a99570126fa5c6d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8671b2f3-590c-460c-accd-6961142fcb40", "node_type": "1", "metadata": {}, "hash": "88855692eb0141555181f71fb564cd3768b334faf60afe473a2cb461f59b36da", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "12\n0  \n HIPO Diagram  \nHIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to \nanalyze the system and provide the means of documentation. HIPO model was  developed by IBM \nin year 1970.  \nHIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO \ndiagram in order to obtain high -level view of system functions. It decomposes functions into sub -\nfunctions in a hierarchical manner. It depicts the functions performed by system.  \nHIPO diagrams are good for documentation purpose. Their graphical representation makes it easier \nfor designers and managers to get the pictorial idea of the system structure.  \n \nIn contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a \nmodule, HIPO does not provide any information about data flow or control f low. \n \n \n \n12\n1  \n \n \n \n  \n12 Describe in detail about architectural styles?  \nArchitectural styles define the components and connectors ( \u2018what?\u2019)  \n \u2022 Less domain specific  \n \u2022 Good architecture makes use of design patterns (on a more finegranular level)  \n \u2022  Usually domain independent  \nAn architectural style is a named collection of architectural design decisions that  \n\u2212 are applicable in a give n development context  \n \u2212 constrain architectural design decisions that are specific to a particular system within that \ncontext  \n \u2212 elicit beneficial qualities in each resulting system  \n\u2022 Reflect less domain specificity than architectural patterns  \n \u2022 Useful in determining everything from subroutine structure to top -level application structure  \n\u2022 Many styles exist and we will discuss them in detail in the next lecture  \nBenefits of Using Styles  \nReuse  \n\u2022 Design: Well -understood solutions applied to new problems  \n\u2022 Code: Shared implementations of invariant aspects of a style  \n  Understandability of system organization  \n \u2022 A phrase such as \u201cclient -server\u201d conveys a lot of information  \n  Interoperability  \n12\n2  \n  \u2022 Supported by style standardization  \n \u2022 Style -specificity  \n \u2022 Anal yses: enabled by the constrained design space  \n \u2022 Visualizations: depictions matching engineers\u2019 mental models  \nBasic Properties of Style s \nA vocabulary of design elements  \n\u2022 Component and connector types; data elements  \n \u2212 e.g., pipes, filters, objects, serve rs \n\u201cArchitectural styles define the components and connectors\u201d  \n \u2022 A software connector is an architectural building block tasked with effecting and regulating \ninteractions among components (Taylor, Medvidovic, Dashofy)  \n \u2022 Procedure call connectors  \n \u2022 Share d memory connectors  \n \u2022 Message passing connectors  \n\u2022 Streaming connectors  \n\u2022 Distribution connectors  \n\u2022 Wrapper/adaptor connectors  \n A set of configuration rules  \n \u2022 Topological constraints that determine allowed compositions of elements  \n \u2212 e.g., a component may be connected to at most two other components  \n A semantic interpretation  \n \u2022 Compositions of design elements have well -defined meanings  \n \u2022 Possible analyses of systems built in a style  \n \n \n \n \n13 Explain transform mapping with suitable example and design steps involved in \nit.(Nov/Dec 2012)  \n \n \nTransform mapping is a set of design steps that allows a DFD with transform flow characteristics to \nbe mapped into a specific architectural style. In this section transform mapping is described by \napplying design steps to an example system \u2014a portion of the SafeHome security software.  \n \nAn Example  \n \nThe SafeHome security system is representative of many computer -based products and systems in \n12\n3  \n use today. The product monitors the real world and reacts to ch anges that it encounters. It also \ninteracts with a user through a series of typed inputs and alphanumeric displays. The level 0 data \nflow diagram for SafeHome, is shown in figure  \n \n \n \n \nDuring requirements analysis, more detailed flow models would be created for SafeHome. In \naddition, control and process specifications, a data dictionary, and various behavioral models would \nalso be created.  \n \nDesign  Steps  \n \nThe preceding example will be used to illustrate each step in transform mapping. The steps begin \nwith a re -evaluation of  work done during requirements analysis and then move to the design of the \nsoftware architecture.  \n \n \nStep 1. Review  the fundamental  system  model.  The fundamental system model encompasses the \nlevel 0 DFD and supporting information. In actuality, the design s tep begins with an evaluation of \nboth the System Specification and the Software Requirements Specification. Both documents \ndescribe information flow and structure at the software interface. Figure 1 and 2   depict level 0 and \nlevel 1 data flow for the SafeH ome software.  \n \n12\n4  \n \n \n \nStep 2. Review  and refine  data  flow diagrams  for the software.  Information obtained from \nanalysis models contained in the Software Requirements Specification is refined to produce greater \ndetail.", "mimetype": "text/plain", "start_char_idx": 205202, "end_char_idx": 210163, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8671b2f3-590c-460c-accd-6961142fcb40": {"__data__": {"id_": "8671b2f3-590c-460c-accd-6961142fcb40", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3531adac-7db6-4632-8bbb-6279d07252eb", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c69938e7dda1c57c9f96112850c885565603603f6a80e80a6aab13b2839b21f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "48540507-3861-4dfc-9e89-09d8b43532ab", "node_type": "1", "metadata": {}, "hash": "a661e422c603555c00bc72aedfd9503c7e3adc4d87652381949b1ef39552a434", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Design  Steps  \n \nThe preceding example will be used to illustrate each step in transform mapping. The steps begin \nwith a re -evaluation of  work done during requirements analysis and then move to the design of the \nsoftware architecture.  \n \n \nStep 1. Review  the fundamental  system  model.  The fundamental system model encompasses the \nlevel 0 DFD and supporting information. In actuality, the design s tep begins with an evaluation of \nboth the System Specification and the Software Requirements Specification. Both documents \ndescribe information flow and structure at the software interface. Figure 1 and 2   depict level 0 and \nlevel 1 data flow for the SafeH ome software.  \n \n12\n4  \n \n \n \nStep 2. Review  and refine  data  flow diagrams  for the software.  Information obtained from \nanalysis models contained in the Software Requirements Specification is refined to produce greater \ndetail. For example, the level 2 DFD for monitor sensors   is exam ined, and a level 3 data flow \ndiagram is derived . At level 3, each transform in the data flow diagram exhibits relatively high \ncohesion. That is, the process implied by a transform performs a single, distinct function that can be \nimplemented as a module9 in the SafeHome software.   Therefore, the DFD in figure   contains \nsufficient detail for a \"first cut\" at the design of architecture for the monitor sensors subsystem, and \nwe proceed without further refinement.  \n \n12\n5  \n \n \n \nStep 3. Determine  whether  the DFD  has transform  or transa ction  flow characteristics.  In \ngeneral, information flow within a system can always be represented as transform. However, when \nan obvious transaction characteristic   is encountered, a different design mapping is recommended. \nIn this step, the designer sele cts global (softwarewide) flow characteristics based on the prevailing \nnature of the DFD. In addition, local regions of transform or transaction flow are isolated. These \nsubflows can be used to refine program architecture derived from a global characterist ic described \npreviously. For now, we focus our attention only on the monitor sensors subsystem data flow \ndepicted in figure.  \n \n \n \nEvaluating the DFD , we see data entering the software along one incoming path and exiting along \nthree outgoing paths. No distinct transaction  center is implied (although the transform establishes \n12\n6  \n alarm conditions that could be perceived as such). Therefore, an overall transform characteristic will \nbe assumed for information flow.  \n \nStep 4. Isolate  the transform  center  by specifying  incoming  and outgoing  flow boundaries.  In \nthe preceding section incoming flow was described as a path in which information is converted \nfrom external to internal form; outgoing flow converts from internal to external form. Incoming and \noutgoing flow boundaries are open  to interpretation. That is, different designers may select slightly \ndifferent points in the flow as boundary locations. In fact, alternative design solutions can be \nderived by varying the placement of flow boundaries. Although care should be taken when \nboundaries are selected, a variance of one bubble along a flow path will generally have little impact \non the final program structure.  \n \nFlow boundaries for the example are illustrated as shaded curves running vertically through the \nflow in the above figure. T he transforms (bubbles) that constitute the transform center lie within the \ntwo shaded boundaries that run from top to bottom in the figure. An argument can be made to \nreadjust a boundary (e.g, an incoming flow boundary separating read sensors and acquire response \ninfo could be proposed). The emphasis in this design step should be on selecting reasonable \nboundaries, rather than lengthy iteration on placement of divisions.  \n \nStep 5. Perform  \"first -level  factoring.\"  Program  structure  represents  a top-down  distribution  \nof control.  Factoring results in a program structure in which top -level modules perform decision \nmaking and low -level modules perform most input, computation, and output work. Middle -level \nmodules perform some control and do moderate amounts of wo rk. \n \nWhen transform flow is encountered, a DFD is mapped to a specific structure (a call and return \narchitecture) that provides control for incoming, transform, and outgoing information processing. \nThis first -level factoring for the monitor sensors subsyst em is illustrated in figure below. A main \ncontroller (called monitor sensors executive) resides at the top of the program structure and \ncoordinates the following subordinate control functions:  \n \n\u2022 An incoming information processing controller, called sensor  input controller, coordinates receipt \nof all incoming data.", "mimetype": "text/plain", "start_char_idx": 209261, "end_char_idx": 214010, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "48540507-3861-4dfc-9e89-09d8b43532ab": {"__data__": {"id_": "48540507-3861-4dfc-9e89-09d8b43532ab", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8671b2f3-590c-460c-accd-6961142fcb40", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f2222376127139da4d69523ad805f688ba4dea8c1f51396908c565dcaafa7033", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "684dc86a-1b2e-4aaa-bb47-70e07cf9f597", "node_type": "1", "metadata": {}, "hash": "d28f83cd8d18711f4fed73a49cd3ce9e096e5cabd04bf138973809d1716d432a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Step 5. Perform  \"first -level  factoring.\"  Program  structure  represents  a top-down  distribution  \nof control.  Factoring results in a program structure in which top -level modules perform decision \nmaking and low -level modules perform most input, computation, and output work. Middle -level \nmodules perform some control and do moderate amounts of wo rk. \n \nWhen transform flow is encountered, a DFD is mapped to a specific structure (a call and return \narchitecture) that provides control for incoming, transform, and outgoing information processing. \nThis first -level factoring for the monitor sensors subsyst em is illustrated in figure below. A main \ncontroller (called monitor sensors executive) resides at the top of the program structure and \ncoordinates the following subordinate control functions:  \n \n\u2022 An incoming information processing controller, called sensor  input controller, coordinates receipt \nof all incoming data.  \n\u2022 A transform flow controller, called alarm conditions controller, supervises all operations on data in \ninternalized form (e.g., a module that invokes various data transformation procedures).  \n \u2022 An outgoing information processing controller, called alarm output controller,  \ncoordinates production of output information.  \n \n12\n7  \n \n \n \nAlthough a three -pronged structure is implied by figure complex flows in large systems may dictate \ntwo or more control modules for each of the  generic control functions described previously. The \nnumber of modules at the first level should be limited to the minimum that can accomplish control \nfunctions and still maintain good coupling and cohesion characteristics.  \n \nStep 6. Perform  \"second -level  factoring.\"  Second -level  factoring  is accomplished  by mapping  \nindividual  transforms  (bubbles)  of a DFD  into appropriate  modules  within  the \narchitecture.  Beginning at the transform center boundary and moving outward along incoming and \nthen outgoing paths, tr ansforms are mapped into subordinate levels of the software structure. The \ngeneral approach to second -level factoring for the SafeHome data flow is illustrated in figure.  \n \n \n12\n8  \n \n \n \n \nAlthough the figure illustrates a one -to-one mapping between DFD transforms and software \nmodul es, different mappings frequently occur. Two or even three bubbles can be combined and \nrepresented as one module (recalling potential problems with cohesion) or a single bubble may be \nexpanded to two or more modules. Practical considerations and measures o f design quality dictate \nthe outcome of secondlevel factoring. Review and refinement may lead to changes in this structure, \nbut it can serve as a \"first -iteration\" design.  \n \nSecond -level factoring for incoming flow follows in the same manner. Factoring is a gain \naccomplished by moving outward from the transform center boundary on the incoming flow side. \nThe transform center of monitor sensors subsystem software is mapped somewhat differently. Each \nof the data conversion or calculation transforms of the transf orm portion of the DFD is mapped into \na module subordinate to the transform controller. A completed first -iteration architecture is shown \nin figure.  \n \n12\n9  \n \n \n \n \nThe modules mapped in the preceding manner and shown in figure represent an initial design of \nsoftware architecture. Although modules are named in a manner that implies function, a brief \nprocessing narrative (adapted from the PSPEC created during analysis modeling) should be written \nfor each. The narrative describes  \n\u2022 Information that passes into and out of the module (a n interface description).  \n\u2022 Information that is retained by a module, such as data stored in a local data structure.  \n\u2022 A procedural narrative that indicates major decision points and tasks.  \n\u2022 A brief discussion of restrictions and special features (e.g., f ile I/O, hardwaredependent \ncharacteristics, special timing requirements).  \nThe narrative serves as a first -generation Design Specification. However, further refinement and \nadditions occur regularly during this period of design.  \n \nStep 7. Refine  the first-iteration  architecture  using  design  heuristics  for improved  software  \nquality.  A first -iteration architecture can always be refined by applying concepts of module \nindependence . Modules are exploded or imploded to produce sensible factoring, good cohesion, \nminimal coupling, and most important, a structure that can be implemented without difficulty, \ntested without confusion, and maintained without grief.  \n \nRefinements are dictated by the analysis and assessment methods described briefly , as well as \npractical con siderations and common sense. There are times, for example, when the controller for \nincoming data flow is totally unnecessary, when some input processing is required in a module that \nis subordinate to the transform controller, when high coupling due to glo bal data cannot be avoided, \nor when  \noptimal structural characteristics   cannot be achieved.", "mimetype": "text/plain", "start_char_idx": 213067, "end_char_idx": 218074, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "684dc86a-1b2e-4aaa-bb47-70e07cf9f597": {"__data__": {"id_": "684dc86a-1b2e-4aaa-bb47-70e07cf9f597", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "48540507-3861-4dfc-9e89-09d8b43532ab", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "23d17da4199b7c0f9e12513129cd7d8729db799e502adba8ff202877c4f749c5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac", "node_type": "1", "metadata": {}, "hash": "115e8c36e85fd859e0cd54f59d2a907f96f4ea463ad7b7f1df02d919373b1f63", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Step 7. Refine  the first-iteration  architecture  using  design  heuristics  for improved  software  \nquality.  A first -iteration architecture can always be refined by applying concepts of module \nindependence . Modules are exploded or imploded to produce sensible factoring, good cohesion, \nminimal coupling, and most important, a structure that can be implemented without difficulty, \ntested without confusion, and maintained without grief.  \n \nRefinements are dictated by the analysis and assessment methods described briefly , as well as \npractical con siderations and common sense. There are times, for example, when the controller for \nincoming data flow is totally unnecessary, when some input processing is required in a module that \nis subordinate to the transform controller, when high coupling due to glo bal data cannot be avoided, \nor when  \noptimal structural characteristics   cannot be achieved. Software requirements coupled with human \njudgment is the final arbiter. Many modifications can be made to the first iteration architecture \ndeveloped for the SafeHom e monitor sensors subsystem. Among many possibilities,  \n \n1. The incoming controller can be removed because it is unnecessary when a single incoming flow \npath is to be managed.  \n \n2. The substructure generated from the transform flow can be imploded into the m odule establish \nalarm conditions (which will now include the processing implied by select phone number). The \ntransform controller will not be needed and the small decrease in cohesion is tolerable.  \n \n3. The modules format display and generate display can be  imploded (we assume that display \nformatting is quite simple) into a new module called produce display.  \n \n13\n0  \n The refined software structure for the monitor sensors subsystem is shown in figure.  \n \n \n \n \nThe objective of the preceding seven steps is to develop an architectural re presentation of software. \nThat is, once structure is defined, we can evaluate and refine software architecture by viewing it as a \nwhole. Modifications made at this time require little additional work, yet can have a profound \nimpact on software quality.  \n \nThe reader should pause for a moment and consider the difference between the design approach \ndescribed and the process of \"writing programs.\" If code is the only representation of software, the \ndeveloper will have great difficulty evaluating or refining at a  global or holistic level and will, in \nfact, have difficulty \"seeing the forest for the trees.\"  \n \n14 Explain the design principles in detail  \nDesign principles are widely applicable laws, guidelines, biases and design considerations which \ndesigners apply wi th discretion. Professionals from many disciplines \u2014e.g., behavioral science, \nsociology, physics and ergonomics \u2014provided the foundation for design principles via their \naccumulated knowledge and experience.  \nTypes of Design Principles  \nDesigners use principles  such as  visibility , findability  and learnability  to address basic human \nbehaviors. We  use some design principles to guide actions . Perceived affordances  such as \nbuttons are an example. That way, we  put users in control in seamless experiences . \nUsability k ingpin Jakob Nielsen identified ten \u201ccommandments\u201d:  \n\uf0b7 Keep users informed  of system status  with constant feedback.  \n\uf0b7 Set information in a logical, natural order . \n\uf0b7 Ensure users can easily undo/redo actions . \n\uf0b7 Maintain consistent standards  so users know what to do next without having to learn new \ntoolsets.  \n\uf0b7 Prevent errors if possible ; wherever you can\u2019t do this,  warn  users before they commit to \nactions.  \n13\n1  \n \uf0b7 Don\u2019t make users remember information  \u2013 keep options, etc.  visible . \n\uf0b7 Make systems flexible  so novices and experts ca n choose  to do more or less on them.  \n\uf0b7 Design with aesthetics and minimalism in mind  \u2013 don\u2019t clutter with unnecessary items.  \n\uf0b7 Provide plain -language error messages  to pinpoint problems and likely solutions.  \n\uf0b7 Offer easy -to-search troubleshooting resources , if needed.  \nEmpathy expert Whitney Hess adds:  \n1. Don\u2019t interrupt or give users obstacles  \u2013 make obvious pathways which offer an easy ride.  \n2. Offer few options  \u2013 don\u2019t hinder users with nice -to-haves; give them needed alternatives instead.  \n3. Reduce distraction s \u2013 let users perform tasks consecutively, not simultaneously.  \n4. Cluster related objects together.  \n5. Have an easy -to-scan visual hierarchy that reflects users\u2019 needs , with commonly used items \nhandily available.  \n6. Make things easy to find.  \n7. Show users where they\u2019ve come from  and where they\u2019re headed with signposts/cues.  \n8. Provide context  \u2013 show how everything interconnects.  \n9.", "mimetype": "text/plain", "start_char_idx": 217161, "end_char_idx": 221878, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac": {"__data__": {"id_": "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "684dc86a-1b2e-4aaa-bb47-70e07cf9f597", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "91c99fb23e0ff5027386d0d01911bb84117234203e2719ebf60fe2726850269d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "965a72af-3845-49b1-b1d5-21712f0d8d8e", "node_type": "1", "metadata": {}, "hash": "e8d459b7ac11c3d589eea83042a1ba7a312e6520dacf03105fd1218ec0dcbd34", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Provide plain -language error messages  to pinpoint problems and likely solutions.  \n\uf0b7 Offer easy -to-search troubleshooting resources , if needed.  \nEmpathy expert Whitney Hess adds:  \n1. Don\u2019t interrupt or give users obstacles  \u2013 make obvious pathways which offer an easy ride.  \n2. Offer few options  \u2013 don\u2019t hinder users with nice -to-haves; give them needed alternatives instead.  \n3. Reduce distraction s \u2013 let users perform tasks consecutively, not simultaneously.  \n4. Cluster related objects together.  \n5. Have an easy -to-scan visual hierarchy that reflects users\u2019 needs , with commonly used items \nhandily available.  \n6. Make things easy to find.  \n7. Show users where they\u2019ve come from  and where they\u2019re headed with signposts/cues.  \n8. Provide context  \u2013 show how everything interconnects.  \n9. Avoid jargon . \n10. Make designs efficient and streamlined.  \n11. Use defaults wisely  \u2013 when you offer predetermined, well -consider ed options, you help \nminimize users\u2019 decisions and increase efficiency.  \n12. Don\u2019t delay users  \u2013 ensure quick interface responses.  \n13. Focus on emotion  \u2013 pleasure of use is as vital as ease of use; arouse users\u2019 passion to increase \nengagement.  \n14. Use \u201cless  is more\u201d  \u2013 make everything count in the design. If functional and aesthetic elements \ndon\u2019t add to the user experience, forget them.  \n15. Be consistent with navigational mechanisms , organizational structure, etc., to make a stable, \nreliable and predictable design.  \n16. Create a good first impression . \n17. Be trustworthy and credible  \u2013 identify yourself through your design to assure users and \neliminate uncertainty.  \n \n \n \n \n \n \n13\n2  \n .   UNIT \u2013 4 PART  \u2013A \n \n \nS.NO  QUESTIONS  \n1 What  are the characteristics  of good  tester?  NOV/ DEC - 10,MAY/JUN -13 \nAll tests should be traceable to customer requirements. Tests should be planned \nlong before testing begins.  \nThe Pareto principle applies to software testing.  \n2 Define software testing?  \nSoftware testing is a critical element of software quality assurance and represents the ultimate \nreview of specification, design, and coding.  \n3 What are the objectives of testing?  \ni. Testing is a process of executing a program with the intend of finding an error. ii. A good \ntest case is one that has high probability of finding  \n an undiscovered error. iii. A successful test is one that uncovers as an - \nyet undiscovered error.  \n4 What is integration testing?and What are the approaches of integration \ntesting? APR/MAY -11 \n \nIn this testing the individual software  modules are combined and tested as a group. It occurs \nafter unit testing & before system testing.  \n1. The non -incremental  testing.  \n2. Incremental  testing.  \n5 What  is regression  testing?  APR/MAY -15 , NOV/DEC - 11,NOV/DEC  \n    2013,  \nIt tends to verify the software a pplication after a change has been made. It  seeks  to  uncover  \nsoftware  errors  by  partially  retesting  a  modified  \nprogram.  \n13\n3  \n 6 Distinguish between stress and load testing  \nStress testing is subjecting a system to an unreasonable load while denying it the \nresources (e.g., RAM, disc, mips, interrupts, etc.) needed to process that  load.  \nLoad testing is subjecting a system to a statistically representative (usually) load. The \ntwo main reasons for using such loads is in support of software reliability testin g and in \nperformance testing. The term \"load testing\" by itself is too \nvague and imprecise to warrant use.  \n7 Define black box testing? APR/MAY -12,MAY/JUN -13 \nA black -box tests are used to demonstrate that software functions are operational, that \ninput is p roperly accepted and output is correctly produced, and that the integrity of \nexternal  \ninformation.  \n8 What is boundary condition testing? APR/MAY -12 \nIt is tested using boundary value analysis. (check BVA \u2013 16 mark question)  \n \n9 How is software testing res ults related to the reliability of software? NOV/DEC -12 \nApplying fault avoidance, fault tolerance and fault detection  for \nthe project helps to achieve reliability of software.  \n10 What is big -bang approach?  NOV/DEC -12 \nBig bang approach talks about testing as the last  phase of  \ndevelopment.", "mimetype": "text/plain", "start_char_idx": 221066, "end_char_idx": 225266, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "965a72af-3845-49b1-b1d5-21712f0d8d8e": {"__data__": {"id_": "965a72af-3845-49b1-b1d5-21712f0d8d8e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fdefa4ede38d28856f552a7484d65692ba6e14eeab0cf48d326fbf8b2a120d84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "97811389-4a6d-4f81-affe-a73ac5587a08", "node_type": "1", "metadata": {}, "hash": "d5300df56886bc107d03af3d22e59e1c912fdaa522347c92d74d65a79b9a14e6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The term \"load testing\" by itself is too \nvague and imprecise to warrant use.  \n7 Define black box testing? APR/MAY -12,MAY/JUN -13 \nA black -box tests are used to demonstrate that software functions are operational, that \ninput is p roperly accepted and output is correctly produced, and that the integrity of \nexternal  \ninformation.  \n8 What is boundary condition testing? APR/MAY -12 \nIt is tested using boundary value analysis. (check BVA \u2013 16 mark question)  \n \n9 How is software testing res ults related to the reliability of software? NOV/DEC -12 \nApplying fault avoidance, fault tolerance and fault detection  for \nthe project helps to achieve reliability of software.  \n10 What is big -bang approach?  NOV/DEC -12 \nBig bang approach talks about testing as the last  phase of  \ndevelopment. All the defects are found in the last phase and cost of rework can be huge.  \n13\n4  \n 11 Why does software fail after it has passed from acceptance testing? APR/MAY 2016  \n \nEach acceptance test represents some expected result from th e system. Customers are \nresponsible for verifying the correctness of the acceptance tests and reviewing test scores to \ndecide which failed tests are of highest priority. Acceptance tests are also used as regression \ntests prior to a production release. A us er story is not considered complete until it has passed its \nacceptance tests. This means that new acceptance tests must be created for each iteration or the \ndevelopment team  will \nreport zero progress.  \n12 What are the objectives of testing?  \nxii. Testing is a process of executing a program with the intend of finding an  error.  \nxiii. A good test case is one that has high probability of finding an undiscovered  error.  \nxiv. A successful test is one that uncovers as an -yet undiscovered  \nerror.  \n13 What are the testing principles t he software engineer must apply while  performing\n the software  testing?     MAY/JUNE  2016,  \nAPRIL/MAY 2018  \ni. All tests should be traceable to customer  requirements.  \nii. Tests should be planned long before testing  begins.  \n iii. The pareto principle can be applied t o software testing -80%  \nof all  \nerrors uncovered during testing will likely be traceable to 20% of all program modules. \niv. Testing should begin \u201cin the small\u201d and progress toward testing \u201cin the large\u201d.  \nv. Exhaustive testing is not possible.  \nvi. To be most effecti ve, an independent third party should conduct  testing.  \n13\n5  \n 14 What are the two levels of testing?  \ni. Component testing Individual components are tested. Tests  are \nderived from developer\u201fs experience.  \nii. System Testing The group of components are integrated to create a system or sub - \nsystem is done.These tests are based on the system  specification.  \n15 What are the various testing activities?  \niii. Test planning  \niv. Test case  design \nv. Test execution  \nvi. Data  collection  \nvii. Effective evaluation  \n16 What is equivalence partitioning?  \nEquivalence partitioning is a black box technique that divides the input domain into \nclasses of data. From this data test cases can be derived. Equivalence class represents a set of \nvalid or invalid states for  \ninput conditions.  \n17 What methods are used for breaking very long expression and statements? \nNOV/DEC2016  \nRefactoring is done to break long expression and ststements.  \n16 What are the various testing strategi es for conventional software?  \ni. Unit testing ii. Integration testing. iii. Validation testing. iv. System testing.  \n18 How can refactoring be made more effective? APR/MAY 2016  \n \nRefactoring improves nonfunctional  attributes of the software . Advantages include improved \ncode readability and reduced complexity ; these can improve source -code maintainability  and \ncreate a more  \nexpressive interna l architecture or object model to improve extensibility  \n13\n6  \n 19 How will you tes t a simple loop  NOV/DEC 2015  \n \n\uf0b7 A simple loop is tested in the following  way:  \n\uf0b7 Skip the entire  loop.  \n\uf0b7 Make 1 pass through the loop.  \n\uf0b7 Make 2 passes through the loop.  \n\uf0b7 Make x passes through the loop where x<y, n is the maximum number of passes through \nthe loop.", "mimetype": "text/plain", "start_char_idx": 224467, "end_char_idx": 228629, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "97811389-4a6d-4f81-affe-a73ac5587a08": {"__data__": {"id_": "97811389-4a6d-4f81-affe-a73ac5587a08", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "965a72af-3845-49b1-b1d5-21712f0d8d8e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62ded8caa9380ab627eeeae6e95ba11cc09485b244c807ec92cb8097a1f6e156", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6cde2b4-2390-4003-8c9f-f6a2f529f445", "node_type": "1", "metadata": {}, "hash": "bc0349c638aced886f2e5e7e447e683ee5e978ddf8278be527906e131ad1a872", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "i. Unit testing ii. Integration testing. iii. Validation testing. iv. System testing.  \n18 How can refactoring be made more effective? APR/MAY 2016  \n \nRefactoring improves nonfunctional  attributes of the software . Advantages include improved \ncode readability and reduced complexity ; these can improve source -code maintainability  and \ncreate a more  \nexpressive interna l architecture or object model to improve extensibility  \n13\n6  \n 19 How will you tes t a simple loop  NOV/DEC 2015  \n \n\uf0b7 A simple loop is tested in the following  way:  \n\uf0b7 Skip the entire  loop.  \n\uf0b7 Make 1 pass through the loop.  \n\uf0b7 Make 2 passes through the loop.  \n\uf0b7 Make x passes through the loop where x<y, n is the maximum number of passes through \nthe loop.  \n\uf0b7 Make \"y\",\"y -1\",\"y+1\" passes through the loop where \"y\" is the maximum number of \nallowable passes through the  loop.  \n20 What are the conditions exists after performing validation testing?  \nAfter  performing  the validation  testing  there  exists  two conditions.  \n\uf0b7 The function or performance characteristics are according to the specifications and are  \naccepted.  \n\uf0b7 The requirement specifications are derived and the deficiency list is created. The \ndeficiencies then can be resolved by  establishing  \nthe proper communication wi th the customer.  \n21 Distinguish between alpha and beta testing.  MAY/JUNE 2016  \n\uf0b7 Alpha and beta testing are the types of acceptance  testing.  \n\uf0b7 Alpha test: The alpha testing is attesting in which the version of complete software is \ntested by the customer under the supervision of developer. This testing is performed  at \ndeveloper\u2019s  site. \n \uf0b7 Beta test: The beta testing is a testing in which the version of the software is tested by \nthe customer without the developer  being  \npresent. This testing is performed at custom er\u2019s site.  \n13\n7  \n  \n22 What are the various types of system testing?  \n3. Recovery testing \u2013 is intended to check the system\u201f s ability  to \nrecover from failures.  \n4. Security testing \u2013 verifies that system protection mechanism prevent  improper  \npenetration or data alteration.  \n5. Stress testing \u2013 Determines breakpoint of a system to establish maximum service  \nlevel.  \n6. Perfo rmance  testing  \u2013 evaluates  the run time performance  of \nthe software, especially real -time software.  \n23 Define debugging and What are the common approaches in debugging?  \nDebugging is defined as the process of removal of defect. It occurs as a consequence o f \nsuccessful testing  \nBrute force method: The memory dumps and run -time tracks are examined and program with  \nwrite statements is loaded to obtain clues to error causes.  \nBack tracking method: The source code is examined by looking backwards from symptom to  \npotential causes of errors.  \nCause elimination method: This method uses binary partitioning to reduce the number of \nlocations where errors can exists.  \n24 Distinguish between verification and validation. NOV/DEC2016,  NOV/DEC 2017, \nAPRIL/MAY 2018  \nVerification  Validation  \n \nEvaluates  the  intermediary  products  Evaluates the final product  to \n \n   to check   whether  it meets  the check whether it meets the specific\n requirements   ofthe business  needs.  \nparticular phase  \n13\n8  \n  \n The \u201cdriver\u201d is a program that accepts t he test data and prints the  \nrelevant results.  \nThe \u201cstub\u201d is a subprogram that uses the module interfaces and performs the minimal data manipulation if \nrequired.  Checks whether the product is  built   It   determines   whether    the  as per the specified \nrequirement and software is fit  for  use  and design  specification.  satisfy the business  \nneed.  \nChecks \u201cAre we building  the product  Checks \u201cAre we building the right\u201d?  right  \nproduct\u201d?  \nThis  is  done  wi thout  executing  the Is done with executing the software  software  \nInvolves  all the static  testing  Includes  all the dynamic techniques  \n    testing  techniques.  \n Examples  includes  reviews,  Example includes all types of inspection  and \nwalkthrough   testing l ike smoke,  regression,  \nfunctional, systems and UAT   \n25 What is meant by structural testing?  \nIn structural testing derivation of test cases is according to program \nstructure. Hence knowledge of the program is used to identify additional test cases.  \n26 Wha t is the need for regression testing?", "mimetype": "text/plain", "start_char_idx": 227889, "end_char_idx": 232224, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d6cde2b4-2390-4003-8c9f-f6a2f529f445": {"__data__": {"id_": "d6cde2b4-2390-4003-8c9f-f6a2f529f445", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "97811389-4a6d-4f81-affe-a73ac5587a08", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "dd3a43b46c767ec6fe2a1ff44def6eaf45126d9548a2be3aca32ce8d1a129649", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3b673e4d-93db-4704-bbaa-ff1d467560a8", "node_type": "1", "metadata": {}, "hash": "6b129ed836d85ddee6fac86c56ce0883b23358303ee17a48447a07c48b85737f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "satisfy the business  \nneed.  \nChecks \u201cAre we building  the product  Checks \u201cAre we building the right\u201d?  right  \nproduct\u201d?  \nThis  is  done  wi thout  executing  the Is done with executing the software  software  \nInvolves  all the static  testing  Includes  all the dynamic techniques  \n    testing  techniques.  \n Examples  includes  reviews,  Example includes all types of inspection  and \nwalkthrough   testing l ike smoke,  regression,  \nfunctional, systems and UAT   \n25 What is meant by structural testing?  \nIn structural testing derivation of test cases is according to program \nstructure. Hence knowledge of the program is used to identify additional test cases.  \n26 Wha t is the need for regression testing? APR/MAY 2015  \nThe purpose of regression testing is to confirm that a recent program or code change has \nnot adversely affected existing features. Regression testing is nothing but full or partial \nselection of already exe cuted test  \ncases which are re -executed to ensure existing functionalities work fine.  \n27 Write about drivers and stubs . NOV/DEC 2017  \nDrivers and stub software need to be developed to test incompatible software.  \n13\n9  \n 28 What is cyclomatic complexity?  \nCyclomatic   complexity   is    software  metric   that gives the quantitative  \nMeasure of logical complexity of the program.  \n29 How to compute the cyclomatic complexity?  \nThe cyclomatic complexity can be computed by any one of the following ways. 1. \nThe numbers of regions of the flow graph  correspond to the cyclom atic complexity.  \n2. Cyclomatic complexity (G), for the flow graph G, is defined as: V(G)=E -N+2, E \n-- number of flow graph edges, N -- number of flow graph  nodes  \n3. V(G) = P+1 Where P is the number of predicate  nodes  \ncontained in the flow graph.  \n30 List out the applications of GUI? April /May 2015  \nGUI-Graphical   User   Interface -   is    a    type    of interface that  allows users  to interact\n with electronic  devices through graphical icons \nand visual indicators such as secondary notation , as opposed to text-based interfaces,  typed \ncommand labels or text navigation  \n \nIn addition to computers, GUIs can be found in hand -held devices such as MP3 players, \nportable media players, gaming devices and smaller household, smar tphones office and \nindustry  equipment.  \nEg:Ticket booking, Inventory tool, Billing Machine, Windows OS  \n31 What is flow graph notation and how it is important. April /May  2015  \nA control flow graph (CFG) in computer science is a representation,  Using graph notation, \nof all paths that might be traversed through a program during its execution.  \n \n14\n0  \n 32 What is smoke testing ? APRIL /MAY 2017  \nSmoke Testing , also known as \u201cBuild Verification Testing \u201d, is a type of software testing \nthat comprises of a non -exhaustive set of tests that aim at ensuring that the most important \nfunctions work. The results of this testing is used to decide if a build is stable enough to \nproceed with  \nfurther testing . \n33 List testing strategies that address verification. Which types of testing a ddress \nvalidation ? APRIL/MAY 2017  \nVerification involves all the static testing techniques. Examples includes reviews, \ninspection and walkthrough  \nValidation includes all the dynamic testing techniques. Example includes all types of \ntesting like smoke, regr ession, functional, systems and  UAT  \n33 \nWhat are the types of static testing  tools?  \n \nThere are three types of static testing  tools.  \n \n\uf0d8 Code based testing tools : These tools take source code as input and generate test  \ncases.  \n\uf0d8 Specialized testing tools : Using  this language the detailed test specification can be \nwritten for each test  case.  \n\uf0d8 Requirement -based testing tools : These tools help in designing the as per user  \nrequirements.  \n34 \nWhat is done in test design step?  \n \nThe details of the layout, tooling and sta ndards required for test  \n development are designed in this stage.  \n14\n1  \n 35 Distinguish between verification and validation ? \nVerification refers to the set of activities that ensure that software correctly implements a \nspecific function. Validation refers to a different set of activities that ensure that the \nsoftware that has been built is  \ntraceable to the customer requirements.  \n36 Write about drivers and stubs?  \nDrivers and stub software need to be developed to test incompatible software.", "mimetype": "text/plain", "start_char_idx": 231504, "end_char_idx": 235911, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3b673e4d-93db-4704-bbaa-ff1d467560a8": {"__data__": {"id_": "3b673e4d-93db-4704-bbaa-ff1d467560a8", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6cde2b4-2390-4003-8c9f-f6a2f529f445", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "084908c5d2d015141f28475e664e40ad8dedd8e6f4140772bd55e33eb729e6b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c06a881-d356-48e1-9dbf-319e1489b5ca", "node_type": "1", "metadata": {}, "hash": "439cd56540ec1141a87713911f7763d22f6f4a0c1e12551024bd6e916b42cf01", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0d8 Code based testing tools : These tools take source code as input and generate test  \ncases.  \n\uf0d8 Specialized testing tools : Using  this language the detailed test specification can be \nwritten for each test  case.  \n\uf0d8 Requirement -based testing tools : These tools help in designing the as per user  \nrequirements.  \n34 \nWhat is done in test design step?  \n \nThe details of the layout, tooling and sta ndards required for test  \n development are designed in this stage.  \n14\n1  \n 35 Distinguish between verification and validation ? \nVerification refers to the set of activities that ensure that software correctly implements a \nspecific function. Validation refers to a different set of activities that ensure that the \nsoftware that has been built is  \ntraceable to the customer requirements.  \n36 Write about drivers and stubs?  \nDrivers and stub software need to be developed to test incompatible software. The \u201cdriver\u201d \nis a prog ram that accepts the test data and prints the relevant results. The \u201cstub\u201d is a \nsubprogram that uses the module  \ninterfaces and performs the minimal data manipulation if required.  \n37 Define debugging . \nDebugging is defined as the process of removal of defec t. It occurs as a consequence of \nsuccessful testing.  \n38 \nDefine the terms:  \n \na) Graph  Matrices.  \n \nb) Connection  Matrices.  \n \nGraph Matrices:  \n \n To develop software tool the data structure used is graph  Matrix.  \n \n Square Matrix  \n \n Size equals number of nodes on the Flow  graph \n \nConnection Matrices:  \n \n It Link Weight = 1= > Connection  Exists  \n \n It Link Weight=1=>Connection Does not  Exists . \n14\n2  \n 39 \nWhat errors are commonly found during Unit Testing?  \n \nErrors commonly found during Unit Testing are:  \n \n\uf0b7 Misunderstood or incorrect arithmetic  precedence  \n \n\uf0b7 Mixed Mode  Operations  \n \n\uf0b7 Incorrect  Initializations  \n \n\uf0b7 Precision  Accuracy  \n \n\uf0b7 Incorrect Symbolic representation of  expression.  \n40 \nWhat problems may be encountered when Top -Down Integration is chosen?  \nFollowing problems may be encountered when Top Dow n Integration is chosen:  \n\uf0b7 Develop stubs that perform limited functions that simulate the actual module.  \nIntegrate the software from the bottom of the hierarchy upward  \n41 \nWhat are the Steps in Bottom -Up Integration?  \n \nSteps in Bottom -Up Integration are:  \n \n\uf0b7 Low level components are combined into clusters perform specific software sub  \nfunction.  \n\uf0b7 Driver is written to coordinate test case input and  output.  \n \n\uf0b7 Cluster is tested.  \n14\n3  \n 42 \nWhat is Flow Graph Notation?  \nFlow Graph Notation means Simple notation for representing  Control Flow. It is drawn \nonly when Logical Structure of component is complex.  \n43 \nWhat is acceptance testing  \n \nAcceptance testing : This type of testing involves testing of the system with customer data \nif the system behaves as per customer need then it is  accepted.  \n44 \nWhat are the various testing strategies for conventional software?  \n \nThe various testing strategies are:  \n \n(i) Unit testing  (ii) Integration  testing  \n \n(iii) Validation  testing  (iv) System  testing . \n45 \nList some of the testing done during SDLC.  \n \nWhite box testing, black box testing, integration testing, system testing, installation testing. \nRegression testing, Acceptance testing . \n46 \nWhat is functionality testing?  \n \nIt is a black box testing which exercises the basic functionality of the product f rom an \nexternal; perspective.  \n14\n4  \n 47 \nWhat are the steps carried out in installation  testing?  \n \nAns. The steps carried out in installation testing  are: \n \n\u2022 Packaging  \u2022 Documenting  \n \n\u2022 Installing  \u2022 Verifying  \n48 \nWhat are the objective of Formal Technical Reviews. Ans.  The Objective \nof Formal Technical Reviews are:  \n\uf0b7 Uncover  errors  in function,  logic  and implementation  for representation of  \nsoftware.  \n\uf0b7 Software represented according to predefined  standard.  \n \n\uf0b7 Verify software under review meets  requirements  \n \n\uf0b7 Achieve software d eveloped in Uniform  Manner.  \n \n\uf0b7 Make projects more  manageable.  \n49 \nExplain Integrated testing team model?  \nAns. There in one project manage who manages both the development and the testing \nfunctions  \n50 \nWhat are the common approaches in  debugging? Ans. The \ncommon approaches tin debugging  are: \n\uf0b7 Brute force method: The memory dumps and run - time tracks are examined and \nprogram with write statements in loaded to obtain clues to error  causes.", "mimetype": "text/plain", "start_char_idx": 234999, "end_char_idx": 239453, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0c06a881-d356-48e1-9dbf-319e1489b5ca": {"__data__": {"id_": "0c06a881-d356-48e1-9dbf-319e1489b5ca", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3b673e4d-93db-4704-bbaa-ff1d467560a8", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "67a4fe4a04edb9f868a6a0ada6b1efab5171e56b9c6c81d0efa0b53f6d8a7549", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4d278904-a78c-41c6-bac9-7a61c4c21ab4", "node_type": "1", "metadata": {}, "hash": "a722937cfcd934b97027724d92fca8adefeafca83cdeec786499e0d7ab50e7b0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Ans.  The Objective \nof Formal Technical Reviews are:  \n\uf0b7 Uncover  errors  in function,  logic  and implementation  for representation of  \nsoftware.  \n\uf0b7 Software represented according to predefined  standard.  \n \n\uf0b7 Verify software under review meets  requirements  \n \n\uf0b7 Achieve software d eveloped in Uniform  Manner.  \n \n\uf0b7 Make projects more  manageable.  \n49 \nExplain Integrated testing team model?  \nAns. There in one project manage who manages both the development and the testing \nfunctions  \n50 \nWhat are the common approaches in  debugging? Ans. The \ncommon approaches tin debugging  are: \n\uf0b7 Brute force method: The memory dumps and run - time tracks are examined and \nprogram with write statements in loaded to obtain clues to error  causes.  \n\uf0b7 Back tracking method: The source code is examined by  looking  \n14\n5  \n  backwards f rom symptom to potential causes or errors.  \n \n\uf0b7 Causes eliminations method: This method uses binary partitioning to reduce the \nnumber of location where errors can exists.  \n \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 What is black box & white -box testing ? Explain how basis path testing helps to derive test \ncases to test every statement of a program. NOV/DEC -12, APRIL/MAY 2015, NOV/DEC  \n2017, APRIL/MAY  2017  \nCriteria  Black Box Testing  White Box Testing  \nDefinition  Black Box Testing is a software testing \nmethod in which the internal structure/ \ndesign/ implementation of the item being \ntested is NOT known to the tester  White Box Testing is a software \ntesting method in which the internal \nstructure/ design/ imp lementation of \nthe item being tested is known to the \ntester.  \nLevels \nApplicable To  Mainly applicable to higher levels of \ntesting: Acceptance Testing  \nSystem Testing  Mainly applicable to lower levels of \ntesting: Unit Testing  \nIntegration Testing  \nResponsibility  Generally, independent Software Testers  Generally, Software Developers  \nProgramming \nKnowledge  Not Required  Required  \nImplementation \nKnowledge  Not Required  Required  \nBasis for Test \nCases  Requirement Specifications  Detail Design  \n \n2 Define: Regression testing. Distinguish: top -down and bottom -up integration. How is \ntesting different from debugging ? Justify NOV/DEC -10, APRIL/MAY 2018  \nRegression testin g (rarely  non-regression testing[1]) is re -running  functional  and non-\nfunctional tests  to ensure that previously developed and tested software still performs \nafter a change.[2] If not, that would be called a  regression . Changes that may require \nregression testing include  bug fixes, software enhancements,  configuration  changes, and \n14\n6  \n even substitution of  electronic components .[3] As regression test suites tend to grow with \neach found defect, test automation is frequently involved. Sometimes a  change impact \nanalysis  is performed to determine an appropriate subset of test  \n \n \nBASIS FOR \nCOMPARISON  TOP -DOWN INTEGRATION  \nTESTING  BOTTOM -UP \nINTEGRATION \nTESTING  \nBasic  Uses stubs as the momentary \nreplacements for the invoked modules \nand simulates the behaviour of the \nseparated lower -level modules.  Use test drivers to initiate \nand pass the required data \nto the lower -level of \nmodules.  \nBeneficial  If the significant d efect occurs toward \nthe top of the program.  If the crucial flaws \nencounters towards the \nbottom of the program.  \nApproach  Main function is written at first then the \nsubroutines are called from it.  Modules are created first \nthen are integrated with the \nmain function.  \nImplemented on  Structure/procedure -oriented \nprogramming languages.  Object -oriented \nprogramming languages.  \n14\n7  \n Risk analysation  Collaborating the impact of internal \noperational failures.  Models are used to analyze \nthe individual process.  \nComplexity  Simple  Complex and highly data \nintensive.  \nWorks on  Big to small components.  Small to big components.  \n \n \nTesting  and Debugging  are significant activities during software development and \nmaintenance.  Testing  aims at finding a problem while  Debugging  aims a t solving the \nproblem. Only after the testing team reports the  defect , debugging  can take place.  With \ndebugging, the developer identifies the problem in the system/application/code. Once \nthe developer has fixed the bug, tester re -tests to ensure that the e rror/bug no longer \nexists.", "mimetype": "text/plain", "start_char_idx": 238703, "end_char_idx": 243045, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4d278904-a78c-41c6-bac9-7a61c4c21ab4": {"__data__": {"id_": "4d278904-a78c-41c6-bac9-7a61c4c21ab4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c06a881-d356-48e1-9dbf-319e1489b5ca", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7dc9789d03cce144a260e4f621b6df628f019a8e30a27cab9b88cce8520c2b2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9", "node_type": "1", "metadata": {}, "hash": "0a89a658e458db0ba67b282b3b792f9f9fe9e69e84b7d1cd6e343dc90a5bf717", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Modules are created first \nthen are integrated with the \nmain function.  \nImplemented on  Structure/procedure -oriented \nprogramming languages.  Object -oriented \nprogramming languages.  \n14\n7  \n Risk analysation  Collaborating the impact of internal \noperational failures.  Models are used to analyze \nthe individual process.  \nComplexity  Simple  Complex and highly data \nintensive.  \nWorks on  Big to small components.  Small to big components.  \n \n \nTesting  and Debugging  are significant activities during software development and \nmaintenance.  Testing  aims at finding a problem while  Debugging  aims a t solving the \nproblem. Only after the testing team reports the  defect , debugging  can take place.  With \ndebugging, the developer identifies the problem in the system/application/code. Once \nthe developer has fixed the bug, tester re -tests to ensure that the e rror/bug no longer \nexists. The figure given below demonstrates the fact very well  \n3 Write a note on equivalence partitioning & boundary value analysis of black box \ntesting APR/MAY -16 , NOV/DEC -15 \nEquivalence partitioning (EP) is a specification -based or bl ack-box technique. It can be \napplied at any level of testing and is often a good technique to use first.  \n\uf0b7 The idea behind this technique is to divide (i.e. to partition) a set of test conditions into \ngroups or sets that can be considered the same (i.e. the system should handle them \nequivalently), hence \u2018equivalence partitioning\u2019.  Equivalence partitions  are also known \nas equivalence classes \u2013 the two terms mean exactly the same thing.  \n\uf0b7 In equivalence -partitioning technique we need to test only one condition fr om each \npartition. This is because we are assuming that all the conditions in one partition will be \ntreated in the same way by the software. If one condition in a partition works, we assume \nall of the conditions in that partition will work, and so there is  little point in testing any of \nthese others. Similarly, if one of the conditions in a partition does not work, then we \nassume that none of the conditions in that partition will work so again there is little point \nin testing any more in that partition.  \n \n4 What is unit testing? Why is it important? Explain the unit test consideration and \ntest procedure. APR/MAY - 11,MAY/JUN -13 NOV/DEC2015  \nA unit test  is the smallest testable part of an application like functions, \nclasses,  procedures, interfaces. Unit testing is a method by which individual units of \nsource code are tested to determine if they are fit for use.  \n14\n8  \n \uf0b7 Unit tests are basically written and executed by software developers  to make sure that \ncode meets its design and requirements and behaves as expected.  \n\uf0b7 The goal of unit testing is to segregate each part of the program and test that the \nindividual parts are working correctly.  \n\uf0b7 This means that for any function or procedure when a set of inputs are given then it \nshould return the proper values. It should handle the failures  gracefully during the course \nof execution when any invalid input is given.  \n\uf0b7 A unit test provides a written contract that the piece of code must assure. Hence it has \nseveral benefits.  \n\uf0b7 Unit testing is basically done before integration as shown in  the image below.  \n \nMethod Used for unit testing:  White Box Testing method is used for executing the unit test.  \nWhen Unit testing should be done?  \nUnit testing should be done before Integration testing.  \nBy whom unit testing should be done?  \nUnit testing should be done by the developers.  \nAdvantages of Unit testing:  \n1. Issues are found at early stage. Since unit testing are carried out by developers wher e they test \ntheir individual code before the integration. Hence the issues can be found very early and can be \nresolved then and there without impacting the other piece of codes.  \n2. Unit testing helps in maintaining and changing the code. This is possible b y making the codes \nless interdependent so that unit testing can be executed. Hence chances of impact of changes to \nany other code gets reduced.  \n3. Since the bugs are found early in unit testing hence it also helps in reducing the cost of bug \nfixes. Just im agine the cost of bug found during the later stages of development like during \nsystem testing or during acceptance testing.  \n4. Unit testing helps in simplifying the debugging process. If suppose a test fails then only latest \n14\n9  \n changes made in code needs to b e debugged.  \n \n5 Explain Integration & debugging activities?", "mimetype": "text/plain", "start_char_idx": 242141, "end_char_idx": 246674, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9": {"__data__": {"id_": "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4d278904-a78c-41c6-bac9-7a61c4c21ab4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a51df3b05f0f765c48b9d437ae174a337cabb886ab38bf64c32c2641969f7ec3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7f263947-7383-43a2-be22-39b99cb5a91f", "node_type": "1", "metadata": {}, "hash": "7d0b0f153dad2fdf0f1bed2e06b7fc4e7b66d6c400048f5d0449e3de3b54eec9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Since unit testing are carried out by developers wher e they test \ntheir individual code before the integration. Hence the issues can be found very early and can be \nresolved then and there without impacting the other piece of codes.  \n2. Unit testing helps in maintaining and changing the code. This is possible b y making the codes \nless interdependent so that unit testing can be executed. Hence chances of impact of changes to \nany other code gets reduced.  \n3. Since the bugs are found early in unit testing hence it also helps in reducing the cost of bug \nfixes. Just im agine the cost of bug found during the later stages of development like during \nsystem testing or during acceptance testing.  \n4. Unit testing helps in simplifying the debugging process. If suppose a test fails then only latest \n14\n9  \n changes made in code needs to b e debugged.  \n \n5 Explain Integration & debugging activities?  MAY/JUN -15 \n \nIntegration  testing  is the process of testing the interface between two software units or module. \nIt\u2019s focus on determining the correctness of the interface. The purpose of the integra tion testing is \nto expose faults in the interaction between integrated units. Once all the modules have been unit \ntested, integration testing is performed.  \n \nIntegration test approaches \u2013 \nThere are four types of integration testing approaches. Those approac hes are the following:  \n1. Big -Bang Integration Testing \u2013 \nIt is the simplest integration testing approach, where all the modules are combining and verifying \nthe functionality after the completion of individual module testing. In simple words, all the \nmodule s of the system are simply put together and tested. This approach is practicable only for \nvery small systems. If once an error is found during the integration testing, it is very difficult to \nlocalize the error as the error may potentially belong to any of  the modules being integrated. So, \ndebugging errors reported during big bang integration testing are very expensive to fix.  \nAdvantages  \n\uf0b7 It is convenient for small systems.  \nDisadvantages:  \n\uf0b7 There will be quite a lot of delay because you would have to wait for all the modules to \nbe integrated.  \n\uf0b7 High risk critical modules are not isolated and tested on priority since all modules are \ntested at once.  \n2. Bottom -Up Integration Testing \u2013 \nIn bottom -up testing, each module at lower levels is tested with higher modules un til all modules \nare tested. The primary purpose of this integration testing is, each subsystem is to test the \ninterfaces among various modules making up the subsystem. This integration testing uses test \ndrivers to drive and pass appropriate data to the low er level modules.  \nAdvantages:  \n\uf0b7 In bottom -up testing, no stubs are required.  \n\uf0b7 A principle advantage of this integration testing is that several disjoint subsystems can be \ntested simultaneously.  \nDisadvantages:  \n\uf0b7 Driver modules must be produced.  \n\uf0b7 In this testing, the complexity that occurs when the system is made up of a large number \nof small subsystem.  \n3. Top -Down Integration Testing \u2013 \nTop-down integration testing technique used in order to simulate the behaviour of the lower -level \nmodules that are not yet integra ted.In this integration testing, testing takes place from top to \nbottom. First high -level modules are tested and then low -level modules and finally integrating the \nlow-level modules to a high level to ensure the system is working as intended.  \nAdvantages:  \n\uf0b7 Separately debugged module.  \n\uf0b7 Few or no drivers needed.  \n15\n0  \n \uf0b7 It is more stable and accurate at the aggregate level.  \nDisadvantages:  \n\uf0b7 Needs many Stubs.  \n\uf0b7 Modules at lower level are tested inadequately.  \n4. Mixed Integration Testing \u2013 \nA mixed integration testing is also called sandwiched integration testing. A mixed integration \ntesting follows a combination of top down and bottom -up testing approaches. In top -down \napproach, testing can start only after the top -level module have been coded and unit tested. In \nbottom -up app roach, testing can start only after the bottom level modules are ready. This \nsandwich or mixed approach overcomes this shortcoming of the top -down and bottom -up \napproaches. A mixed integration testing is also called sandwiched integration testing.  \nAdvantag es: \n\uf0b7 Mixed approach is useful for very large projects having several sub projects.  \n\uf0b7 This Sandwich approach overcomes this shortcoming of the top -down and bottom -up \napproaches.  \nDisadvantages:  \n\uf0b7 For mixed integration testing, require very high cost because one p art has Top -down \napproach while another part has bottom -up approach.", "mimetype": "text/plain", "start_char_idx": 245767, "end_char_idx": 250425, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7f263947-7383-43a2-be22-39b99cb5a91f": {"__data__": {"id_": "7f263947-7383-43a2-be22-39b99cb5a91f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4f993486bc2a86fd31de6b0bd8319c407c15f08e6523f805abad38cf8fc53f95", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c", "node_type": "1", "metadata": {}, "hash": "700a65c618b876d90e2e06d5564ce83181f4184c3171f6750a57be6db444c56f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A mixed integration \ntesting follows a combination of top down and bottom -up testing approaches. In top -down \napproach, testing can start only after the top -level module have been coded and unit tested. In \nbottom -up app roach, testing can start only after the bottom level modules are ready. This \nsandwich or mixed approach overcomes this shortcoming of the top -down and bottom -up \napproaches. A mixed integration testing is also called sandwiched integration testing.  \nAdvantag es: \n\uf0b7 Mixed approach is useful for very large projects having several sub projects.  \n\uf0b7 This Sandwich approach overcomes this shortcoming of the top -down and bottom -up \napproaches.  \nDisadvantages:  \n\uf0b7 For mixed integration testing, require very high cost because one p art has Top -down \napproach while another part has bottom -up approach.  \n\uf0b7 This integration testing cannot be used for smaller system with huge interdependence \nbetween different modules.  \nDEBUGGING  \nIt is a systematic process of spotting and fixing the number of b ugs, or defects, in a piece of \nsoftware so that the software is behaving as expected. Debugging is harder for complex systems \nin particular when various subsystems are tightly coupled as changes in one system or interface \nmay cause bugs to emerge in anothe r. \nDebugging is a developer activity and effective debugging is very important before testing \nbegins to increase the quality of the system. Debugging will not give confidence that the system \nmeets its requirements completely but testing gives confidence.  \n \n6 Explain software testing types? APR/MAY -16, NOV/DEC 2015  \nPress -Pg-no- 384 \n7 Write elaborately on unit testing and regression testing. How do you develop test \nsuites. APRIL/MAY -15, APRIL/MAY 2018  \nUnit testing, a testing technique using which individual mo dules are tested to determine if there \nare any issues by the developer himself. It is concerned with functional correctness of the \nstandalone modules.  \nThe main aim is to isolate each unit of the system to identify, analyze and fix the defects.  \nUnit Testing  - Advantages:  \n\uf0b7 Reduces Defects in the Newly developed features or reduces bugs when changing the \nexisting functionality.  \n\uf0b7 Reduces Cost of Testing as defects are captured in very early phase.  \n\uf0b7 Improves design and allows better refactoring of code.  \n\uf0b7 Unit Tests,  when integrated with build gives the quality of the build as well.  \n15\n1  \n Unit Testing LifeCyle:  \n \nUnit Testing Techniques:  \n\uf0b7 Black Box Testi ng - Using which the user interface, input and output are tested.  \n\uf0b7 White Box Testing - used to test each one of those functions behaviour is tested.  \n\uf0b7 Gray Box Testing - Used to execute tests, risks and assessment methods.  \nRegression testing a black box testi ng technique that consists of re -executing those tests that are \nimpacted by the code changes. These tests should be executed as often as possible throughout \nthe software development life cycle.  \nTypes of Regression Tests:  \n\uf0b7 Final Regression Tests: - A \"final regression testing\" is performed to validate the build \nthat hasn't changed for a period of time. This build is deployed or shipped to customers.  \n\uf0b7 Regression Tests: - A normal regression testing is performed to verify if the build has \nNOT broken any other pa rts of the application by the recent code changes for defect \nfixing or for enhancement.  \nSelecting Regression Tests:  \n\uf0b7 Requires knowledge about the system and how it affects by the existing functionalities.  \n15\n2  \n \uf0b7 Tests are selected based on the area of frequent def ects. \n\uf0b7 Tests are selected to include the area, which has undergone code changes many a times.  \n\uf0b7 Tests are selected based on the criticality of the features.  \nRegression Testing Steps:  \nRegression tests are the ideal cases of automation which results in better  Return  On Investment \n(ROI).  \n\uf0b7 Select the Tests for Regression.  \n\uf0b7 Choose the apt tool and automate the Regression Tests  \n\uf0b7 Verify applications with Checkpoints  \n\uf0b7 Manage Regression Tests/update when required  \n\uf0b7 Schedule the tests  \n\uf0b7 Integrate with the builds  \n\uf0b7 Analyze the res ults \n \n \n8 i.What is cyclomatic complexity? How to compute cyclomatic complexity \nAPRIL/MAY -15, NOV/DEC 2017  \nCyclomatic complexity is a source code complexity measurement that is being correlated to a \nnumber of coding errors. It is calculated by developing a  Control Flow Graph of the code that \nmeasures the number of linearly -independent paths through a program module.", "mimetype": "text/plain", "start_char_idx": 249593, "end_char_idx": 254102, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c": {"__data__": {"id_": "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7f263947-7383-43a2-be22-39b99cb5a91f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c966e427d085c9a2caab447d5675748baa63e5df757c38341635322d8571ab91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1e029456-2349-4129-8f61-4067cd0657d6", "node_type": "1", "metadata": {}, "hash": "878584d299b1094bbb632c589b2f9ee52424e543a8a9c9a43f175ab748e6f376", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Tests are selected based on the criticality of the features.  \nRegression Testing Steps:  \nRegression tests are the ideal cases of automation which results in better  Return  On Investment \n(ROI).  \n\uf0b7 Select the Tests for Regression.  \n\uf0b7 Choose the apt tool and automate the Regression Tests  \n\uf0b7 Verify applications with Checkpoints  \n\uf0b7 Manage Regression Tests/update when required  \n\uf0b7 Schedule the tests  \n\uf0b7 Integrate with the builds  \n\uf0b7 Analyze the res ults \n \n \n8 i.What is cyclomatic complexity? How to compute cyclomatic complexity \nAPRIL/MAY -15, NOV/DEC 2017  \nCyclomatic complexity is a source code complexity measurement that is being correlated to a \nnumber of coding errors. It is calculated by developing a  Control Flow Graph of the code that \nmeasures the number of linearly -independent paths through a program module.  \nLower the Program's cyclomatic complexity, lower the risk to modify and easier to understand. \nIt can be represented using the below formula:  \nCyclomatic  complexity = E - N + 2*P  \nwhere , \n  E = number of edges in the flow graph . \n  N = number of nodes in the flow graph . \n  P = number of nodes that have exit points  \nExample :  \nIF A = 10 THEN  \n IF B > C THEN  \n   A = B \n ELSE  \n   A = C \n ENDIF  \nENDIF  \nPrint  A \nPrint B \nPrint  C \n15\n3  \n FlowGraph:  \n \nThe Cyclomatic complexity is calculated using the above control flow diagram that shows seven \nnodes(shapes) and eight edges (lines), hence the cyclomatic complexity is 8 - 7 + 2 = 3  \n \n9 Explain  integration  testing  in detail. MAY/JUN -13, APRIL/MAY \n2017, APRIL/MAY  2018  \nUpon completion of unit testing, the units or modules are to be integrated which give s raise to \nintegration testing. The purpose of integration testing is to verify the functional, performance, \nand reliability between the modules that are integrated.  \nIntegration Strategies:  \n15\n4  \n \uf0b7 Big-Bang Integration  \nBig Bang Integration Testing is an integratio n testing strategy wherein all units are linked at \nonce, resulting in a complete system. When this type of testing strategy is adopted, it is difficult \nto isolate any errors found, because attention is not paid to verifying the interfaces across \nindividual  units.  \nBig Bang Integration - WorkFlow Diagram  \nBig Bang Testing is represented by the following workflow diagram:  \n \nDisadvantage s of Big -Bang Testing  \n\uf0b7 Defects present at the interfaces of components are identified at very late stage as all \ncomponents are integrated in one shot.  \n\uf0b7 It is very difficult to isolate the defects found.  \n\uf0b7 There is high probability of missing some critical defe cts, which might pop up in the \nproduction environment.  \n\uf0b7 It is very difficult to cover all the cases for integration testing without missing even a \nsingle scenario.  \nTop Down Integration  \nTop-down integration testing is an integration testing technique used in  order to simulate the \nbehaviour of the lower -level modules that are not yet integrated. Stubs are the modules that act \nas temporary replacement for a called module and give the same output as that of the actual \nproduct.  \nThe replacement for the 'called' mo dules is known as 'Stubs' and is also used when the software \nneeds to interact with an external system.  \n15\n5  \n Stub - Flow Diagram:  \n \nThe above diag rams clearly states that Modules 1, 2 and 3 are available for integration, whereas, \nbelow modules are still under development that cannot be integrated at this point of time. Hence, \nStubs are used to test the modules. The order of Integration will be:  \n1,2 \n1,3 \n2,Stub 1 \n2,Stub 2 \n3,Stub 3 \n3,Stub 4 \nTesting Approach:  \n+ Firstly , the integration between the modules 1,2 and 3 \n+ Test the integration between the module  2 and stub 1,stub 2 \n+ Test the integration between the module  3 and stub 3,stub 4 \n \nBottom Up Integr ation  \nEach component at lower hierarchy is tested individually and then the components that rely upon \nthese components are tested.  \nBottom Up Integration - Flow Diagram  \n \nThe order of Integration by Bottom -down approach will be:  \n15\n6  \n 4,2 \n5,2 \n6,3 \n7,3 \n2,1 \n3,1 \nTesting Approach :  \n+ Firstly , Test 4,5,6,7 individually using  drivers .", "mimetype": "text/plain", "start_char_idx": 253267, "end_char_idx": 257447, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1e029456-2349-4129-8f61-4067cd0657d6": {"__data__": {"id_": "1e029456-2349-4129-8f61-4067cd0657d6", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "efd32fcda506be99f2dd1fe661b25171ad71dac6119c0082c1e8c0788b334422", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e", "node_type": "1", "metadata": {}, "hash": "28ddf2b3c8beaf5ff21cb472271b8b1a0354f16d7836752cbf63b66105403b05", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The order of Integration will be:  \n1,2 \n1,3 \n2,Stub 1 \n2,Stub 2 \n3,Stub 3 \n3,Stub 4 \nTesting Approach:  \n+ Firstly , the integration between the modules 1,2 and 3 \n+ Test the integration between the module  2 and stub 1,stub 2 \n+ Test the integration between the module  3 and stub 3,stub 4 \n \nBottom Up Integr ation  \nEach component at lower hierarchy is tested individually and then the components that rely upon \nthese components are tested.  \nBottom Up Integration - Flow Diagram  \n \nThe order of Integration by Bottom -down approach will be:  \n15\n6  \n 4,2 \n5,2 \n6,3 \n7,3 \n2,1 \n3,1 \nTesting Approach :  \n+ Firstly , Test 4,5,6,7 individually using  drivers . \n+ Test 2 such that it calls 4 and 5 separately . If an error o ccurs we know that the problem is in one \nof the modules . \n+ Test 1 such that it calls 3 and If an error occurs we know that the problem is in 3 or in  \nHybrid Integration  \nIntegration Testing is a phase in software testing in which standalone modules are comb ined and \ntested as a single entity. During that phase, the interface and the communication between each \none of those modules are tested. There are two popular approaches for Integration testing which \nis Top down Integration Testing and Bottom up Integratio n Testing.  \nIn Hybrid Integration Testing, we exploit the advantages of Top -down and Bottom -up \napproaches. As the name suggests, we make use of both the Integration techniques.  \n \nHybrid Integration Testing - Features  \n\uf0b7 It is viewed as three layers; viz - The Main Target Layer, a layer above the target layer \nand a layer below the target layer.  \n\uf0b7 Testing is mainly focussed for th e middle level target layer and is selected on the basis of \nsystem characteristics and the structure of the code.  \n\uf0b7 Hybrid Integration testing can be adopted if the customer wants to work on a working \nversion of the application as soon as possible aimed at p roducing a basic working \nsystem in the earlier stages of the development cycle.  \n \n \n10 What is black box testing? Explain the different types of black box testing \nstrategies with example? NOV/DEC 2016  \nBlack -box testing is a method of software testing that ex amines the functionality of an \napplication based on the specifications. It is also known as Specifications based testing. \nIndependent Testing Team usually performs this type of testing during the software testing life \n15\n7  \n cycle.  \nThis method of test can be appl ied to each and every level of software testing such as unit, \nintegration, system and acceptance testing.  \nBehavioural Testing Techniques:  \nThere are different techniques involved in Black Box testing.  \n\uf0b7 Equivalence Class  \nEquivalence Partitioning also called a s equivalence class partitioning. It is abbreviated as ECP. \nIt is a software testing technique that divides the input test data of the application under test into \neach partition at least once of equivalent data from which test cases can be derived.  \nAn adva ntage of this approach is it reduces the time required for performing testing of a \nsoftware due to less number of test cases.  \nExample:  \nThe Below example best describes the equivalence class Partitioning:  \nAssume  that the application accepts an integer in the range 100 to 999 \nValid  Equivalence  Class  partition : 100 to 999 inclusive . \nNon-valid Equivalence  Class  partitions : less than 100, more than 999, decimal  numbers and \nalphabets /non-numeric characters . \n \n\uf0b7 Boundary Value Analysis  \nBoundary value analysis is a ty pe of black box or specification based testing technique in which \ntests are performed using the boundary values.  \nExample:  \nAn exam has a pass boundary at 50 percent, merit at 75 percent and distinction at 85 percent. \nThe Valid Boundary values for this scena rio will be as follows:  \n49, 50 - for pass \n74, 75 - for merit  \n84, 85 - for distinction  \nBoundary values are validated against both the valid boundaries and invalid boundaries.  \nThe Invalid Boundary Cases for the above example can be given as follows:  \n0 - for lower limit boundary value  \n101 - for upper limit boundary value  \n \n\uf0b7 Domain Tests  \nDomain testing is a software testing technique in which selecting a small number of test cases \nfrom a nearly infinite group of test cases. For testing few applications, Domain sp ecific \nknowledge plays a very crucial role.", "mimetype": "text/plain", "start_char_idx": 256784, "end_char_idx": 261137, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e": {"__data__": {"id_": "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1e029456-2349-4129-8f61-4067cd0657d6", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "83f1d8353dfd3c7ecbe70e1fcd2191e0cab2ebbe569e4d1f7e7c87ad42f59ebc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0c1df18c-5d92-4290-8cfe-480f9066a379", "node_type": "1", "metadata": {}, "hash": "695819f25c3983ebad54caa4746424ce07ac4b63eb4ad827c8452beceb3bccf6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Boundary Value Analysis  \nBoundary value analysis is a ty pe of black box or specification based testing technique in which \ntests are performed using the boundary values.  \nExample:  \nAn exam has a pass boundary at 50 percent, merit at 75 percent and distinction at 85 percent. \nThe Valid Boundary values for this scena rio will be as follows:  \n49, 50 - for pass \n74, 75 - for merit  \n84, 85 - for distinction  \nBoundary values are validated against both the valid boundaries and invalid boundaries.  \nThe Invalid Boundary Cases for the above example can be given as follows:  \n0 - for lower limit boundary value  \n101 - for upper limit boundary value  \n \n\uf0b7 Domain Tests  \nDomain testing is a software testing technique in which selecting a small number of test cases \nfrom a nearly infinite group of test cases. For testing few applications, Domain sp ecific \nknowledge plays a very crucial role.  \nDomain testing is a type of functional testing and tests the application by feeding interesting \n15\n8  \n inputs and evaluating its outputs.  \nDomain - Equivalence Class Testing  \nEquivalence class carries its own significance  when performing domain testing. Different ways \nof equivalence class are:  \n\uf0d8 Intuitive equivalence  \n\uf0d8 Specified equivalence  \n\uf0d8 Subjective equivalence  \n\uf0d8 Risk-based equivalence:  \n \n \n\uf0b7 Orthogonal Arrays  \nOrthogonal array testing is a systematic and statistical way of a black  box testing technique used \nwhen number of inputs to the application under test is small but too complex for an exhaustive \ntesting.  \nOrthogonal Array Testing Characteristics:  \n\uf0b7 OAT, is a systematic and statistical approach to pairwise interactions.  \n\uf0b7 Executing a well -defined and a precise test is likely to uncover most of the defects.  \n\uf0b7 100% Orthogonal Array Testing implies 100% pairwise testing.  \nExample:  \nIf we have 3 parameters , each can have 3 values then the possible Number  of tests using  \nconventional method is 3^3 = 27 \nWhile  the same using  OAT , it boils down to 9 test cases . \n \n\uf0b7 Decision Tables  \n \n\uf0b7 State Models  \n\uf0b7 Exploratory Testing  \n\uf0b7 All-pairs testing  \n \n15\n9  \n 11 1. (a) Consider the pseudo code for simple subtraction given below: \nNOV/DEC 2016, APRIL/MAY  2018  \n(1) program \u2018simple  subtr action\u2019  \n(2) input  (x,y)  \n(3) output  (x) \n(4) output  (y) \n(5) if x> y then  DO \n(6) x-y = z  \n(7) else y \u2013x = z \n(8) endif  \n(9) output  (z) \n(10) output \u201cend program\u201d  \nPerform basis path testing and generate test cases.  \n(b) What is refactoring? When is it needed? Explain with ex?  \nRefer class notes.  \n12 Explain in detail about system testing  \nSystem Testing is the testing of a complete and fully integrated software product. Usually, \nsoftware is only one element of a larger computer -based system. Ultimately, software is \ninterfaced with other software/hardware  systems. System Testing is actually a series of different \ntests whose sole purpose is to exercise the full computer -based system.  \nTwo Category of Software Testing  \n\uf0b7 Black Box Testing  \n\uf0b7 White Box Testing  \nSystem test falls under the  black box testing  category o f software testing.  \nWhite box testing  is the testing of the internal workings or code of a software application. In \ncontrast, black box or System Testing is the opposite. System test involves the external workings \nof the software from the user's perspectiv e. \n \n  \n13 Explain about the software testing strategies  \nSoftware testing  is an investigation conducted to provide stakeholders with information about \nthe quality  of the  software  product or service under test.[1] Software testing can also provide an \n16\n0  \n objective, independe nt view of the software to allow the business to appreciate and understand \nthe risks of software implementation. Test techniques include the process of executing a program \nor application with the intent of finding  software bugs  (errors or other defects), and verifying that \nthe software product is fit for use.  \nSoftware testing involves the execution of a software component or system component to \nevaluate one or more properties of in terest.", "mimetype": "text/plain", "start_char_idx": 260236, "end_char_idx": 264340, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0c1df18c-5d92-4290-8cfe-480f9066a379": {"__data__": {"id_": "0c1df18c-5d92-4290-8cfe-480f9066a379", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c11299f4a45f5c7c8ed529211e3b84ff301c5c5e11297e7a3ad1280a1bfd9c59", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6f61084d-df44-4d97-8ff7-2105e6b1e8d2", "node_type": "1", "metadata": {}, "hash": "21761043407f21c3c9a625bff27ff2e4aad6bbe20d862311996c1ac31b7be1c9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "White box testing  is the testing of the internal workings or code of a software application. In \ncontrast, black box or System Testing is the opposite. System test involves the external workings \nof the software from the user's perspectiv e. \n \n  \n13 Explain about the software testing strategies  \nSoftware testing  is an investigation conducted to provide stakeholders with information about \nthe quality  of the  software  product or service under test.[1] Software testing can also provide an \n16\n0  \n objective, independe nt view of the software to allow the business to appreciate and understand \nthe risks of software implementation. Test techniques include the process of executing a program \nor application with the intent of finding  software bugs  (errors or other defects), and verifying that \nthe software product is fit for use.  \nSoftware testing involves the execution of a software component or system component to \nevaluate one or more properties of in terest. In general, these properties indicate the extent to \nwhich the component or system under test:  \n\uf0b7 meets the requirements that guided its design and development,  \n\uf0b7 responds correctly to all kinds of inputs,  \n\uf0b7 performs its functions within an acceptable time , \n\uf0b7 it is sufficiently usable,  \n\uf0b7 can be installed and run in its intended  environments , and  \n\uf0b7 achieves the general result its stakeholders desire.  \nAs the number of pos sible tests for even simple software components is practically infinite, all \nsoftware testing uses some strategy to select tests that are feasible for the available time and \nresources. As a result, software testing typically (but not exclusively) attempts to execute a \nprogram or application with the intent of finding  software bugs  (errors or other defects). The job \nof testing is an iterative process as when one bug is fixed, it can  illuminate other, deeper bugs, or \ncan even create new ones.  \nSoftware testing can provide objective, independent information about the quality of software and \nrisk of its failure to users or sponsors.[1] \nSoftware testing can be conducted as soon as executable software (even if partially complete) \nexists. The  overal l approach to software development  often determines when and how testing is \nconducted. For example, in a phased process, most testing occurs after system requirements have \nbeen defined and then implemented in testable programs. In contrast, under an  agile approach , \nrequirements, programming, and testing are often done concurrently.  \n \n14 Discuss in detail about test strategies for conventional \nsoftware(M ay/June 2011)  \nRefer class notes  \n15 Explain in detail about basic path testing.(May/Jun 2014)  \nPath Testing is a structural testing method based on the source code or algorithm and NOT based \non the specifications. It can be applied at different levels of gr anularity.  \nPath Testing Assumptions:  \n\uf0b7 The Specifications are Accurate  \n\uf0b7 The Data is defined and accessed properly  \n\uf0b7 There are no defects that exist in the system other than those that affect control flow  \nPath Testing Techniques:  \n\uf0b7 Control Flow Graph (CFG) - The P rogram is converted into Flow graphs by \nrepresenting the code into nodes, regions and edges.  \n\uf0b7 Decision to Decision path (D -D) - The CFG can be broken into various Decision to \nDecision paths and then collapsed into individual nodes.  \n16\n1  \n \uf0b7 Independent (basis) paths  - Independent path is a path through a DD -path graph which \ncannot be reproduced from other paths by other methods.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nUNIT \u2013 5 \nPART \u2013A \n \n \nS.NO  QUESTIONS  \n1 What are the processes of risk management ? NOV/DEC -10, NOV/DEC - 12,\n NOV/DEC  2013,NOV/DEC2015  \nRisk identification  \nRisk projection (estimation)  \nRisk mitigation, monitoring, and management  \n2 State the need for software configuration review. NOV/DEC -11 \nThe intent  of the review is to ensure that all elements of the software \nconfiguration  \nhave been properly developed, cataloged & have necessary detail to bolster \nthe \nsupportpfase of the software lifecycle.  \n16\n2  \n 3 List any five CASE tools classified by function in the tax onomy of CASE tools \nNOV/DEC -11 \n1. project planning  tools  \n2. metrics & management  tools  \n 3. prototyping  tools  \n4. Re- engineering  tools  \n5. documentation  tools.  \n4 Define error, fault and failure. NOV/DEC -10 \nError \u2013 it is a state that can lead to a system behavior that is unexpected by \nthe \nSystem user.  \nFault - it is a characteristic of a software system that can lead to system error.", "mimetype": "text/plain", "start_char_idx": 263361, "end_char_idx": 267937, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6f61084d-df44-4d97-8ff7-2105e6b1e8d2": {"__data__": {"id_": "6f61084d-df44-4d97-8ff7-2105e6b1e8d2", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0c1df18c-5d92-4290-8cfe-480f9066a379", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e1f209c684b25796bbd2b899490499676673fa27c263cb26c2033a1675828cbc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8850614d-dd1b-4beb-8219-adf93321ba24", "node_type": "1", "metadata": {}, "hash": "43472dd9c3898ab17a8d0832d229431616fb02295710027cb41adf47379179dd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "NOV/DEC -11 \nThe intent  of the review is to ensure that all elements of the software \nconfiguration  \nhave been properly developed, cataloged & have necessary detail to bolster \nthe \nsupportpfase of the software lifecycle.  \n16\n2  \n 3 List any five CASE tools classified by function in the tax onomy of CASE tools \nNOV/DEC -11 \n1. project planning  tools  \n2. metrics & management  tools  \n 3. prototyping  tools  \n4. Re- engineering  tools  \n5. documentation  tools.  \n4 Define error, fault and failure. NOV/DEC -10 \nError \u2013 it is a state that can lead to a system behavior that is unexpected by \nthe \nSystem user.  \nFault - it is a characteristic of a software system that can lead to system error.  \nFailure \u2013 it is an event that occurs at some point in time when the system \ndoes not  \nDeliver a service as per user\u2019s expectation.  \n5 What is pro ject planning? APR/MAY -12, APR/MAY -15 \nThe various types of plan is developed to support main software project plan \nwhich is concerned with schedule & budget. Types of project plan  \nQuality plan, Validation plan, Configuration mgmt plan, Maintenance  \nplan, St aff development plan.  \n6 List the various types of software errors? APR/MAY -11, NOV/DEC -12 \nReports detailing bugs in a program are commonly known as bug reports, \ndefect reports, fault reports, problem reports, trouble reports, change requests.  \n16\n3  \n 7 Different iate between  size oriented  and function  oriented  metrics? \nMAY/JUN -13 MAY/JUNE 2016,NOV/DEC  2015  \nSize oriented metrics \u2013 it considers the size of the software that has been \nproduced. The software organization maintains simple records in tabular form. \nTable entries are LOC, effort, defects, and project name. Function oriented \nmetrics \u2013 it measures the functionality delivered by software. Function point \nbased on software information domain  and \nComplexity.  \n8 Define measure.(APRIL/MAY -2008)  \n Measure is defined  as a quantitative indication of the extent,  \namount, dimension, or size of some attribute of a product or process.  \n9 How is productivity and cost related to function points?  NOV/DEC2016  \n \nSoftware Productivity = Function Points / Inputs (persons/mnth) Cost  = $ / \nFunction Points (FP)  \n10 What are the types of metrics? MAY/JUNE 2016  \nDirect metrics \u2013 It refers to immediately measurable attributes. Example  \n\u2013 Lines of code,execution speed.  \nIndirect metrics \u2013 It refers to the aspects that are not immediately quan tifiable or \nmeasurable.  \nExample \u2013 functionality of a program.  \n16\n4  \n 11 What are the advantages and disadvantages of size measure? Advantages:  \n\uf0b7 Artifact of software development which is easily counted.  \n\uf0b7 Many existing methods use LOC as a key  input.  \n\uf0b7 A large body of  literature and data based on LOC already  exists  \nDisadvantages:  \nThis method is dependent upon the programming language.  \n\uf0a7 This method is well designed but shorter program may get  suffered.  \n\uf0a7 It does not accommodate non procedural  languages.  \n\uf0a7 In early stage of d evelopment it is difficult to estimate LOC.  \n12 Write short note on the various estimation techniques.  \nAlgorithmic cost modeling \u2013 the cost estimation is based on the size of the \nsoftware.  \nExpert judgement  \u2013 The experts  from software  development  \nand  the   application domain  use  their  exoerience  to  predict  software  \n costs.  \nEstimation by analogy \u2013 The cost of a project is computed by comparing \nthe project to a similar project in the same application domain and then cost can be \ncomputed.  \nParkinson\u2019s law \u2013 The cost is determined by available resources rather \nthan by objective assessment.  \nPricing to win \u2013 The project costs whatever the customer ready to  \nspend it.  \n13 What is COCOMO model?  \nCOnstructiveCOstMOdel is a cost model, which gives the estimate of number of \nman- months it will take to develop the software product.  \n16\n5  \n 14 Give the procedure of the Delphi method.  \n1. The co -ordinator presents a specification and estimation form to each  expert.  \n2. Co-ordinator calls a group meeting in which the experts discuss e stimation \nissues with the coordinator and each  other.  \n3. Experts fill out forms  anonymously.  \n4. Co-ordinator prepares and distributes a summary of the estimates.  \n5.", "mimetype": "text/plain", "start_char_idx": 267236, "end_char_idx": 271488, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8850614d-dd1b-4beb-8219-adf93321ba24": {"__data__": {"id_": "8850614d-dd1b-4beb-8219-adf93321ba24", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6f61084d-df44-4d97-8ff7-2105e6b1e8d2", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ed7460a1470b3dd0b4f73fce5b21ded18ea69c758c58f773395b27402982c804", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb", "node_type": "1", "metadata": {}, "hash": "dcdb6e5a34cb5906309ec0c8a1cc30c307c88620f51ba1305a811c3a56e84e4e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Parkinson\u2019s law \u2013 The cost is determined by available resources rather \nthan by objective assessment.  \nPricing to win \u2013 The project costs whatever the customer ready to  \nspend it.  \n13 What is COCOMO model?  \nCOnstructiveCOstMOdel is a cost model, which gives the estimate of number of \nman- months it will take to develop the software product.  \n16\n5  \n 14 Give the procedure of the Delphi method.  \n1. The co -ordinator presents a specification and estimation form to each  expert.  \n2. Co-ordinator calls a group meeting in which the experts discuss e stimation \nissues with the coordinator and each  other.  \n3. Experts fill out forms  anonymously.  \n4. Co-ordinator prepares and distributes a summary of the estimates.  \n5. The Co -ordinator then calls a group meeting.In this meeting the experts mainly \ndiscuss the points wh ere their estimates vary  widely.  \n6. The experts again fill out forms  anonymously.  \n7. Again co -ordinator edits and summarizes the forms,repeating steps5 and  6 until \nthe co-ordinator  is satisfied  with the overallprediction  synthesized  \nfrom experts.  \n15 What are th e metrics computed during error tracking activity?  \nErrors per requirement specification page. Errors per \ncomponent -design level  \nErrors per component -code level DRE -\nrequirement analysis  \nDRE -architectural analysis  \nDRE -component level design  \n DRE -coding.  \n16 What is risk management? NOV/DEC2016  \nRisk   management is   the   identification,   assessment,   and   prioritization of risks \nfollowed by coordinated and economical application of resources to minimize,  monitor, \nand control the probability and/or impact of unfortunate eventsor to maximize the \nrealization of opportunities. Risk management\u2019s objective is to assure uncertainty does \nnot deflect the en deavor from  the \nbusiness goals.  \n17 What is software maintenance?  \nSoftware maintenance is an activity in which program is modified after it has been put \ninto use.  \n16\n6  \n 18 Will exhaustive testing guarantee that the program is 100% correct? APR/MAY \n2016  \nNo,    e ven    exhaustive    testing    will    not    guarantee     that     the program    is    \n100   percent    correct.    There    are    too    many variables to consider.  \n19 What are the types of software maintenance?  \n\uf0b7 Corrective maintenance \u2013 Means the ma intenance for correcting the \nsoftware  faults.  \n\uf0b7 Adaptive maintenance \u2013 Means maintenance for adapting the change in \nenvironment.  \n\uf0b7 Perfective maintenance \u2013 Means modifying or enhancing the system to \nmeet the new  requirements.  \n\uf0b7 Preventive maintenance \u2013 Means cha nges made to  improve  \nfuture maintainability  \n20 How the CASE tools are classified?  \nCASE tools can be classified  by \na. By function or  use \nb. By user type(e.g.  manager,tester),or  \nc. By stage in software engineering process  (e.g.requirements,test).  \n21 Dinguish betwee n direct & indirect measures of metrics.  \nDirect metrics is directly measurable attribute(lines of code execution speed,size \nof memory.  \nIndirect metrics: these are the aspects that are not immediately  \nmeasurable.(functionality,reliabblity,maintainability)  \n22 List down few process and product metrics.  MAY/JUNE 2016  \n1. size metrics -It is used for measuring the size of the software.(local based \nmetric,FP based  metric)  \n2. complexity metric - A software module can be described by a control flow \ngraph.(cyclomatic comple xity, McCabe  complexity)  \n3. quality metric - (Defects,reliabilitymetric,Maintainability)  \n16\n7  \n 23 Define software measure.  \nIt is a numeric value for a attribute of a software product or process.  \nTypes:  \n1.Direct measure 2.indirect measure  \n24 List out the different approaches to size of the software . \n1. LOC -computing the line of code  \n2. FP-computing function point of the  program.  \n25 An organic software occupies 15000 LOC.how many programmers are needed to \ncomplete?(NOV/DEC -12) \nSystem=organic Lines of \ncoding=15k LOC  \nE=a b(KLOC)b b \n=2.4(15)1.05 \n=41 persons per month D=c b(e)d b \n=2.5(41)0.38 \n=10 months P=41/10  \nP=4 persons.  \n 4 persons are needed.  \n26 What is error tracking?", "mimetype": "text/plain", "start_char_idx": 270758, "end_char_idx": 274899, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb": {"__data__": {"id_": "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8850614d-dd1b-4beb-8219-adf93321ba24", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ffac73dcedf8f8ee1c16569921dea0662ddfdce45dacc642e155d5d96de30c34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "787699e2-a516-424a-89d0-03763cc2c216", "node_type": "1", "metadata": {}, "hash": "fc017da5e0d10280ebccee61d932999288ca45d66a287bffe3935bcf3da93934", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is a numeric value for a attribute of a software product or process.  \nTypes:  \n1.Direct measure 2.indirect measure  \n24 List out the different approaches to size of the software . \n1. LOC -computing the line of code  \n2. FP-computing function point of the  program.  \n25 An organic software occupies 15000 LOC.how many programmers are needed to \ncomplete?(NOV/DEC -12) \nSystem=organic Lines of \ncoding=15k LOC  \nE=a b(KLOC)b b \n=2.4(15)1.05 \n=41 persons per month D=c b(e)d b \n=2.5(41)0.38 \n=10 months P=41/10  \nP=4 persons.  \n 4 persons are needed.  \n26 What is error tracking?(APRIL/MAY -14) \nIt is a process of finding out and correcting the errors that may occur \nduring the software d evelopment process at various stages such as software design,coding \nor documenting.  \n16\n8  \n 27 What are the types of static testing tools?  \nThere are three types of static testing tools.  \n\uf0b7 Code based testing tools \u2013 These tools take source code as input and generate  test \ncases.  \n\uf0b7 Specialized testing tools \u2013 Using this language the detailed test specification can \nbe written for each test  case.  \n\uf0b7 Requirement -based testing tools \u2013 These tools help in designing the test cases as \nper user \nrequirements.  \n28 What are the produc tivity measures and list its type. APRIL/MAY 2017  \nProductivity is an overall measure of the ability to produce a good or service. \nMore specifically, productivity is the measure of how specified resources are managed to \naccomplish timely objectives as state d in terms of quantity and quality. Productivity may \nalso be defined as an index that measures output (goods and services) relative to the input \n(labor, materials, energy, etc., used to produce the output). there are two major ways to \nincrease productivity : increase the numerator (output) or decrease the denominator  \n(input).  \n29 Define ZIPF\u2019s law.  \nThe probability of occurrence of words or other items starts high and tapers off. \nThus, a few occur very often while many others occur rarely. Formal  Definition:  Pn ~ \n1/na,  where  Pn is the frequency  of occurrence  of the \nnth ranked item and a is close to 1.  \n30 List out the principles of project scheduling. NOV/DEC2017  \n \nSoftware project scheduling is an activity that distributes estimated effort  \n16\n9  \n  across the planed project duration by allocating the effort to specific software engineering \ntasks.  \n \nFirst, a macroscopic schedule is developed. a detailed schedule is redefined for each entry \nin the macroscopic schedule.  \n \nA schedule evolves over time.  \n \nBasic principles gui de software project scheduling:  \n \n- Compartmentalization  \n \n- Interdependency  \n \n- Time  allocation  \n \n- Effort  allocation  \n \n- Effort  validation  \n \n- Defined  responsibilities  \n \n- Defined  outcomes  \n \n- Defined  milestones  \n31 Write a note on Risk information sheet. NOV/DEC 2017  \n \nA risk i nformation sheet is a means of capturing information about a risk. Risk \ninformation sheets are used to document new risks as they are identified. They are also \nused to modify information as risks are managed. It is a form that can be submitted to the \nappro priate person or included in a database with other project risks. In the absence of a \ndatabase, this becomes a primary means of  \ndocumenting and retaining information about a risk.  \n32 List two customer related and technology related risks. APRIL/MAY 2017  \n17\n0  \n  customer related risks  \n \n\uf0b7 Customer relationship management may be  fragmented.  \n\uf0b7 New methods with which to improve customer service and reduce  related costs are \nnot utilized.  \n\uf0b7 Lack of knowledge on the part of one section of an enterprise  regarding \ninteractions with a customer on the part of another can lead to customer frustration \nand embarrassment.  \n\uf0b7 Inability to respond to market demands caused by lack of integration  among order -\nentry systems or, even worse, due to  infrastructure.  \n\uf0b7 Lack of visibility of the order  status along the whole supply  chain.  \n \nTechnology related risk :  \n \n\uf0b7 Architecture risk \n\uf0b7 Artificial intelligence  risk \n\uf0b7 Audit  risk \n\uf0b7 Availability  \n33 What is EVA ?", "mimetype": "text/plain", "start_char_idx": 274317, "end_char_idx": 278439, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "787699e2-a516-424a-89d0-03763cc2c216": {"__data__": {"id_": "787699e2-a516-424a-89d0-03763cc2c216", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "30b02c904d596e47abe590a12cb8f31da325de8874d8b3006cde793dd657c7d3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8cd4e341-8b13-46d8-bed4-6a984d0cb372", "node_type": "1", "metadata": {}, "hash": "ad0b5e51b7924fc24ce411de98ef5a233bbc911ef7e52e2352f213b72a8bd561", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "32 List two customer related and technology related risks. APRIL/MAY 2017  \n17\n0  \n  customer related risks  \n \n\uf0b7 Customer relationship management may be  fragmented.  \n\uf0b7 New methods with which to improve customer service and reduce  related costs are \nnot utilized.  \n\uf0b7 Lack of knowledge on the part of one section of an enterprise  regarding \ninteractions with a customer on the part of another can lead to customer frustration \nand embarrassment.  \n\uf0b7 Inability to respond to market demands caused by lack of integration  among order -\nentry systems or, even worse, due to  infrastructure.  \n\uf0b7 Lack of visibility of the order  status along the whole supply  chain.  \n \nTechnology related risk :  \n \n\uf0b7 Architecture risk \n\uf0b7 Artificial intelligence  risk \n\uf0b7 Audit  risk \n\uf0b7 Availability  \n33 What is EVA ? APRIL/MAY 2018  \n \nEarned Value Analysis ( EVA ) is an industry standard method of measuring a project's \nprogress at any given point in time, forecasting its completion date and final cost, and \nanalyzing variances in the schedule  \nand budget as the project proceeds.  \n34 Identify The Types Of Maintenance for each of the following APRIL/MAY  2018  \n \nCorrecting the So ftware Faults . Adapting the \nchange in environment  \nThere are four types of maintenance , namely, corrective , adaptive, perfective, and \npreventive . ... \nCorrectivemaintenance dealswiththe repair of faults or defects found in day -today \nsystem functions. ...  \nIn the event of a system failure due to an error, actions are taken to restore the \noperation of the software  system.  \n17\n1  \n 35 \nWhat is cost schedule?  \n \nCost schedule shows the planned cumulative expenditure cost by the use of resource \novertime  \n36 \nWhat is RMMM?  \nAns. RMMM stands for Risk Mitigation, Monitoring and Management Plan. It is also \ncalled Risk Aversion.  \n37 \nWhat Is Risk mitigation?  \nAns. Mitigation is a possible means if minimizing or even avoiding the Impact of risk.  \n38 \nWhat are the factors that lead to Ri sk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n39 \nWhat are the test points?  \n \nTest points allow data to be inspected or modified at various points in the system  \n40 \nWhat is refactoring?  \n \nA small chang e to a database schema which improves its design  \n41 \nExplain the common risk tools and techniques.  \n \nAns. There are at least six different ways of identifying the potential risks.  \nThese are:  \n17\n2  \n  \n\u2022 Examining organizational  history  \n \n\u2022 Preparing  checklists  \n \n\u2022 Informat ion buying  \n \n\u2022 Framework based risk  categorization  \n \n\u2022 Simulation  \n \n\u2022 Decision  trees.  \n42 \nWhat is called support risk?  \nAns. Support risk is the degree of uncertainty fiat the resultant software will be easy to \ncorrect, adapt and enhance  \n43 \nWhat Is Risk?  \n \nAns. Risks are events that are usually beyond the planner\u2019s control.  \n44 \nWhat are the Dimensions of Risk quantification? Ans. \nProbability and the impact of Risk.  \n45 \nWhat is meant by Delphi method?  \nThe Delphi technique is an estimation technique intended to active a common agreement \nfor estimation efforts.  \n46 \nWhat is meant by CASE tools?  \n \nThe computer aided software engineering tools automatic the project  \n17\n3  \n  management activities, manage all the work products. The CASE tools assist to \nperform various activities such  as analysis, design, coding and  \ntesting.  \n47 \nWhat are the three phases of Risk management? Ans. The \nthree phases of risk management are:  \nRisk identification, Risk Quantification, and Risk mitigation.  \n48 \nWhat are the factors that lead to Risk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n49 \nWhat is meant by software project scheduling?  \nSoftware project scheduling is an activity that distributes estimated effort across the \nplanned project duration by al locating the effort to specified software engineering \ntasks.  \n50 \nWhat are the various steps under risk analysis? Ans. The \nvarious steps under risk analysis are:  \n\uf0b7 Risk Estimation.  \n \n\uf0b7 Risk identification.  \n \n\uf0b7 Risk evaluation.  \n17\n4  \n   \n \nPART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 (f) Elaborate on the series of tasks of a software configuration management  \nprocess.", "mimetype": "text/plain", "start_char_idx": 277636, "end_char_idx": 281932, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8cd4e341-8b13-46d8-bed4-6a984d0cb372": {"__data__": {"id_": "8cd4e341-8b13-46d8-bed4-6a984d0cb372", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "787699e2-a516-424a-89d0-03763cc2c216", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "3ec7c912bda7dacb6b90a101fa7316df83e230eedeaa79fda62759ace6deadda", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "835f4d37-14db-4be5-bcf9-34bd76c0663d", "node_type": "1", "metadata": {}, "hash": "7abc39c705e4738930bbbc12227b71fa25ee96ca84a8125f075b08b1f59bb096", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The \nthree phases of risk management are:  \nRisk identification, Risk Quantification, and Risk mitigation.  \n48 \nWhat are the factors that lead to Risk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n49 \nWhat is meant by software project scheduling?  \nSoftware project scheduling is an activity that distributes estimated effort across the \nplanned project duration by al locating the effort to specified software engineering \ntasks.  \n50 \nWhat are the various steps under risk analysis? Ans. The \nvarious steps under risk analysis are:  \n\uf0b7 Risk Estimation.  \n \n\uf0b7 Risk identification.  \n \n\uf0b7 Risk evaluation.  \n17\n4  \n   \n \nPART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 (f) Elaborate on the series of tasks of a software configuration management  \nprocess.  \n(g) Describe  function  point  analysis  with  a neat \nexample NOV/DEC 2013  \nSoftware configuration management, SCM is an activity which is used at every level and \nevery part of the process of software Engineering. Every improvement takes the shape of \nbetter control. This is a discipline which controls betters and according to client need in \nsoftware Engineering. With the help of this many types are changes which play an important \nrole in sof tware Engineering and development process.  \nIn the simple way if we define the term configuration of management, this is the tool which \nmakes better control, easy maintenance during the whole process of software development. \nWith the help of software config uration management we can easily find out what \nmodification and controlling required by the developer. SCM have the capacity to control all \nthose effects which comes in software projects. The main objectives of SCM is increase the \nproduction by reduce the errors.  \nWhen a software development process start then SCM take change by identification, control, \nalteration, audit and etc. after that the output of total process provided to our customer. We \ncan clarify the action of SCM as:  \n1. Software configuration ident ification  - Normally software is used in various kinds \nof programs and documentation and data related to each program is called \nconfiguration identification. With the help of C.I we can make a guide line which \nwill be helpful in software development proces s, several time the requirement of \nguideline for check the document and design of software. Document related to SCM \nare the useful item, with the help of this we can make better control and take a basic \nunit for configuration.  \n2. Software configuration contro l - This is the process of deciding with the help of \nthis we make coordination between the changes which is necessary and apply them \nas per mentioned in guideline. Configuration control board gives the permission for \nany kind of change or modification whic h is necessary for the project. Many times \nCCB take advice of those members which are the part of software development \nprocess.  \n3. Accounting status of Software configuration  - The process of maintaining record \nof all data which is necessary for the software is called accounting status of \nsoftware. It has all the data related to the old software to new software that what \nchanges are done or required for the fulfillment of the customer need.  \n17\n5  \n 4. Auditing of software configuration  - Auditing of software configuratio n is may be \ndefined as an art with the help of this we can understand that the required actions or \nchanges are done by the developer or not. Some of the item involved in the process \nof verifying or auditing.  \no Function is properly performed by the software.  \no The process of documentation, data is completed or not.  \nBenefits  \no With the help of SCM we can easily control all changes which are done in \ndevelopment process.  \no It gives the surety to check that changes are done on required area.  \no It is helpful to generate th e new software with old components.  \no SCM has the capacity to explain everything about the process of software \ndevelopment.  \n \n2 Explain make/buy decision & discuss Putnam resource allocation model & \nderive time & effort equation? APRIL/MAY2016  \nThe Lawrence Pu tnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n6  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution.", "mimetype": "text/plain", "start_char_idx": 281114, "end_char_idx": 285641, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "835f4d37-14db-4be5-bcf9-34bd76c0663d": {"__data__": {"id_": "835f4d37-14db-4be5-bcf9-34bd76c0663d", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8cd4e341-8b13-46d8-bed4-6a984d0cb372", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "8901444bd52f702b303800a4693ba434172c1c15afdbb32115f0f3bcd40cd4ee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8", "node_type": "1", "metadata": {}, "hash": "b6714ccbf2e2f415a72745c559038e5d382be6fe01bb3f063cdae32abb71c57e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "o The process of documentation, data is completed or not.  \nBenefits  \no With the help of SCM we can easily control all changes which are done in \ndevelopment process.  \no It gives the surety to check that changes are done on required area.  \no It is helpful to generate th e new software with old components.  \no SCM has the capacity to explain everything about the process of software \ndevelopment.  \n \n2 Explain make/buy decision & discuss Putnam resource allocation model & \nderive time & effort equation? APRIL/MAY2016  \nThe Lawrence Pu tnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n6  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution. \nPutnam used his observation about productivi ty levels to derive the software equation:  \n \nThe various terms of this expression are as follows:  \nThe Lawrence Putnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n7  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution. \nPutnam used his observation about producti vity levels to derive the software equation:  \n \nThe various terms of this expression are as follows:  \nK is the to tal effort expended (in PM) in product development, and L is the product estimate \nin KLOC  . \ntd correlate to the time of system and integration testing. Therefore,  td can be relatively \nconsidered as the time required for developing the product.  \nCk Is the st ate of technology constant and reflects requirements that impede the development \nof the program.  \nTypical values of  Ck = 2 for poor development environment  \n17\n8  \n Ck= 8 for good software development environment  \nCk = 11 for an excellent environment (in addition to following software engineering \nprinciples, automated tools and techniques are used).  \nThe exact value of  Ck for a specific task can be computed from the historical data of the \norganization developing it.  \nPutnam proposed that optimal staff develop on a proje ct should follow the Rayleigh curve. \nOnly a small number of engineers are required at the beginning of a plan to carry out planning \nand specification tasks. As the project progresses and more detailed work are necessary, the \nnumber of engineers reaches a p eak. After implementation and unit testing, the number of \nproject staff falls.  \nEffect of a Schedule change on Cost  \nPutnam derived the following expression:  \n \nWhere,  K is the total effort expended (in PM) in the product development  \nL is the product size in KLOC  \ntd corresponds to the time of system and integration testing  \nCk Is the state of technology constant and re flects constraints that impede the progress of the \nprogram  \nNow by using the above expression, it is obtained that,  \n \nFor the same product size, C =L3 / C k3 is a constant.  \n \n(As project development effort is equally proport ional to project development cost)  \nFrom the above expression, it can be easily observed that when the schedule of a project is \n17\n9  \n compressed, the required development effort as well as project development cost increases in \nproportion to the fourth power of th e degree of compression. It means that a relatively small \ncompression in delivery schedule can result in a substantial penalty of human effort as well as \ndevelopment cost.  \nFor example,  if the estimated development time is 1 year, then to develop the produc t in 6 \nmonths, the total effort required to develop the product (and hence the project cost) increases \n16 times.  \n \n \n3 Explain the various CASE tools for project management and how they are \nuseful in achieving the objectives  APRIL/MAY - 15 \nProject management  is one of the critical processes of any project. This is due to the fact that \nproject management is the core process that connects all other project activities and \nprocesses together.  \nWhen it comes to the activities of project management, there are plenty . However, these \nplenty of project management activities can be categorized into five main processes.  \nLet's have a look at the five main project management processes in detail.  \n1 - Project Initiation  \nProject initiation is the starting point of any project.  In this process, all the activities related \nto winning a project takes place. Usually, the main activity of this phase is the pre -sale.", "mimetype": "text/plain", "start_char_idx": 284762, "end_char_idx": 289436, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8": {"__data__": {"id_": "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "835f4d37-14db-4be5-bcf9-34bd76c0663d", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "978842d2215f7bababf1b93b575e0e0f717e377a4df32b93c8a02252284af4f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0e003cbb-0a63-4b33-962e-2ce986e02e32", "node_type": "1", "metadata": {}, "hash": "31e60ea76dcad8885dea6e42076206e4892ae5161aad3fcf175465ae337d7b9b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3 Explain the various CASE tools for project management and how they are \nuseful in achieving the objectives  APRIL/MAY - 15 \nProject management  is one of the critical processes of any project. This is due to the fact that \nproject management is the core process that connects all other project activities and \nprocesses together.  \nWhen it comes to the activities of project management, there are plenty . However, these \nplenty of project management activities can be categorized into five main processes.  \nLet's have a look at the five main project management processes in detail.  \n1 - Project Initiation  \nProject initiation is the starting point of any project.  In this process, all the activities related \nto winning a project takes place. Usually, the main activity of this phase is the pre -sale. \nDuring the pre -sale period, the service provider proves the eligibility and ability of \ncompleting the project to the cl ient and eventually wins the business. Then, it is the detailed \nrequirements gathering which comes next.  \nDuring the requirements gathering activity, all the client requirements are gathered and \nanalysed for implementation. In this activity, negotiations ma y take place to change certain \nrequirements or remove certain requirements altogether.  \nUsually, project initiation process ends with requirements sign -off. \n2 - Project Planning  \nProject planning is one of the main project management processes. If the projec t \nmanagement team gets this step wrong, there could be heavy negative consequences during \nthe next phases of the project.  \nTherefore, the project management team will have to pay detailed attention to this process of \nthe project.  \nIn this process, the projec t plan is derived in order to address the project requirements such \nas, requirements scope, budget and timelines. Once the project plan is derived, then the \nproject schedule is developed.  \nDepending on the budget and the schedule, the resources are then all ocated to the project. \nThis phase is the most important phase when it comes to project cost and effort.  \n18\n0  \n 3 - Project Execution  \nAfter all paperwork is done, in this phase, the project management executes the project in \norder to achieve project objectives.  \nWhen it comes to execution, each member of the team carries out their own assignments \nwithin the given deadline for each activity. The detailed project schedule will be used for \ntracking the project progress.  \nDuring the project execution, there are many repo rting activities to be done. The senior \nmanagement of the company will require daily or weekly status updates on the project \nprogress.  \nIn addition to that, the client may also want to track the progress of the project. During the \nproject execution, it is a  must to track the effort and cost of the project in order to determine \nwhether the project is progressing in the right direction or not.  \nIn addition to reporting, there are multiple deliveries to be made during the project \nexecution. Usually, project deli veries are not onetime deliveries made at the end of the \nproject. Instead, the deliveries are scattered through out the project execution period and \ndelivered upon agreed timelines.  \n4 - Control and Validation  \nDuring the project life cycle, the project acti vities should be thoroughly controlled and \nvalidated. The controlling can be mainly done by adhering to the initial protocols such as \nproject plan, quality assurance test plan and communication plan for the project.  \nSometimes, there can be instances that a re not covered by such protocols. In such cases, the \nproject manager should use adequate and necessary measurements in order to control such \nsituations.  \nValidation is a supporting activity that runs from first day to the last day of a project. Each \nand eve ry activity and delivery should have its own validation criteria in order to verify the \nsuccessful outcome or the successful completion.  \nWhen it comes to project deliveries and requirements, a separate team called 'quality \nassurance team' will assist the p roject team for validation and verification functions.  \n5 - Closeout and Evaluation  \nOnce all the project requirements are achieved, it is time to hand over the implemented \nsystem and closeout the project. If the project deliveries are in par with the accept ance \ncriteria defined by the client, the project will be duly accepted and paid by the customer.  \nOnce the project closeout takes place, it is time to evaluate the entire project. In this \nevaluation, the mistakes made by the project team will be identified and will take necessary \nsteps to avoid them in the future projects.  \nDuring the project evaluation process, the service provider may notice that they haven't \ngained the expected margins for the project and may have exceeded the timelines planned at \nthe begi nning.  \nIn such cases, the project is not a 100% success to the service provider.", "mimetype": "text/plain", "start_char_idx": 288628, "end_char_idx": 293579, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0e003cbb-0a63-4b33-962e-2ce986e02e32": {"__data__": {"id_": "0e003cbb-0a63-4b33-962e-2ce986e02e32", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5c30b645608ce7d926670a09bd0deecdab039bc5b07d250437d42980529f2e87", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8c135d63-f222-4db6-baaf-12f3a9e3c452", "node_type": "1", "metadata": {}, "hash": "1787a1a1401746cf30b5f98895ac13173cd7518a8a5681fb708e2266ab8c8543", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "5 - Closeout and Evaluation  \nOnce all the project requirements are achieved, it is time to hand over the implemented \nsystem and closeout the project. If the project deliveries are in par with the accept ance \ncriteria defined by the client, the project will be duly accepted and paid by the customer.  \nOnce the project closeout takes place, it is time to evaluate the entire project. In this \nevaluation, the mistakes made by the project team will be identified and will take necessary \nsteps to avoid them in the future projects.  \nDuring the project evaluation process, the service provider may notice that they haven't \ngained the expected margins for the project and may have exceeded the timelines planned at \nthe begi nning.  \nIn such cases, the project is not a 100% success to the service provider. Therefore, such \ninstances should be studied carefully and should take necessary actions to avoid in the \nfuture.  \n18\n1  \n Conclusion  \nProject management is a responsible process. The pro ject management process connects all \nother project activities together and creates the harmony in the project.  \nTherefore, the project management team should have a detailed understanding on all the \nproject management processes and the tools that they can m ake use for each project \nmanagement process.  \n \n4 Brief about calculating Earned value measures APR/MAY - \n12,APRIL/MAY 2018  \nEarned value analysis is the  project management  tool that is used to measure  project progress. \nIt compares the actual work completed at any time to the original budget and schedule. It \nforecasts the final budget and schedule and analyzes the path to get there. It gives you the \nessential  early warning signal  that things are going awry.  \nThere are two variables which the  earned value method  focuses on.  \n\uf0a7 Schedule (time)  \n\uf0a7 Cost \nThere are 8 steps to performing earned value analysis eff ectively.   It may seem like alot at \nfirst glance, but for small projects this takes five minutes once you learn how to do it:  \n1. Determine the percent complete of each task.  \n2. Determine Planned Value (PV).  \n3. Determine Earned Value (EV).  \n4. Obtain Actual Cost (AC).  \n5. Calculate Schedule Variance (SV).  \n6. Calculate Cost Variance (CV).  \n7. Calculate Other Status Indicators  (SPI, CPI, EAC, ETC, and TCPI)  \n8. Compile Results  \nThe first four steps represent an information gathering phase. The remaining steps are \ncalculations which give t he project manager a glimpse into the current status of the project \nfrom a  budget  and schedule  perspective.  \nBefore you get started, it is important to define appropriate project status points in which this \ncalculation is performed.   Weekly status meetings work very well  for any size project, but \nwhatever time frame is used the important thing is to make sure thes e calculations are \nperformed at that time.  \n18\n2  \n Determine Percent Complete  \nTo start the process, the percentage complete of each task needs to be determined.  \nSmall tasks (80 hours or less) are often best done on a 0, 50, or 100% complete basis (not \nstarted, in progress, or complete).   This brings the workload down to reasonable levels and \nprevents abuse when project team members exaggerate, for example they might tell you a \ntask is 80% complete when it is really 50% complete.  \nFor repetitive tasks you can also us e progressive measures such as number of fence posts \ninstalled.  \nDetermine Planned Value (PV)  \nPlanned Value , also known as  Budgeted Cost of Work Scheduled (BCWS) , is defined as the \namount of the task that is  supposed to  have been completed.   It is in monetary terms as a \nportion of the task budget.   For example let\u2019s say that:  \n\uf0a7 The task budget is $5,000,  \n\uf0a7 The task start date is January 1, and  \n\uf0a7 The task finish date is January 10.  \nIf it\u2019s January 6 today, the task is supposed to be 60% complete. Therefore,  PV = $5,000 x \n60% = $3,000 . \nDetermine Earned Value (EV)  \nEarned Value , also known as  Budgeted Cost of Work Performed (BCWP) , is the amount of \nthe task that is actually complete.   It is, again, in monetary terms as a portion of the task \nbudget.   For example, let\u2019s use the same example task.", "mimetype": "text/plain", "start_char_idx": 292770, "end_char_idx": 296967, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8c135d63-f222-4db6-baaf-12f3a9e3c452": {"__data__": {"id_": "8c135d63-f222-4db6-baaf-12f3a9e3c452", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0e003cbb-0a63-4b33-962e-2ce986e02e32", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ed0e0912ef20cffb7d368be17f10ab4319950ff385492cdd8b8a40152846aaa0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f", "node_type": "1", "metadata": {}, "hash": "0b47029e63947e51bf58526320b017ce6b1333b4d957c758b42b297cc1543090", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is in monetary terms as a \nportion of the task budget.   For example let\u2019s say that:  \n\uf0a7 The task budget is $5,000,  \n\uf0a7 The task start date is January 1, and  \n\uf0a7 The task finish date is January 10.  \nIf it\u2019s January 6 today, the task is supposed to be 60% complete. Therefore,  PV = $5,000 x \n60% = $3,000 . \nDetermine Earned Value (EV)  \nEarned Value , also known as  Budgeted Cost of Work Performed (BCWP) , is the amount of \nthe task that is actually complete.   It is, again, in monetary terms as a portion of the task \nbudget.   For example, let\u2019s use the same example task.  \n\uf0a7 The task budget is $5,000, (same as above)  \n\uf0a7 The task start date is January 1, and (same as above)  \n\uf0a7 The task finish date is January 10.   (same as ab ove) \nLet\u2019s say the actual percent complete of the task (step 1) is 40%. Therefore,  EV = $5,000 x \n40% = $2,000 . \nObtain Actual Cost (AC)  \nThe Actual Cost , also known as  Actual Cost of Work Performed (ACWP) , as you might \nguess, is the  actual cost  of the work.   Generally employee hours need to be converted into a \n18\n3  \n cost, and all project costs need to be added up, such as the following items:  \n\uf0a7 Labor  \n\uf0a7 Materials  \n\uf0a7 Equipment  \n\uf0a7 Fixed cost items, like subcontractors  \nSince most projects have these well defined via accounting or project management software, \nwe will not go into great detail here.   For the purposes of our example project let\u2019s say the \nactual cost of the example task is $1,500.  \nAt this point  the information gathering phase is complete. The following  calculations \nrepresent the application of the earned value analysis to keep your project on schedule and \nbudget.  \nCalculate Schedule Variance (SV)  \nThe Schedule Variance  represents the schedule status of the project.  \nSV = EV \u2013 PV \nIn our above example the schedule variance is:   SV = $2,000 \u2013 $3,000 = -$1,000 . \nA negative schedule variance means the task is behind sc hedule.   A positive schedule \nvariance means it is ahead of schedule.   The amount can be compared to worker charge out \nrates or similar metrics to get an idea of how difficult it would be to recover.  \nCalculate Cost Variance (CV)  \nThe Cost Variance  represents the cost status of the project.  \nCV = EV \u2013 AC \nIn our above  example  the cost variance is:   CV = $2,00 0 \u2013 $1,500 = $500 . \nA negative cost variance means the task is over budget.   A positive cost variance means it is \nunder budget.  \nCalculate Other Status Indicators  \nAlthough the SV and CV are the minimum requirement and work well for small projects, \nthere are other variables that are derived from them which you might want to calculate:  \n\uf0a7 Schedule Performance Index (SPI) :  The schedule variance expressed in percentage \n18\n4  \n terms, for example, SPI = 0.8 means the project 20% behind schedule.  \nSPI = EV / PV  \n\uf0a7 Cost Performance Index (CPI) : The cost variance expressed in percentage terms, \nfor example, CPI = 0.9 means the project is 10% over budget.  \nCPI = EV / AC  \n\uf0a7 Estimate at Completion (EAC) :  The expected budget at the end of the project \ngiven the va riances that have already taken place. There are various ways to extrapolate \nthis value but assuming that the past variances are likely to persist:  \nEAC = AC + BAC \u2013 EV \n\uf0a7 Estimate to Complete (ETC) :  The expected cost to finish the rest of the project.  \nETC = EAC \u2013 AC \n\uf0a7 To Complete Performance Index (TCPI) :  The required CPI necessary to finish the \nproject right on budget.   For example, TCPI = 1.25 means you need to find 25% \nefficiencies to finish on budget.  \nTCPI = (BAC \u2013 EV) / (BAC \u2013 AC) \nCompile the Results  \nEach metric is calculated for each individual task in the project. Therefore they need to be \nadded up into overall project variances to get the overall progress indicator for the project.   \nThis represents the  total variance  of the project and can be  reported  to management, clients, \nand stakeholders.", "mimetype": "text/plain", "start_char_idx": 296385, "end_char_idx": 300296, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f": {"__data__": {"id_": "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8c135d63-f222-4db6-baaf-12f3a9e3c452", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1451f29b153b2ef252e3b71b632c00ce4b5d974f462d14ac7bfb6528de64a2c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a5b6456b-9069-4290-af6b-5604ef801d32", "node_type": "1", "metadata": {}, "hash": "1b66aaf546791f1a7ddfa860875bf31fd53802a4dcc2a48814db18dcf47f04f7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "ETC = EAC \u2013 AC \n\uf0a7 To Complete Performance Index (TCPI) :  The required CPI necessary to finish the \nproject right on budget.   For example, TCPI = 1.25 means you need to find 25% \nefficiencies to finish on budget.  \nTCPI = (BAC \u2013 EV) / (BAC \u2013 AC) \nCompile the Results  \nEach metric is calculated for each individual task in the project. Therefore they need to be \nadded up into overall project variances to get the overall progress indicator for the project.   \nThis represents the  total variance  of the project and can be  reported  to management, clients, \nand stakeholders.  \nThe results are as instantaneous as the input data, that is, if you input the percent complete as \nof right now the statu s reported will be as of right now as well. It\u2019s amazing how a small \nvariance does not cause anyone concern until they see it as a number, and it can be corrected \nbefore it becomes more serious.  \nInterpreting the Results  \nThe first two calculations (SV and C V) give you the basic indicator of project progress.  A \nnegative value indicates an undesirable situation.  \n\uf0a7 If the schedule variance (SV) is negative, you are behind schedule.  \n\uf0a7 If the cost variance (CV) is negative, you are over budget.  \nThe amount of the var iance can be compared to the project\u2019s budget to see how concerning it \nis.  For example, a variance of $1,000 on a $100,000 project is not that concerning but a \n$10,000 variance might need some attention.  The variances can also  be compared to \nemployee cha rge out rates or something similar, for example a $1,000 variance might require \n18\n5  \n a person who\u2019s earning $50/hour to work 20 hours to recover.  \nIn our example the schedule variance was -$1,000 and the cost variance was $500.   This \nmeans that the project is be hind schedule, but it is being performed efficiently and is cost -\npositive.   If an worker  charging $75/hr was performing the majority of this work, they are \nabout 13 hours behind schedule (although they will finish under budget).  Thus, we know that \nthis ta sk requires a couple days of work over and above the regular schedule to get it back on \ntrack.  \nGraphing the results over multiple status points is a very helpful exercise.   Good  project \ncontrol  often means that the instantaneous project status snapshot is not as important as the \ntrend the indicators are making over time.   For example, if the SV has been increasing, then \nmaybe the project will finish on time even though it\u2019s behin d schedule today.  \nIt is a well understood concept that if projects fall behind early they will tend to continue \nfalling further behind throughout their entire life. Earned value analysis will alert you if you \nare even one hour behind and allow you to take the necessary remedial action. The value of \nthis in producing successful projects is almost without equal.  \n \n  \n5 Define Risk. Explain the needs and activities or risk management? APR/MAY -\n15 , NOV/DEC2015  ,NOV/DEC  2017  \nRisk is inevitable in a business orga nization when undertaking projects. However, the \nproject manager needs to ensure that risks are kept to a minimal. Risks can be mainly \ndivided between two types, negative impact risk and positive impact risk.  \nNot all the time would project managers be faci ng negative impact risks as there are positive \nimpact risks too. Once the risk has been identified, project managers need to come up with a \nmitigation plan or any other solution to counter attack the risk.  \nProject Risk Management  \nManagers can plan their st rategy based on four steps of risk management which prevails in \nan organization. Following are the steps to manage risks effectively in an organization:  \n\uf0b7 Risk Identification  \n\uf0b7 Risk Quantification  \n\uf0b7 Risk Response  \n\uf0b7 Risk Monitoring and Control  \nLet's go through each  of the step in project risk management:  \n18\n6  \n Risk Identification  \nManagers face many difficulties when it comes to identifying and naming the risks that \noccur when undertaking projects. These risks could be resolved through structured or \nunstructured brainstorm ing or strategies. It's important to understand that risks pertaining to \nthe project can only be handled by the project manager and other stakeholders of the project.  \nRisks, such as operational or business risks will be handled by the relevant teams. The r isks \nthat often impact a project are supplier risk, resource risk and budget risk.", "mimetype": "text/plain", "start_char_idx": 299718, "end_char_idx": 304130, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a5b6456b-9069-4290-af6b-5604ef801d32": {"__data__": {"id_": "a5b6456b-9069-4290-af6b-5604ef801d32", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ad91997808a98ed96b181dafc5a209d010e0805775696252dcb19f5160b116d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d0d23288-1f8f-4206-b143-2d27443330a0", "node_type": "1", "metadata": {}, "hash": "22002755222735511719b1cc26eade279ed5b910da0e70662d766fdf48fbc2f9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Project Risk Management  \nManagers can plan their st rategy based on four steps of risk management which prevails in \nan organization. Following are the steps to manage risks effectively in an organization:  \n\uf0b7 Risk Identification  \n\uf0b7 Risk Quantification  \n\uf0b7 Risk Response  \n\uf0b7 Risk Monitoring and Control  \nLet's go through each  of the step in project risk management:  \n18\n6  \n Risk Identification  \nManagers face many difficulties when it comes to identifying and naming the risks that \noccur when undertaking projects. These risks could be resolved through structured or \nunstructured brainstorm ing or strategies. It's important to understand that risks pertaining to \nthe project can only be handled by the project manager and other stakeholders of the project.  \nRisks, such as operational or business risks will be handled by the relevant teams. The r isks \nthat often impact a project are supplier risk, resource risk and budget risk. Supplier risk \nwould refer to risks that can occur in case the supplier is not meeting the timeline to supply \nthe resources required.  \nResource risk occurs when the human reso urce used in the project is not enough or not \nskilled enough. Budget risk would refer to risks that can occur if the costs are more than \nwhat was budgeted.  \nRisk Quantification  \nRisks can be evaluated based on quantity. Project managers need to analyze the l ikely \nchances of a risk occurring with the help of a matrix.  \n \nUsing the matrix, the project manager can categorize the risk into four  categories as Low, \nMedium, High and Critical. The probability of occurrence and the impact on the project are \nthe two parameters used for placing the risk in the matrix categories. As an example, if a risk \noccurrence is low (probability = 2) and it has th e highest impact (impact = 4), the risk can be \ncategorized as 'High'.  \nRisk Response  \nWhen it comes to risk management, it depends on the project manager to choose strategies \nthat will reduce the risk to minimal. Project managers can choose between the four risk \nresponse strategies, which are outlined below.  \n\uf0b7 Risks can be avoided  \n\uf0b7 Pass on the risk  \n\uf0b7 Take corrective measures to reduce the impact of risks  \n\uf0b7 Acknowledge the risk  \nRisk Monitoring and Control  \nRisks can be monitored on a continuous basis to check if any c hange is made. New risks can \nbe identified through the constant monitoring and assessing mechanisms.  \n18\n7  \n Risk Management Process  \nFollowing are the considerations when it comes to risk management process:  \n\uf0b7 Each person involved in the process of planning needs to  identify and understand the \nrisks pertaining to the project.  \n\uf0b7 Once the team members have given their list of risks, the risks should be \nconsolidated to a single list in order to remove the duplications.  \n\uf0b7 Assessing the probability and impact of the risks inv olved with the help of a matrix.  \n\uf0b7 Split the team into subgroups where each group will identify the triggers that lead to \nproject risks.  \n\uf0b7 The teams need to come up with a contingency plan whereby to strategically \neliminate the risks involved or identified.  \n\uf0b7 Plan the risk management process. Each person involved in the project is assigned a \nrisk in which he/she looks out for any triggers and then finds a suitable solution for \nit. \nRisk Register  \nOften project managers will compile a document, which outlines the ri sks involved and the \nstrategies in place. This document is vital as it provides a huge deal of information.  \nRisk register will often consists of diagrams to aid the reader as to the types of risks that are \ndealt by the organization and the course of action  taken. The risk register should be freely \naccessible for all the members of the project team.  \nProject Risk; an Opportunity or a Threat?  \nAs mentioned above, risks contain two sides. It can be either viewed as a negative element \nor a positive element. Negat ive risks can be detrimental factors that can haphazard situations \nfor a project.  \nTherefore, these should be curbed once identified. On the other hand, positive risks can \nbring about acknowledgements from both the customer and the management. All the risks  \nneed to be addressed by the project manager.  \nConclusion  \nAn organization will not be able to fully eliminate or eradicate risks. Every project \nengagement will have its own set of risks to be dealt with. A certain degree of risk will be \ninvolved when undert aking a project.  \nThe risk management process should not be compromised at any point, if ignored can lead to \ndetrimental effects. The entire management team of the organization should be aware of the \nproject risk management methodologies and techniques.", "mimetype": "text/plain", "start_char_idx": 303187, "end_char_idx": 307888, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d0d23288-1f8f-4206-b143-2d27443330a0": {"__data__": {"id_": "d0d23288-1f8f-4206-b143-2d27443330a0", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a5b6456b-9069-4290-af6b-5604ef801d32", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "17e47ea1b2c74e3d7a8e856d6e4d0dd4a9d6a74b8c577cdf66e8adecc4394319", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf2ceb5d-f329-47ac-87f2-eef545fbb54f", "node_type": "1", "metadata": {}, "hash": "90ee20dea9c321432eeb66b9ab60703a059d693563f1c9ddb6d780a9685b7f31", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "As mentioned above, risks contain two sides. It can be either viewed as a negative element \nor a positive element. Negat ive risks can be detrimental factors that can haphazard situations \nfor a project.  \nTherefore, these should be curbed once identified. On the other hand, positive risks can \nbring about acknowledgements from both the customer and the management. All the risks  \nneed to be addressed by the project manager.  \nConclusion  \nAn organization will not be able to fully eliminate or eradicate risks. Every project \nengagement will have its own set of risks to be dealt with. A certain degree of risk will be \ninvolved when undert aking a project.  \nThe risk management process should not be compromised at any point, if ignored can lead to \ndetrimental effects. The entire management team of the organization should be aware of the \nproject risk management methodologies and techniques.  \nEnhanced education and frequent risk assessments are the best way to minimize the damage \nfrom risks.  \n \n18\n8  \n 6 Explain  about  all COCOMO  models? NOV/DEC  2015,  \nAPRIL/MAY2016, APRIL/MAY 2017, APRIL/MAY  2018  \nCocomo (Constructive Cost Model) is a regression model based o n LOC, i.e  number  \nof Lines  of Code . It is a procedural cost estimate model for software projects and \noften used as a process of reliably predicting the various parameters associated with \nmaking a project such as size, effort, cost, time and quality. It was  proposed by Barry \nBoehm in 1970 and is based on the study of 63 projects, which make it one of the \nbest-documented models.  \nThe key parameters which define the quality of any software products, which are also \nan outcome of the Cocomo are primarily Effort &  Schedule:  \n\uf0b7 Effort:  Amount of labor that will be required to complete a task. It is \nmeasured in person -months units.  \n\uf0b7 Schedule:  Simply means the amount of time required for the completion of \nthe job, which is, of course, proportional to the effort put. It is  measured in the \nunits of time such as weeks, months.  \nDifferent models of Cocomo have been proposed to predict the cost estimation at \ndifferent levels, based on the amount of accuracy and correctness required. All of \nthese models can be applied to a variet y of projects, whose characteristics determine \nthe value of constant to be used in subsequent calculations. These characteristics \npertaining to different system types are mentioned below.  \nBoehm\u2019s definition of organic, semidetached, and embedded systems:  \n1. Organic \u2013 A software project is said to be an organic type if the team size \nrequired is adequately small, the problem is well understood and has been solved \nin the past and also the team members have a nominal experience regarding the \nproblem.  \n2. Semi -detached  \u2013 A software project is said to be a Semi -detached type if the \nvital characteristics such as team -size, experience, knowledge of the various \nprogramming environment lie in between that of organic and Embedded. The \nprojects classified as Semi -Detached are comparatively less familiar and difficult \nto develop compared to the organic ones and require more experience and better \nguidance and creativity. Eg: Compilers or different Embedded Systems can be \nconsidered of Semi -Detached type.  \n3. Embedded \u2013 A software pro ject with requiring the highest level of \ncomplexity, creativity, and experience requirement fall under this category. Such \nsoftware requires a larger team size than the other two models and also the \ndevelopers need to be sufficiently experienced and creati ve to develop such \ncomplex models.  \nAll the above system types utilize different values of the constants used in Effort \nCalculations.  \nTypes of Models:  COCOMO consists of a hierarchy of three increasingly detailed \nand accurate forms. Any of the three forms c an be adopted according to our \nrequirements. These are types of COCOMO model:  \n1. Basic COCOMO Model  \n2. Intermediate COCOMO Model  \n3. Detailed COCOMO Model  \n18\n9  \n The first level,  Basic COCOMO  can be used for quick and slightly rough \ncalculations of Software Costs. Its accu racy is somewhat restricted due to the absence \nof sufficient factor considerations.  \nIntermediate COCOMO  takes these Cost Drivers into account and  Detailed \nCOCOMO  additionally accounts for the influence of individual project phases, i.e in \ncase of Detailed it accounts for both these cost drivers and also calculations are \nperformed phase wise henceforth producing a more accurate result.", "mimetype": "text/plain", "start_char_idx": 306986, "end_char_idx": 311496, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bf2ceb5d-f329-47ac-87f2-eef545fbb54f": {"__data__": {"id_": "bf2ceb5d-f329-47ac-87f2-eef545fbb54f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d0d23288-1f8f-4206-b143-2d27443330a0", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "bdaa58c7cf88b6cd0ec2660def6ef4a4df66d0c016951b986860440e5e49bed3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4f25b662-1891-4305-9079-4ab2e2170813", "node_type": "1", "metadata": {}, "hash": "b5e06762b3dec8144c2e525771f4f975b66379f26f47f50ddefd7408ce0b2f41", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Types of Models:  COCOMO consists of a hierarchy of three increasingly detailed \nand accurate forms. Any of the three forms c an be adopted according to our \nrequirements. These are types of COCOMO model:  \n1. Basic COCOMO Model  \n2. Intermediate COCOMO Model  \n3. Detailed COCOMO Model  \n18\n9  \n The first level,  Basic COCOMO  can be used for quick and slightly rough \ncalculations of Software Costs. Its accu racy is somewhat restricted due to the absence \nof sufficient factor considerations.  \nIntermediate COCOMO  takes these Cost Drivers into account and  Detailed \nCOCOMO  additionally accounts for the influence of individual project phases, i.e in \ncase of Detailed it accounts for both these cost drivers and also calculations are \nperformed phase wise henceforth producing a more accurate result. These two models \nare further discussed below.  \nEstimation of Effort: Calculations \u2013 \n4. Basic Model \u2013 \n5.  \nThe above formula is used for the cost estimation of for the basic COCOMO \nmodel, and also is used in the subsequent models. The constant  values a and b for \nthe Basic Model for the different categories of system:  \nSOFTWARE PROJECTS  A B \nOrganic  2.4 1.05 \nSemi Detached  3.0 1.12 \nEmbedded  3.6 1.20 \nThe effort is measured in Person -Months and as evident from the formula is \ndependent on Kilo -Lines of code. These formulas are used as such in the Basic \nModel calculations, as not much consideration of different factors such as \nreliability, expertise is taken into account, henceforth the estimate is rough.  \n6. Intermediate Model \u2013 \nThe basic Cocomo model assumes that the effort is only a function of the number \nof lines of code and some constants evaluated according to the different software \nsystem. However, in reality, no system\u2019s effort and schedule can be solely \ncalculated on the basis of Lines of Code. For that, various other factors such as \nreliability, experience, Capability. These factors are known as Cost Drivers and \nthe Intermediate Model utilizes 15 such drivers for cost estimation.  \nClassification of Cost Drivers and their attributes:  \n1.", "mimetype": "text/plain", "start_char_idx": 310688, "end_char_idx": 312785, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4f25b662-1891-4305-9079-4ab2e2170813": {"__data__": {"id_": "4f25b662-1891-4305-9079-4ab2e2170813", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf2ceb5d-f329-47ac-87f2-eef545fbb54f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ebc2aac680e23336193f4ec9e535b359d109ba6f800db7820d56637069dd72c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "24375d55-a978-4c4e-90a4-d8beb35572bb", "node_type": "1", "metadata": {}, "hash": "073f48e42df99fcef8e2116e40660331d79a1f9d8a09f0234d5309c7c169c3a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These formulas are used as such in the Basic \nModel calculations, as not much consideration of different factors such as \nreliability, expertise is taken into account, henceforth the estimate is rough.  \n6. Intermediate Model \u2013 \nThe basic Cocomo model assumes that the effort is only a function of the number \nof lines of code and some constants evaluated according to the different software \nsystem. However, in reality, no system\u2019s effort and schedule can be solely \ncalculated on the basis of Lines of Code. For that, various other factors such as \nreliability, experience, Capability. These factors are known as Cost Drivers and \nthe Intermediate Model utilizes 15 such drivers for cost estimation.  \nClassification of Cost Drivers and their attributes:  \n1. Product attri butes \u2013 \n\uf0b7 Required software reliability extent  \n\uf0b7 Size of the application database  \n\uf0b7 The complexity of the product  \n(ii) Hardware attributes \u2013 \n\uf0b7 Run-time performance constraints  \n\uf0b7 Memory constraints  \n\uf0b7 The volatility of the virtual machine environment  \n19\n0  \n \uf0b7 Required turnabout time \n(iii) Personnel attributes \u2013 \n\uf0b7 Analyst capability  \n\uf0b7 Software engineering capability  \n\uf0b7 Applications experience  \n\uf0b7 Virtual machine experience  \n\uf0b7 Programming language experience  \n(iv) Project attributes \u2013 \n\uf0b7 Use of software tools  \n\uf0b7 Application of software engineering meth ods \n\uf0b7 Required development schedule  \n; \nCOST DRIVERS  VERY \nLOW  LOW  NOMINAL  HIGH  VERY \nHIGH  \nProduct Attributes  \n     Required Software \nReliability  0.75 0.88 1.00 1.15 1.40 \nSize of Application \nDatabase  \n 0.94 1.00 1.08 1.16 \nComplexity of The \nProduct  0.70 0.85 1.00 1.15 1.30 \nHardware Attributes  \n     Runtime Performance \nConstraints  \n  1.00 1.11 1.30 \nMemory Constraints  \n  1.00 1.06 1.21 \nVolatility of the virtual \n 0.87 1.00 1.15 1.30 \n19\n1  \n machine environment  \nRequired turnabout \ntime \n 0.94 1.00 1.07 1.15 \nPersonnel attri butes  \n     Analyst capability  1.46 1.19 1.00 0.86 0.71 \nApplications \nexperience  1.29 1.13 1.00 0.91 0.82 \nSoftware engineer \ncapability  1.42 1.17 1.00 0.86 0.70 \nVirtual machine \nexperience  1.21 1.10 1.00 0.90 \n Programming language \nexperience  1.14 1.07 1.00 0.95 \n Project Attributes  \n     Application of software \nengineering methods  1.24 1.10 1.00 0.91 0.82 \nUse of software tools  1.24 1.10 1.00 0.91 0.83 \nRequired development \nschedule  1.23 1.08 1.00 1.04 1.10 \nThe project manager is to rate these 15 differen t parameters for a particular \nproject on a scale of one to three. Then, depending on these ratings, appropriate \n19\n2  \n cost driver values are taken from the above table. These 15 values are then \nmultiplied to calculate the EAF (Effort Adjustment Factor). The Inte rmediate \nCOCOMO formula now takes the form:  \n \nThe values of a and b in case of the intermediate model are as fo llows:  \nSOFTWARE PROJECTS  A B \nOrganic  3.2 1.05 \nSemi Detached  3.0 1.12 \nEmbeddedc  2.8 1.20 \n2. Detailed Model \u2013 \nDetailed COCOMO incorporates all characteristics of the intermediate version \nwith an assessment of the cost driver\u2019s impact on each step of the sof tware \nengineering process. The detailed model uses different effort multipliers for each \ncost driver attribute. In detailed cocomo, the whole software is divided into \ndifferent modules and then we apply COCOMO in different modules to estimate \neffort and th en sum the effort.  \nThe Six phases of detailed COCOMO are:  \n1. Planning and requirements  \n2. System design  \n3. Detailed design  \n4. Module code and test  \n5. Integration and test  \n6.", "mimetype": "text/plain", "start_char_idx": 312023, "end_char_idx": 315560, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "24375d55-a978-4c4e-90a4-d8beb35572bb": {"__data__": {"id_": "24375d55-a978-4c4e-90a4-d8beb35572bb", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4f25b662-1891-4305-9079-4ab2e2170813", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a8e7eb0f54bae5f6a2e19dc72923e19d56c1661d4398d14cd1aa5c9bc613a4fc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36d409f7-601b-47d5-9472-deefdf8e3697", "node_type": "1", "metadata": {}, "hash": "b1d9686cb545d22b9384f14bea8fc5534aecdcad9f9770e5d960e2fb50c9f573", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Detailed Model \u2013 \nDetailed COCOMO incorporates all characteristics of the intermediate version \nwith an assessment of the cost driver\u2019s impact on each step of the sof tware \nengineering process. The detailed model uses different effort multipliers for each \ncost driver attribute. In detailed cocomo, the whole software is divided into \ndifferent modules and then we apply COCOMO in different modules to estimate \neffort and th en sum the effort.  \nThe Six phases of detailed COCOMO are:  \n1. Planning and requirements  \n2. System design  \n3. Detailed design  \n4. Module code and test  \n5. Integration and test  \n6. Cost Constructive model  \nThe effort is calculated as a function of program size and a set of cost dri vers are \ngiven according to each phase of the software lifecycle.  \n \n7 Write   about   software   maintenance,  PERT  - CPM  for scheduling , \nRMMP  NOV/DEC -12 \nProject Scheduling or project management is used to schedule, manage and \ncontrol projects which can b e analyzed into various semi -independent \nactivities or tasks. Example: Building a New Home When building a home \nindividual subcontractors are hired to:  \n \u2015 Grade and prepare the land  \n \u2015 Build the foundation  \n \u2015 Frame up the home  \n\u2015 Insulate the home  \n\u2015 Wire (Electricity, Cable, Telephone lines) the home \u2015 Drywall  \n19\n3  \n \u2015 Paint (inside)  \n\u2015 Put vinyl siding on home  \n \u2015 Install Carpet  \n \u2015 Landscape  \n \u2015 Lay Concrete  \nPERT \u2013 Program Evaluation and Review Technique  \n \u2013 Developed by U.S. Navy for Polaris missile project  \n \u2013 Developed to handle uncertain activity times CPM  \n\u2013 Critical Path Method  \n\u2013 Developed by Du Pont & Remington Rand  \n \u2013 Developed for industrial projects for which activity times are known \nThere are project management software packages that can perform both.  \nPERT and CPM have been used to plan, schedule, and control a wide \nvariety of projects:  \n \u2013 R&D of new products and processes  \n \u2013 Construction of buildings and highways  \n \u2013 Maintenance of large and complex equipment  \n\u2013 Design and installation of management syste ms \n \u2013 Organizing transportation projects  \n\u2013 Deployment and/or relocation of forces  \n\u2013 Design of computer systems  \n\uf0b7 PERT/CPM is used to plan the scheduling and optimal staffing of \nindividual activities that make up a project.  \n\uf0b7 Projects may have as many as sev eral thousand activities and may \nhave to be broken up into simpler sub -projects.  \n\uf0b7  Usually some activities depend on the completion of other activities \nbefore they can be started.  \n\uf0b7  So we need to start with the Prerequisites Task Set giving the order \nof prec edencies, along with durations for each task, or activity  \n8 Describe steps involved in project scheduling process, project timeline chart \nand task network . MAY/JUN -15, APRIL/MAY  2018  \nPress -Pg-no- 708 \n19\n4  \n 9 (b) Suppose you have a budgeted cost of a project as Rs.  9,00,000. The project \nis to be completed in 9 months. After a month you have completed 10 percent \nof project at a total expense of Rs. 1,00,000. The planned completion should \nhave been 15 percent. You need to determine whether the project is on -time \nand on budget? Use Earned value analysis approach and interpret NOV/DEC  \n2016  \n(c ) Consider the following function point components and their complexity. If \nthe total degree of influence is 52, find the estimated function  points.  \nFunction type  Estimated count  complexi ty \nFED  2 7 \nGHD  4 \n10 \nHJI 22 4 \nBU 16 5 \n BJ 24 4 \n \n \nRefer class notes  \n10 Describe in detail COCOMO model for software cost estimation. Use it to \nestimate the effort required to build software for a simple ATM that produce \n12 screens, 10 reports and has 80 so ftware components. Assume average \ncomplexity and average developer maturity. Use application composition \nmodel with object points. NOV/DEC 2016, NOV/DEC 2017  \n \nRefer class notes  \n11 Explain the process of function point analysis?explain function point analys is \nwith sample cases for componentfor different complexity APRIL/MAY 2018  \nRefer class notes  \n12 Discuss on the various software cost estimation techniques. (April/MayApr/May \n2008)  \nRefer class notes  \n13 Explain  the process of Delphi method ?", "mimetype": "text/plain", "start_char_idx": 314945, "end_char_idx": 319135, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "36d409f7-601b-47d5-9472-deefdf8e3697": {"__data__": {"id_": "36d409f7-601b-47d5-9472-deefdf8e3697", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "24375d55-a978-4c4e-90a4-d8beb35572bb", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "69df9f0f0325be7955ed93d047bd26faea4a4b0a40278af989bb822bc148769e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b817c53-525b-4cb5-990f-eb8332c6627e", "node_type": "1", "metadata": {}, "hash": "2d418f342523144737e2b956a91621e106f986977e7ed1828fdc46549c28d3a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Use it to \nestimate the effort required to build software for a simple ATM that produce \n12 screens, 10 reports and has 80 so ftware components. Assume average \ncomplexity and average developer maturity. Use application composition \nmodel with object points. NOV/DEC 2016, NOV/DEC 2017  \n \nRefer class notes  \n11 Explain the process of function point analysis?explain function point analys is \nwith sample cases for componentfor different complexity APRIL/MAY 2018  \nRefer class notes  \n12 Discuss on the various software cost estimation techniques. (April/MayApr/May \n2008)  \nRefer class notes  \n13 Explain  the process of Delphi method ? advantages and  disadvantages \n(Nov/Dec 2013)  \nRefer class notes  \n14 Explain about Risk management (May/Jun 2014)  \nRisk management  is the identification, evaluation, and prioritization of  risks  (defined \n19\n5  \n in ISO 31000  as the effect of uncertainty on objectives ) followed by coordinated and \neconomical application of resources to minimize, monitor, and control the probability \nor impact of unfortunate  events[1] or to maximize the realization of opportunities.  \nRisks can come from various sources including uncertainty in  financial markets , \nthreats from project failures (at any phase in design, development, production, or \nsustaining of life -cycles), legal liabilities, credit risk, accidents,  natural causes and \ndisasters , deliberate attack from an adversary, or events of uncertain or \nunpredictable  root-cause . There are two types of events i.e. negative events can be \nclassified as risks while positive events are classified as opportunities. Risk \nmanagement  standards  have been develope d by various institutions, including \nthe Project Management Institute , the National Institute of Standards and Technology , \nactuarial societies, and ISO standards.[2][3] Methods, definitions and goals vary widely \naccording to whether the risk management method is in the context of project \nmanagement, security,  engineering , industrial processes , financial portfolios, actuarial \nassessments, or public health and safety.  \nStrategies to manage threats (uncertainties with negative consequences) typically \ninclude avoiding the threat, reducing the negative effect or probability of the threat, \ntransferring all or part of the threat to another party, and even retainin g some or all of \nthe potential or actual consequences of a particular threat, and the opposites for \nopportunities (uncertain future states with benefits).  \nCertain risk management standards have been criticized for having no measurable \nimprovement on risk, whereas the confidence in estimates and decisions seems to \nincrease.[1] For example, one study found that one in six IT projects were \" black \nswans \" with gigantic overruns (cost overruns averaged 200%, and schedule overruns \n7 \n \n15 Give detail explanation about Scheduling and Tracking  \nProject Scheduling helps to establish a  roadmap for project managers together with \nestimation methods and risk analysis. Project scheduling and Tracking begins with the \nidentification of process models, identification of software tasks and activities, \nestimation of effort and work and ends with  creation of network of tasks and making \nsure it gets done on time. This network is adapted on encountering of changes and \nrisks.  \n \nAt the project level, the Project Manager does project tracking and scheduling based \non information received from Software En gineers. At an individual level the Software \nEngineer does it. It is important, as in a complex system many tasks may occur in \nparallel and have interdependencies that are understandable only with a schedule. A \ndetailed schedule is a useful tool to assess progress on a moderate or large project.  \n  \nThe basic steps followed are, once the tasks dictated by the software process model is \nrefined based on the functionality of the system , effort and duration are allocated for \neach task and an activity network is created that allows the project to meets its \ndeadlines. The work product of this activity is the project schedule and in order that it \nis accurate it is required to check all tasks are covered in the activity network, effort \nand timing are appropriately al located, interdependencies are correctly indicated, \n19\n6  \n resources are allocated tasks in a right manner and closely spaced milestones are \ndefined to track the project easily.  \n  \nOne of the major challenges in software project management is the difficulty to \nadhere to schedules. The common reasons for a late delivery of software project are \nan unrealistic deadline, changing customer requirements, honest underestimate of \neffort or resources, overlooked risks, unforeseen technical difficulties or human \ndifficulties , miscommunication and failure by project manager to recognize the delay \nearly and take appropriate measures.", "mimetype": "text/plain", "start_char_idx": 318496, "end_char_idx": 323377, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9b817c53-525b-4cb5-990f-eb8332c6627e": {"__data__": {"id_": "9b817c53-525b-4cb5-990f-eb8332c6627e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "d8e2994c-91a7-499a-ad27-2d6b07280208", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36d409f7-601b-47d5-9472-deefdf8e3697", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7fe6c850d52c337eec16bd6e1dc9b26ebc7bb91222349f7b94ecdcc2f7fde6c7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The work product of this activity is the project schedule and in order that it \nis accurate it is required to check all tasks are covered in the activity network, effort \nand timing are appropriately al located, interdependencies are correctly indicated, \n19\n6  \n resources are allocated tasks in a right manner and closely spaced milestones are \ndefined to track the project easily.  \n  \nOne of the major challenges in software project management is the difficulty to \nadhere to schedules. The common reasons for a late delivery of software project are \nan unrealistic deadline, changing customer requirements, honest underestimate of \neffort or resources, overlooked risks, unforeseen technical difficulties or human \ndifficulties , miscommunication and failure by project manager to recognize the delay \nearly and take appropriate measures.  \n  \nSoftware project scheduling is an activity that distributes estimated effort across the \nduration of project cycle by allocating effort to each s pecific task that is associated \nwith all process. The basic principles that guides software project scheduling is \ncompartmentalization of the project into a number of manageable tasks, correct \nallocation of time, correct effort validation ,defining respons ibility for each task to a \nteam member, defining outcomes or work product for each task and defining \nmilestones for a task or group of tasks as appropriate.  \n  \nA Task set is a collection of software tasks, milestones and deliveries that must be \ncompleted fo r the project to be successfully accomplished. Task sets are defined for \nbeing applicable to different type of project and degree of rigor. The types of projects \ncommonly encountered are Concept Development projects, New applications, \nDevelopment projects,  Application enhancement projects, Application maintenance \nprojects and Re -engineering projects. The degree of rigor with which the software \nprocess is applied may be casual, structured, strict or quick reaction (used for \nemergency situation).  \n  \nFor the pr oject manager to develop a systematic approach for selecting degree of rigor \nfor the type of project project adaptation criteria are defined and a task set selector \nvalue is computed based on the characteristics of the project.  \n  \nProgram evaluation and rev iew technique (PERT) and critical path method (CPM) are \ntwo of the commonly used project scheduling methods. These techniques are driven \nby information such as estimates of effort, decomposition of the product function, the \nselection of process model, task  set and decomposition of tasks. The \ninterdependencies among tasks are defined using a task network.  \n  \nA task network or activity network is a graphic representation of the task flows for a \nproject. According to basic PERT, expected task duration is calcul ated as the \nweighted average of the most pessimistic, the most optimistic and most probable time \nestimates. The expected duration of any path on the network is found by summing the \nexpected durations of tasks.  \n  \nPERT gives appropriate results when there is  a single dominant path in the network. \nThe time needed to complete the project is defined by the longest path in the network \nwhich is called critical path. CPM allows software planner to determine the critical \npath and establish most likely time estimates . \n19\n7  \n   \nWhile creating schedule a timeline chart also called as Gantt chart can be generated. \nThis can be developed for entire project or separately for each function or individual.  \n \nThe information necessary for generation of this is Work Breakdown Structure (WBS \n\u2013 Making a complex project manageable by breaking it into individual components in \na hierarchical structure that defines independent tasks), effort, duration and start date \nand details of assignment of tasks to resources. Along with this most software  project \nscheduling tools produce project tables which is a tabular listing o project tasks, their \nplanned and actual start, end dates and other information. This with timeline chart is \nvaluable to project managers to track the progress.  \n  \nTracking the pro ject schedule can be done by conducting periodic project status \nmeeting, evaluating result of reviews conducted at all stages of development life \ncycle, determining the completion of defined project milestones, comparison of actual \nand planned dates, using  earned value analysis technique for performing quantitative \nanalysis of program.  \n  \nError tracking methods can also be used for ass essing the status of current project. \nThis is done by collecting error related measures and metrics from past project and \nusing this as baseline for comparison against real time data.", "mimetype": "text/plain", "start_char_idx": 322534, "end_char_idx": 327257, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "75516d67-96c6-43da-b89e-8e4d52e6a546": {"__data__": {"id_": "75516d67-96c6-43da-b89e-8e4d52e6a546", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee", "node_type": "1", "metadata": {}, "hash": "783fd65c7d5852a22f31c8bb7b965b4437bb29c9dd21479848858f23183f37b2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "1   \n \n \n \n \n \n \n \nDEPARTMENT OF COMPUTER SCIENCE & ENGINEERING  \n \n \nCS8494 \nSOFTWARE ENGINEERING  \nQuestion Bank  \nIII YEAR A & B / BATCH : 2017  -21\n2  \n  \n \nSYLLABUS  \n \n \nCS 8494 - SOFTWARE ENGINEERING  \n \n \n \n \nUNIT I - SOFTWARE PROCESS AND  PROJECT  MANAGEMENT  9 \nIntroduction to Software E ngineering, Software Process, Perspective and Specialized Process \nModels . Introduction to Agility -Agile process -Extreme programming -XP Process.  \nUNIT II -REQUIREMENTS ANALYSIS  AND SPECIFICATION  9 \nSoftware Requirements:Functional and Non -Functional, User requ irements, System \nrequirements,Software Requirements Document \u2013Requirement Engineering Process: Feasibility \nStudies,Requirements elicitation and analysis, requirements validation, requirements management - \nClassicalanalysis: Structured system Analysis, Petri  Nets-Data Dictionary  \nUNIT  III-SOFTWARE DESIGN  9 \nDesign process \u2013Design Concepts -Design Model \u2013Design Heuristic \u2013Architectural Design \u2013 \nArchitectural styles, Architectural Design, Architectural Mapping using Data Flow -User nterface \nDesign: Interface analysi s, Interface Design \u2013Component levelDesign: Designing Class based \ncomponents, traditional Components  \nUNIT IV -TESTING  AND  IMPLEMENTATION  9 \nSoftware testing fundamentals -Internal and external views of Testing -white box testing -basis \npathtesting -control stru cture testing -black box testing -Regression Testing \u2013Unit Testing \u2013\n3  \n IntegrationTesting  \u2013Validation  Testing  \u2013System  Testing  And Debugging  \u2013Software \nImplementationTechniques: Coding  practices -ING \n \n \n \n \nUNIT V  -PROJECT  MANAGEMENT  9 \n \n \nEstimation \u2013FP Based, LOC Ba sed, Make/Buy Decision, COCOMO II -Planning \u2013Project Plan, \nPlanning Process, RFP Risk Management \u2013Identification, Projection,RMMM -Scheduling and \nTracking \u2013Relationship between people and effort, Task Set & Network, Scheduling, EVA \u2013 \nProcessand Project Met rics \n \n \nTEXT BOOKS  \n\uf0b7 Roger S. Pressman,  \u201cSoftware Engineering  \u2013 A practitioner\u2019s  Approach\u201d,  Sixth  Edition,  \nMcGraw -Hill International Edition, 2005  \n\uf0b7 Ian Sommerville, \u201cSoftware engineering\u201d, Seventh Edition, Pearson Education Asia, 2007.  \n \n \n \nREFERENCES:  \n \n1. Rajib  Mall, \u2015Fundamentals of Software Engineering\u2016, Third Edition, PHI Learning \nPrivateLimited, 2009.  \n2. PankajJalote, \u2015Software Engineering, A Precise Approach\u2016, Wiley  India, \n2010.  \n3. Kelkar S.A., \u2015Software Engineering\u2016, Prentice Hall of India Pvt Ltd, 2007.  \n4. Steph en R.Schach, \u2015Software Engineering\u2016, Tata McGraw -Hill Publishing Company  \nLimited,2007.\n4  \n  \nINDEX PAGE  \n \n \n \n \nUNIT   \nREFERENCE BOOK   \nPAGE \nNUMBER  \n \nI Roger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGraw -Hill International Edi tion, 2010  1- 212 \n \n \nII Roger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGraw -Hill International Edition,  2010  220- 294 \n \nIII  \nRoger  S. Pressman,  \u201cSoftware  Engineering  \u2013 A practitioner\u2019s \nApproach\u201d, Sixth Edition, McGr aw-Hill International Edition,  2010  311- 357 \n \nIV  \nIan Sommerville, \u2015Software Engineering\u2016, 9th Edition, Pearson Education Asia, 2011  360- 427 \n \nV  \nIan Sommerville, \u2015Software Engineering\u2016, 9th Edition, Pearson Education Asia, 2011  663- 771 \n \n \n \n \n \n \n \n5  \n  \nUNIT \u2013 1 \nPART \u2013A \nS.NO  QUESTIONS  \n1 Write down the generic  process framework that is applicable to any software project / \nrelationship between work product, task, activity and system NOV/DEC -\n10,NOV/DEC2016,  NOV/DEC  2017  \nCommon process frame work  \n- Process frame work  activities  \n- Umbrella activities  \n- Frame work  activit ies \n- Task  sets \n2 List the goals  of software  engineering?  APR/MAY -11 \nSatisfy user requirements , High reliability , Low maintenance cost , Delivery on time , Low \nproduction cost , High performance , Ease of reuse.  \n3 What is the difference between verificat ion and validation?", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3923, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee": {"__data__": {"id_": "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "75516d67-96c6-43da-b89e-8e4d52e6a546", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0f719e162a73e966b7633fa6714cc9b8526bb7a24c7ac555d2c6d4ff1159d031", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f0cf1cb0-3124-4086-92a8-42e9a44bcda6", "node_type": "1", "metadata": {}, "hash": "57d57e9679f0fba613978ca4f6708c6af0605875cff8ec1fa957e99ee1d601f5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "APR/MAY -11 \nSatisfy user requirements , High reliability , Low maintenance cost , Delivery on time , Low \nproduction cost , High performance , Ease of reuse.  \n3 What is the difference between verificat ion and validation? NOV/DEC -10 , APR/MAY -11 \n, NOV/DEC -11, MAY/JUN -13 \n\uf0b7 Verification refers to the set of activities that ensure that software correctly implements  \na specific  function.  Verification : \"Are  we building  the product  \nright?\"  \n \uf0b7 Validation refers to a different set of activities that ensure that the software that  has \nbeen built is traceable  to customer  requirements.  Validation : \"Are  \nwe building the right product?\"  \n6  \n 4 For the scenario described below, which life cycle model would you choose? Give the \nreason why you would choose this model. NOV/DEC -11 , \nYou are interacting with the MIS department of a very large oil company with multiple \ndepartments. They have a complex regency system. Migrating the data from this legacy \nsystem is not an easy task and wo uld take a considerable time. The oil company is very \nparticular about processes, acceptance criteria and legal contracts.  \nSpiral  model  Proactive problem prevention. Each iteration has a risk analysis,   \nsector   that   evaluates.  Alternatives for proactiv e problem  \navoidance.  \n5 Give two reasons why system engineers must understand the environment of a system? \nAPR/MAY -12 \n \n1. The reason for the existence of a system is to make some changes i its  \nenvironment.  \n \n2. The functioning of a system can be very difficult to  predict.  \n6 What are the two types of software products? APR/MAY -12 \n1. Generic products: these are stand -alone systems that are produced by a development  \nOrganization and sold in the open market to any customer who wants to buy it.  \n2. Customized products: these  are systems that are commissioned by a specific customer  \nand developed specially by some contractor to meet a special need.  \n7 What is the advantage of adhering to life cycle models for software? NOV/DEC -12 \nIt helps  to produce  good  quality  software  produc ts without  time and cost over  \nruns.It  encourages the development  of software in  a systematic  & disciplined  \n manner.  \n7  \n 8 Is it always possible to realize win -win spiral model for software? Justify.  \nNOV/DEC -12 \n \n \no Must identify stake holder and their win  condition  \no Developing buy -in to the model is important than the model itself  \no Eliminating the clashes between customers is important.  \n9 What is software process? List its activities. MAY/JUN -13 \nSoftware process is defined as the structured set of activities that are required to \ndevelop the software  system.  \nActivities \u2013 Specification, design & implementation, validation & evolution.  \n10 What are the various categories of software?  \n\uf0b7 System  software  \n\uf0b7 Application  software  \n\uf0b7 Engineering/Scientific software  \n\uf0b7 Embedded  software  \n\uf0b7 Web Applications  \n\uf0b7 Artificial Intelligence  software  \n11 What are the umbrella activities of a software process? APR/MAY 2015  \n\uf0b7 Software project tracking and  control.  \n\uf0b7 Risk management.  \n\uf0b7 Software Quality  Assurance.  \n\uf0b7 Formal Technical  Reviews.  \n\uf0b7 Software Configu ration  Management.  \n\uf0b7 Work product preparation and  production.  \n\uf0b7 Reusability  management.  \n\uf0b7 Measurement  \n12 What are the merits of incremental model?  \ni. The incremental model can be adopted when tere are less number of people involved \nin the project.  \n8  \n  ii. Technical r isks can be managed with each  increment.  \niii. For a very small time span,at least core product can be delivered to the customer.  \n13 List the task regions in the Spiral  model . \n\uf0b7 Customer communication \u2013 In this region it is suggested to establish customer  \ncommuni cation.  \n\uf0b7 Planning \u2013 All planning activities are carried out in order to define resources timeline \nand otherproject related  activities.  \n\uf0b7 Risk analysis \u2013 The tasks required to calculate technical and management risks.  \n\uf0b7 Engineering \u2013 In this the task region,task s required to build one or more representations \nof applications are carried  out. \n\uf0b7 Construct  and release  \u2013 All the necessary  tasks  required  to \nconstruct,test,install the applications are conducted. \u00be_Customer  evaluation  \n\u2013 Customer\u201f s feedback is obtained and  based on the customer  evaluation  \nrequired tasks are performed and implemented at installation stage.", "mimetype": "text/plain", "start_char_idx": 3700, "end_char_idx": 8108, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f0cf1cb0-3124-4086-92a8-42e9a44bcda6": {"__data__": {"id_": "f0cf1cb0-3124-4086-92a8-42e9a44bcda6", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7e249cdb42f4f885a9d658a8d891a88557d6d908a006240af964743aac617c84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e9400b64-c39b-4322-9e3a-833b07693f82", "node_type": "1", "metadata": {}, "hash": "dbcd47db370dd81519f2140ba8cf0da671ba9539ea76589e5d605808b2773524", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Technical r isks can be managed with each  increment.  \niii. For a very small time span,at least core product can be delivered to the customer.  \n13 List the task regions in the Spiral  model . \n\uf0b7 Customer communication \u2013 In this region it is suggested to establish customer  \ncommuni cation.  \n\uf0b7 Planning \u2013 All planning activities are carried out in order to define resources timeline \nand otherproject related  activities.  \n\uf0b7 Risk analysis \u2013 The tasks required to calculate technical and management risks.  \n\uf0b7 Engineering \u2013 In this the task region,task s required to build one or more representations \nof applications are carried  out. \n\uf0b7 Construct  and release  \u2013 All the necessary  tasks  required  to \nconstruct,test,install the applications are conducted. \u00be_Customer  evaluation  \n\u2013 Customer\u201f s feedback is obtained and  based on the customer  evaluation  \nrequired tasks are performed and implemented at installation stage.  \n14 Characteristics  of software  contrast  to characteristics  of hardware?  \nAPR/MAY 2016  \n \no Software is easier to change than hardware. The cost of change is much higher for \nhardware than for  software.  \no Software products evolve through multiple releases by adding new features and re -\nwriting existing logic to support the new features. Hardware products consist of physical \ncomponents that cannot be \u201crefactored\u201d aft er manufacturing, and cannot add new \ncapabilities that require hardware changes.  \no Specialized hardware components can have much longer lead times for acquisition than \nis true for  software.  \no Hardware design is driven by architectural decisions. More of the ar chitectural work \nmust be done up front compared to software  products.  \no The cost of development for software products is relatively flat over  time.  \n9  \n  However, the cost of hardware development rises rapidly towards the end of the \ndevelopment cycle.  \no Testing software commonly requires developing thousands of test cases. Hardware \ntesting involves far fewer  tests.  \nHardware must be designed and tested to work over a range of time and environmental \nconditions, which is not the case for software.  \n15 List the proce ss maturity levels in SEIs CMM. NOV/DEC2015  \nLevel 1:Initial \u2013 Few processes are defined and individual efforts are taken. Level \n2:Repeatable \u2013 To track cost schedule and functionality basic project management \nprocesses are established.  \nLevel 3:Defined \u2013 The p rocess is standardized, documented and followed.  \nLevel 4:Managed \u2013 Both the software process and product are quantitatively understood \nand controlled using detailed measures.  \n16 What does Verification represent?  \nVerification represents the set of activitie s that are carried out to confirm that the \nsoftware correctly implements the specific  functionality.  \n17 What does Validation represent?  \nValidation represents the set of activities that ensure that the software that has been \nbuilt is satisfying the custome r requirements.  \n10  \n 18 What are the steps followed in testing?  MAY/JUNE 2016  \ni. Unit testing \u2013 The individual components are tested in this type of  testing.  \nii. Module testing \u2013 Related collection of independent components  are \ntested.  \niii. Sub-system testing \u2013 This is a kind of integration testing. Various modules  are \nintegrated into a subsystem and the whole subsystem is tested.  \niv. System testing \u2013 The whole system is tested in this system.  \nv. Acceptance  testing  \u2013 This type of testing  involves  testing  of the system  \nwith custom er data.If the system behaves as per customer need then it is accepted.  \n19 State  the  advantages  and disadvantages in LOC based cost estimation? APR/MAY \n2015  \n \nAdvantages of LOC  \n \n       It is straight forward  (simple)  \n \n       Easily can be automated (pl enty of tools are  available)  \n \nDisadvantages of LOC  \n \n       Its Language dependent  \n \n       Penalizes the well designed short  programs  \n \n       Cannot easily accommodate nonprocedural  languages  \n \n       Need a level of detail that may not be available at t he early stages of development.  \n11  \n 20 What is requirement engineering?  \n \nRequirement engineering is the process of establishing the services that the customer requires \nfrom the system and the constraints under which it operates and  \nis developed.  \n21 What are the various types of traceability in software engineering?  \n \ni. Source traceability \u2013 These are basically the links from requirement to stakeholders who \npropose these  requirements.  \n \nii . Requirements traceability \u2013 These are links between dependant  requirements.  \n \niii . Design traceability \u2013 These are links from requirements to  design.  \n22 If you have to develop a word processing software product, what process models will you \nchoose? Justify your answer.", "mimetype": "text/plain", "start_char_idx": 7177, "end_char_idx": 11979, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e9400b64-c39b-4322-9e3a-833b07693f82": {"__data__": {"id_": "e9400b64-c39b-4322-9e3a-833b07693f82", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f0cf1cb0-3124-4086-92a8-42e9a44bcda6", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "682cdf13bef3d73bc631be28bdc09b887609da7619d1d0b790dc240deb19db02", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c5a590e6-1666-45e9-8bac-80410e976250", "node_type": "1", "metadata": {}, "hash": "a9dbe4620d09d80a32889388bdde3bf30038c6bbdcb9d09a1cb99854d26b8131", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "11  \n 20 What is requirement engineering?  \n \nRequirement engineering is the process of establishing the services that the customer requires \nfrom the system and the constraints under which it operates and  \nis developed.  \n21 What are the various types of traceability in software engineering?  \n \ni. Source traceability \u2013 These are basically the links from requirement to stakeholders who \npropose these  requirements.  \n \nii . Requirements traceability \u2013 These are links between dependant  requirements.  \n \niii . Design traceability \u2013 These are links from requirements to  design.  \n22 If you have to develop a word processing software product, what process models will you \nchoose? Justify your answer. NOV/DEC 2016  \nWe will choose the incremental model for word processing  software. It focuses on  \n the aspects of the word processing software that are visible to the customer / end  \nuser. The feedback is used to refine the prototype.  \n23 What led to the transition from product to process oriented development in software \nengine ering? APR/MAY 2016  \n \nProduct techniques to designing software - Large numbers of software projects do not meet \ntheir expectations in terms of functionality, cost, or delivery schedule. Proces s - Composed of \nline practitioners who have varied skills, the group is at the center of the collaborative effort \nof everyone in the organization who is involved with software engineering process  \nimprovement.  \n \nProcess -oriented view on cooperating software components based on the concepts and \nterminology of a language/action perspective on cooperative work provides a more suitable \nfoundation for the analysis, design and implementation of software  \ncomponents in business applications.  \n12  \n 24 What are the advantag es and disadvantages of iterative software development model  \nNOV/DEC 2015  \nAdvantages  \n In iterative model we can only create a high -level design of the application before we \nactually begin to build the product and define the design solution for the entire  product.  \n Building and improving the product step by  step.  \n \n can get the reliable user  feedback  \n \n Less time is spent on documenting and more time is given for  designing.  \n \nDisadvantages  \n \n Each phase of an iteration is rigid with no overlaps  \n Costly system architec ture or design issues may arise because not all requirements are \ngathered up front for the entire  lifecycle  \n25 What are the issues in measuring the software size using LOC as metric NOV/DEC 2015, \nNOV/DEC 2017  \n \n\uf0b7 Lack of Accountability.  \n\uf0b7 Lack of Cohesion with  Functionality.  \n\uf0b7 Adverse Impact on  Estimation.  \n\uf0b7 Difference in Languages.  \n\uf0b7 Advent of GUI Tools  \n\uf0b7 Lack of Counting  Standards.  \n26 What is System Engineering? April/may 2018  \nSystem Engineering means designing, implementing, deploying and operating systems which \ninclude hardware, software and people.  \n27 What is the use of CMM? NOV/DEC2015  \nCapability Maturity Model is used in assessing how well an organization\u2019s  \nprocesses allow to complete and ma nage new software projects.  \n13  \n 28 What is meant by Software engineering paradigm?  \nThe development strategy that encompasses the process, methods and tools and generic phases \nis often referred to as a process model or software engineering  \nparadigm.  \n29 Define  agility and agile team. April /May  2015  \n\uf06e Agility -Effective (rapid and adaptive) response to change (team members, new \ntechnology,  requirements)  \n\uf06e Effective communication in structure and attitudes among all team members, \ntechnological and business people, so ftware engineers and managers \u3002 \n\uf06e Drawing the customer into the team. Eliminate \u201cus and them\u201d  attitude.  \nPlanning in an uncertain world has its limits and plan must be flexible.  \n\uf06e Organizing a team so that it is in control of the work  performed  \n\uf06e The development g uidelines stress delivery over analysis and design although these \nactivates are not discouraged, and active and  continuous  \n communication between developers and customers  \n\uf06e Eliminate all but the most essential work products and keep them  lean.  \nEmphasize an incremental delivery strategy as opposed to intermediate products that gets \nworking software to the customer as rapidly as  feasible  \n30 Write any two characteristics of software as a product. April /May 2015  \n1. Software is developed or engineered, it is not m anufactured in the classical  sense  \n2. Software doesn't \"wear  out.\"  \n3. Although the industry is moving toward component -based assembly, most software \ncontinues to be custom built.  \n31 Write the IEEE definition of software engineering .", "mimetype": "text/plain", "start_char_idx": 11272, "end_char_idx": 15915, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c5a590e6-1666-45e9-8bac-80410e976250": {"__data__": {"id_": "c5a590e6-1666-45e9-8bac-80410e976250", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e9400b64-c39b-4322-9e3a-833b07693f82", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a72a9979ec82634e2e3a2e3cc6129bb1ee62ba82f27060ba9f928d199829272f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6284572f-7815-45df-a826-663f5593a7d1", "node_type": "1", "metadata": {}, "hash": "a5d91005c46688b33db104174012079600e0af29e3887e640e7e94c34a6adef7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf06e Organizing a team so that it is in control of the work  performed  \n\uf06e The development g uidelines stress delivery over analysis and design although these \nactivates are not discouraged, and active and  continuous  \n communication between developers and customers  \n\uf06e Eliminate all but the most essential work products and keep them  lean.  \nEmphasize an incremental delivery strategy as opposed to intermediate products that gets \nworking software to the customer as rapidly as  feasible  \n30 Write any two characteristics of software as a product. April /May 2015  \n1. Software is developed or engineered, it is not m anufactured in the classical  sense  \n2. Software doesn't \"wear  out.\"  \n3. Although the industry is moving toward component -based assembly, most software \ncontinues to be custom built.  \n31 Write the IEEE definition of software engineering . NOV/DEC 2017  \nAccording to IEEE's definition software engineering can be defined as the \napplication of a systematic, disciplined, quantifiable approach to the development, operation, \nand maintenance of software , and the study of these approaches; that is, the application of \nengineeri ng to software . \n14  \n 32 List two deficiencies in waterfall model . Which process model do you suggest to \novercome each deficiency. APRIL/MAY 2017  \n\uf0b7 Once an application is in the testing  stage, it is very difficult to go back and change \nsomething that was not well -thought out in the concept  stage.  \n\uf0b7 No working software is produced until late during the life cycle.  \n33 What is Agile?  \nThe word \u2018agile\u2019 means \u2212  \n\uf0b7 Able to move your body quickly and  easily.  \n\uf0b7 Able to think quickly and  clearly.  \nIn business, \u2018agile\u2019 is used for describing ways of planning and doing work wherein it is \nunderstood that making changes as needed is an important part o f the job. Business\u2018agililty\u2019 \nmeans that a company is always in a position to take account of the market  changes.  \nIn software development, the term \u2018agile\u2019 is adapted to mean \u2018the  \nability to respond to changes \u2212 changes from Requirements, Technology and Pe ople.\u2019  \n34 What is Agile Manifesto?  \nThe Agile Manifesto states that \u2212  \nWe are uncovering better ways of developing software by doing it and helping others do it. \nThrough this work, we have come to value \u2212  \n\uf0b7 Individuals and interactions over processes and  tools. \n \n\uf0b7 Working software over comprehensive  documentation.  \n \n\uf0b7 Customer collaboration over contract  negotiation.  \n \n\uf0b7 Responding to change over following a  plan.  \nThat is, while there is value in the items on the right, we value the items on the left  more.  \n15  \n 35 What ar e the Characteristics of Agility?  \nfollowing are the characteristics of Agility \u2212  \n\uf0b7 Agility in Agile Software Development focuses on the culture of the whole team with multi -discipline, \ncross -functional teams that are empowered and  selforganizing.  \n\uf0b7 It fosters shared responsibility and  accounta bility.  \n \n\uf0b7 Facilitates effective communication and continuous  collaboration.  \n \n\uf0b7 The whole -team approach avoids delays and wait  times.  \n \n\uf0b7 Frequent and continuous deliveries ensure quick feedback that in in turn enable the team align to the  \nrequirements.  \n\uf0b7 Collabora tion facilitates combining different perspectives timely in implementation, defect fixes and \naccommodating  changes.  \n36 What are the principles of of agile methods? Customer \ninvolvement  \nCustomers should be closely involved throughout the development proces s. Their role  \nis provide and prioritize new system requirements and to evaluate the iterations of the  \n System.  \nIncremental delivery  \nThe software is developed in increments with the customer specifying the requirements to be included in each \nincrement.  \nPeople not process  \nThe skills of the development team should be recognized and exploited. Team members should be left to \ndevelop their own ways of working without prescriptive processes.  \nEmbrace  change  \nExpect the system requirements to change and so design th e system to accommodate these changes.  \nMaintain simplicity  \nFocus on simplicity in both the software being developed and in the development process. Wherever \npossible, actively work to eliminate complexity from the system.  \n37 What are the Problems with agi le methods?  \n \n\uf0b7 It can be difficult to keep the interest of customers who are involved in the  process.  \n\uf0b7  Team members may be unsuited to the intense involvement that characterizes agile methods.  \n\uf0b7 Prioritizing changes can be difficult where there are multiple  stakeholders . \n\uf0b7 Maintaining simplicity requires extra  work.  \n\uf0b7 Contracts may be a problem as with other approaches to iterative  development.", "mimetype": "text/plain", "start_char_idx": 15051, "end_char_idx": 19748, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6284572f-7815-45df-a826-663f5593a7d1": {"__data__": {"id_": "6284572f-7815-45df-a826-663f5593a7d1", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c5a590e6-1666-45e9-8bac-80410e976250", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "3c4309adb267750364d7c6e6c9fcb96d9db00cff18711244ab382b36733fe415", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bee753c9-767e-4a9b-9c26-be8c2c94c0e5", "node_type": "1", "metadata": {}, "hash": "d18e67e46c300ada690f54733a0377c257c28ca3d54f51cb130795083518e4c6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "People not process  \nThe skills of the development team should be recognized and exploited. Team members should be left to \ndevelop their own ways of working without prescriptive processes.  \nEmbrace  change  \nExpect the system requirements to change and so design th e system to accommodate these changes.  \nMaintain simplicity  \nFocus on simplicity in both the software being developed and in the development process. Wherever \npossible, actively work to eliminate complexity from the system.  \n37 What are the Problems with agi le methods?  \n \n\uf0b7 It can be difficult to keep the interest of customers who are involved in the  process.  \n\uf0b7  Team members may be unsuited to the intense involvement that characterizes agile methods.  \n\uf0b7 Prioritizing changes can be difficult where there are multiple  stakeholders . \n\uf0b7 Maintaining simplicity requires extra  work.  \n\uf0b7 Contracts may be a problem as with other approaches to iterative  development.  \n16  \n 38 What is Extreme Programming?  \nXP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop a software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development me thodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self-organize. \nExtreme Programming provides specific core practices where  \u2212 \n\uf0b7 Each practice is simple and  self-complete.  \n \n\uf0b7 Combination of practices produces mor e complex and emergent behavior.  \n39 HOW Embrace Change happens in Extreme programming?  \nA key assumption of Extreme Programming is that the cost of changing a program can be held \nmostly constant over time.  \nThis can be achieved with \u2212  \n\uf0b7 Emphasis on continuous  feedback from the  customer  \n \n\uf0b7 Short  iterations  \n \n\uf0b7 Design and  redesign  \n \n\uf0b7 Coding and testing  frequently  \n \n\uf0b7 Eliminating defects early, thus reducing  costs  \n \n\uf0b7 Keeping the customer involved throughout the development  \n \n\uf0b7 Delivering working product to the  customer  \n17  \n 40 How Extreme Programming usedin a Nutshell?  \nExtreme Programming involves \u2212  \n\uf0b7 Writing unit tests before programming and keeping all of the tests running at all times. The \nunit tests are automated and eliminate defects early, thus reducing the costs.  \n\uf0b7 Starting with a simple design just enough to code the  features at hand and redesigning when  \nrequired.  \n\uf0b7 Programming in pairs (called pair programming), with two programmers at one screen, \ntaking turns to use the keyboard. While one of them is at the keyboard, the other constantly \nreviews and provides  inputs.  \n\uf0b7 Integrating and testing the whole system several times a  day. \n41 Why is it called \u201cExtreme?  \nExtreme Programming takes the effective principles and practices to extreme levels.  \n \n \uf0b7 Code reviews are effective as the code is reviewed all the  time.  \n \n\uf0b7 Testing is effective as there is continuous regression and  testing.  \n \n\uf0b7 Design is effective as everybody needs to do refactoring  daily.  \n \n\uf0b7 Integration testing is important as integrate and test several times a day.  \n\uf0b7 Short iterations are effective as the planning game for r elease planning and iteration  planning.  \n18  \n 42 What are the E xtreme Programming Advantages?  \nExtreme Programming solves the following problems often  faced  \nin the software development projects \u2212  \n\uf0b7 Slipped schedules \u2212 and achievable development cycles  ensure  \ntimely deliveries.  \n \n\uf0b7 Cancelled projects \u2212 Focus on continuous customer involvement ensures transparency with the \ncustomer and immediate resolution of any  issues. \n\uf0b7 Costs incurred in changes \u2212 Extensive and ongoing testing makes sure the changes do not break the \nexisting functionality. A running working system always ensures sufficient time for accommodating \nchanges such that the current operations are not  affect ed. \n\uf0b7 Production and post -delivery defects: Emphasis is on \u2212 the  unit \ntests to detect and fix the defects early.  \n43 What is Scrum ?  \nThe Scrum approach is a general agile method but its focus is on managing iterative \ndevelopment rather than specific agile pr actices. There are three phases in Scrum:  \n \n1.  The initial phase is an outline planning phase where you establish the general \nobjectives for the project and design the software  architecture.  \n2. This is followed by a series of sprint cycles, where each cycle deve lops an \n increment of the system.  \n3.  The project closure phase wraps up the project, completes required documentation \nsuch as system help frames and user manuals and assesses  the lessons learned from the  \nproject.  \n19  \n 44 What are the Advantages of scrum ?", "mimetype": "text/plain", "start_char_idx": 18803, "end_char_idx": 23598, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bee753c9-767e-4a9b-9c26-be8c2c94c0e5": {"__data__": {"id_": "bee753c9-767e-4a9b-9c26-be8c2c94c0e5", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6284572f-7815-45df-a826-663f5593a7d1", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f4fe093d05e935c4b86db62e17e432eb802826ff6ca06b4cd9a86028348e1c00", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a", "node_type": "1", "metadata": {}, "hash": "d5420ee4cc735bec57371ae34bd434f28f9323424e40085e4b6a5de7a37524d4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Production and post -delivery defects: Emphasis is on \u2212 the  unit \ntests to detect and fix the defects early.  \n43 What is Scrum ?  \nThe Scrum approach is a general agile method but its focus is on managing iterative \ndevelopment rather than specific agile pr actices. There are three phases in Scrum:  \n \n1.  The initial phase is an outline planning phase where you establish the general \nobjectives for the project and design the software  architecture.  \n2. This is followed by a series of sprint cycles, where each cycle deve lops an \n increment of the system.  \n3.  The project closure phase wraps up the project, completes required documentation \nsuch as system help frames and user manuals and assesses  the lessons learned from the  \nproject.  \n19  \n 44 What are the Advantages of scrum ?  \n \n\uf0b7  The product is broken down into a set of manageable and understandable chunks . \n\uf0b7 Unstable requirements do not hold up progress . \n\uf0b7  The whole team has visibility of everything and consequently team \ncommunication is improved.  \n\uf0b7  Customers see on-time delivery of increments and gain feedback on  how the \nproduct  works.  \n\uf0b7  Trust between customers and developers is established and a positive culture is \ncreated in which everyone expects the project to  succeed.  \n45. Mention the Two perspectives on scaling of agile methods?  \n1. Scaling  up \n2. Scaling  out \n46. What is Scaling up  \nUsing agile methods for developing large software systems that cannot be developed by a \nsmall team. For large systems development, it is not possible to focus only on the code of the \nsystem; you need to do mor e up- front design and system documentation. Cross -team \ncommunication mechanisms have to be designed and used, which should involve regular phone \nand video conferences between team members and frequent, short electronic meetings where \nteams update each oth er on progress. Continuous integration, where the whole system is built \nevery time any developer checks in a change, is practically impossible; however, it is essential  \nto maintain  frequent  system  builds  and regular  releases  of the \nsystem.  \n47. What is Scaling out.  \nHow agile methods can be introduced across a large organization with many years of software \ndevelopment experience. Project managers who do not have experience of agile methods may \nbe reluctant to accept the risk of a new approach. Large organiza tions often have quality \nprocedures and standards that all projects are expected to follow and, because of their \nbureaucratic nature, these are likely to be incompatible with agile methods. Agile methods \nseem to work best when team members have a relativel y high skill level. However, within large  \norganizations,  \nthere are likely to be a wide range of skills and abilities.  \n20  \n \n \n \n \n \n \n48.  \n \n \n \n \nDraw the diagram of Extreme programming?  \n49 What is a gile development?  \nSpecification, design, implementation and testing a re inter -leaved and the outputs from the \ndevelopment process are decided through a process of negotiation during the software \ndevelopment process.  \nprojects include elements of plan -driven and agile processes. Deciding on the balance depends \non many technic al, human, and organizational issues . \n50. What is Scrum master?  \nThe role of the Scrum Master is to protect the development team from external distractions. At \nthe end of the sprint the work done is reviewed and presented to  \nstakeholders (including the pro duct owner).  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n21  \n PART \u2013B \n \n \n \n \n \n1 Explain  the  following:  (i)  waterfall  model  (ii)  Spiral  model  \n(iii)RAD   model   (iv)  Prototyping  model.  NOV/DEC -12, \nNOV/DEC -15, \n\uf0b7 A Project management methodology based on a  sequential design  proces s \n\uf0b7 Finishes one phase before another phase can  begin \n \n\uf0b7 SDLC  Model  \n \n\uf0b7 Linear Sequential  Model  \n \n\uf0b7 Simple to understand and easy to  implement  \nWaterfall model phases  \n There are separate identified phases in the waterfall  model:  \n1. Requirements analysis and  definition  \n2. System and software  design  \n3. Implementation and unit  testing  \n4. Integration and system  testing  \n5. Operation and  maintenance  \n The main drawback of the waterfall model is the difficulty of accommodating change after the \nprocess is underway. In principle, a phase has t o be complete before moving onto the next  phase.  \n(ii)SPIRAL MODEL  \nThe spiral model is divided into number of frame works. These frameworks are  \n22  \n denoted by task regions.", "mimetype": "text/plain", "start_char_idx": 22800, "end_char_idx": 27327, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a": {"__data__": {"id_": "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bee753c9-767e-4a9b-9c26-be8c2c94c0e5", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "37ee44dec0a027e0d597ceff5bd6e401d2cbe1c3aee637fab21c2683d71c4190", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "06607e52-c67e-4b9b-8888-d67eaf66b14c", "node_type": "1", "metadata": {}, "hash": "6d01d8b0c1e1f80c03d6e4e2bb19ef6e81c897fb75fdab3fec6a706946fc8740", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Requirements analysis and  definition  \n2. System and software  design  \n3. Implementation and unit  testing  \n4. Integration and system  testing  \n5. Operation and  maintenance  \n The main drawback of the waterfall model is the difficulty of accommodating change after the \nprocess is underway. In principle, a phase has t o be complete before moving onto the next  phase.  \n(ii)SPIRAL MODEL  \nThe spiral model is divided into number of frame works. These frameworks are  \n22  \n denoted by task regions.  \nUsually there are six task regions. In spiral model project entry point axis is  \ndefined.  \nThe task regions are:  \n1. Customer communication ,Planning Risk analysis., Engineering, Construct and release and \nCustomer evaluation.  \n\uf0b7 Drawbacks  \n1. It is based on customer communication.  \n2. It demands considerable risk assessment.  \n \n \n \n \n \n \n \n \nIt was original ly proposed by Barry Boehm, the spiral model is an evolutionary \nsoftware process model that couples the iterative nature of prototyping with the \ncontrolled and systematic aspects of the waterfall  model.  \n23  \n \n It provides the potential for rapid development of increasingly more  complete versions of the software.  \n The spiral  model  can be adopted  to apply  throughout  the entire  lifecycle  of the \napplication from concept development to  maintenance.  \n The spiral model is divided into set of framework activities defined by  software \nengineering  team.  \n The initial activity is shown from centre and developed in  clockwise direction.  \n \nAdvantages  \n\uf0b7 In this approach, the project monitoring is easy  and more  effective compared  to other  models.  \n\uf0b7 It reduces the number of risk in software  development before they become serious  problem.  \n\uf0b7 Suitable for very high  risk. \n\uf0b7 Schedule and cost is more  realistic.  \n\uf0b7 Risk management is in -built in the spiral  model.  \n\uf0b7 Changes can be accommodated in th e later   \n\uf0b7 stages  \n \n(iii) RAD Model  \nRAD or Rapid Application Development process is an adoption of the waterfall model; it targets at \ndeveloping software in a short span of time. RAD follows the iterative  \nSDLC RAD model has following phases  \niv. Business Modeling  \nv. Data Modeling  \nvi . Process Modeling  \nvii . Application Generation  \nviii . Testing and Turnover  \n24  \n \n \niv) Prototyping Model  \n Prototype methodology is defined as a Software Development model in which a prototype is built, \ntest, and then reworked when needed until an acceptable pr ototype is achieved. It also creates a base to \nproduce the final system.  \nSoftware prototyping model works best in scenarios where the project's requirements are not known. It is \nan iterative, trial, and error method which take place between the developer a nd the client  \n \nOften, a customer defines a set of general objectives for sof tware,  but does not identify detailed \nrequirements for functions and features.  \n In this case Prototyping is best suited  \n Prototyping can be used together with other models for e licitation requirements  \n The prototype can serve as \u201cthe first system.\u201d  \n Some prototypes are \u201cThrow Away\u201d while others also evolve become part of the actual \nsystem.  \n Both customers and developers like the prototyping paradigm.  \ni. Customer/End user gets a f eel for the actual  system  \n25  \n ii. Developer get to build something  immediately.  \n2 Discuss the various life cycle models in software development? APR/MAY -16 \n\uf0b7 The Software Development Lifecycle (SDLC)  is a systematic process for building software that \nensures the q uality and correctness of the software built.  \n\uf0b7 SDLC process aims to produce high -quality software which meets customer expectations.  \n\uf0b7 The system development should be complete in the pre -defined time frame and cost.  \nDLC consists of a detailed plan which ex plains how to plan, build, and maintain specific software. Every \nphase of the SDLC lifecycle has its own process and deliverables that feed into the next phase.  \n \n\uf0b7 Phase 1: Requirement collection and analysis  \n\uf0b7 Phase 2: Feasibility study:  \n\uf0b7 Phase 3: Design:  \n\uf0b7 Phase 4: Coding:  \n\uf0b7 Phase 5: Testing:  \n\uf0b7 Phase 6: Installation/Deployment:  \n\uf0b7 Phase 7: Maintenance:  \nPhase 1: Requirement collection and analysis:  \nThe requirement is the first stage in the SDLC process. It is conducted by the senior team members with \ninputs from all th e stakeholders and domain experts in the industry. Planning for the quality assurance \n26  \n requirements and recognization of the risks involved is also done at this stage.", "mimetype": "text/plain", "start_char_idx": 26823, "end_char_idx": 31359, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "06607e52-c67e-4b9b-8888-d67eaf66b14c": {"__data__": {"id_": "06607e52-c67e-4b9b-8888-d67eaf66b14c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1c5f9951b2cdbd54e59c678916a744b54ac3cae2b8eae42ac90ed1535f2867e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04", "node_type": "1", "metadata": {}, "hash": "ec9c08565c5c22d8f8c8a172d536766bef8fd1f9d8fb032df5f7a7719c5567e2", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "DLC consists of a detailed plan which ex plains how to plan, build, and maintain specific software. Every \nphase of the SDLC lifecycle has its own process and deliverables that feed into the next phase.  \n \n\uf0b7 Phase 1: Requirement collection and analysis  \n\uf0b7 Phase 2: Feasibility study:  \n\uf0b7 Phase 3: Design:  \n\uf0b7 Phase 4: Coding:  \n\uf0b7 Phase 5: Testing:  \n\uf0b7 Phase 6: Installation/Deployment:  \n\uf0b7 Phase 7: Maintenance:  \nPhase 1: Requirement collection and analysis:  \nThe requirement is the first stage in the SDLC process. It is conducted by the senior team members with \ninputs from all th e stakeholders and domain experts in the industry. Planning for the quality assurance \n26  \n requirements and recognization of the risks involved is also done at this stage.  \nThis stage gives a clearer picture of the scope of the entire project and the anticipated  issues, opportunities, \nand directives which triggered the project.  \nRequirements Gathering stage need teams to get detailed and precise requirements. This helps companies to \nfinalize the necessary timeline to finish the work of that system.  \nPhase 2: Feasib ility study:  \nOnce the requirement analysis phase is completed the next step is to define and document software needs. \nThis process conducted with the help of 'Software Requirement Specification' document also known as 'SRS' \ndocument. It includes everything  which should be designed and developed during the project life cycle.  \nThere are mainly five types of feasibilities checks:  \n\uf0b7 Economic:  Can we complete the project within the budget or not?  \n\uf0b7 Legal:  Can we handle this project as cyber law and other regulatory framework/compliances.  \n\uf0b7 Operation feasibility:  Can we create operations which is expected by the client?  \n\uf0b7 Technical:  Need to check whether the current computer system can support the software  \n\uf0b7 Schedule:  Decide that the project can be completed within the give n schedule or not.  \nPhase 3: Design:  \nIn this third phase, the system and software design documents are prepared as per the requirement \nspecification document. This helps define overall system architecture.  \nThis design phase serves as input for the next phas e of the model.  \nThere are two kinds of design documents developed in this phase:  \nHigh -Level Design (HLD)  \n(a) Brief description and name of each module  \n(b) An outline about the functionality of every module  \n(c) Interface relationship and dependencies between modules  \n(d) Database tables identified along with their key elements  \n(e) Complete architecture diagrams along with technology details  \nLow-Level Design(LLD)  \n\uf0b7 Functional logic of the modules  \n27  \n \uf0b7 Database tables, which include type and size  \n\uf0b7 Complete detail of the interface  \n\uf0b7 Addresse s all types of dependency issues  \n\uf0b7 Listing of error messages  \n\uf0b7 Complete input and outputs for every module  \nPhase 4: Coding:  \nOnce the system design phase is over, the next phase is coding. In this phase, developers start build the \nentire system by writing code using the chosen programming language. In the coding phase, tasks are \ndivided into units or modules and assigned to the various developers. It is the longest phase of the Software \nDevelopment Life Cycle process.  \nIn this phase, Developer needs to follow cer tain predefined coding guidelines. They also need to use \nprogramming tools like compiler, interpreters, debugger to generate and implement the code.  \nPhase 5: Testing:  \nOnce the software is complete, and it is deployed in the testing environment. The testing  team starts testing \nthe functionality of the entire system. This is done to verify that the entire application works according to the \ncustomer requirement.  \nDuring this phase, QA and testing team may find some bugs/defects which they communicate to develop ers. \nThe development team fixes the bug and send back to QA for a re -test. This process continues until the \nsoftware is bug -free, stable, and working according to the business needs of that system.  \nPhase 6: Installation/Deployment:  \nOnce the software testin g phase is over and no bugs or errors left in the system then the final deployment \nprocess starts. Based on the feedback given by the project manager, the final software is released and \nchecked for deployment issues if any.  \nPhase 7: Maintenance:  \nOnce the s ystem is deployed, and customers start using the developed system, following 3 activities occur  \n\uf06e Bug fixing - bugs are reported because of some scenarios which are not tested at all  \n\uf06e Upgrade - Upgrading the application to the newer versions of the Software  \n\uf06e Enhancement - Adding some new features into the existing software  \n3 What is the difference between information engineering & product engineering?", "mimetype": "text/plain", "start_char_idx": 30598, "end_char_idx": 35347, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04": {"__data__": {"id_": "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "06607e52-c67e-4b9b-8888-d67eaf66b14c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "05eb74e4165685ae01b66be80509343ed00bd64586b140611ab15bb73cb7c7d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760", "node_type": "1", "metadata": {}, "hash": "0544cef42f5f378ef0e5affc89a28f47667dd2fe0e12df1018011d30f419065d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The development team fixes the bug and send back to QA for a re -test. This process continues until the \nsoftware is bug -free, stable, and working according to the business needs of that system.  \nPhase 6: Installation/Deployment:  \nOnce the software testin g phase is over and no bugs or errors left in the system then the final deployment \nprocess starts. Based on the feedback given by the project manager, the final software is released and \nchecked for deployment issues if any.  \nPhase 7: Maintenance:  \nOnce the s ystem is deployed, and customers start using the developed system, following 3 activities occur  \n\uf06e Bug fixing - bugs are reported because of some scenarios which are not tested at all  \n\uf06e Upgrade - Upgrading the application to the newer versions of the Software  \n\uf06e Enhancement - Adding some new features into the existing software  \n3 What is the difference between information engineering & product engineering? Also explain the \nproduct engineering hierarchy in detail.  MAY/JUN -13 \n28  \n Product engineering   \n\uf0b7 It refers to the pro cess of designing and developing a device, assembly, or system such that it is \nproduced as an item for sale through some production  manufacturing  process.  \n\uf0b7 Product  engineering  usually entails activity dealing with issues of cost, producibility, quality, \nperformance, reliability, serviceability, intended lifespan and user features.  \n\uf0b7 These product characteristics are generally all sought in the attempt to make the resulting product \nattractive to its intended  market  and a successful contributor to the business  of the organization that \nintends to offer the product to that market.  \n\uf0b7  It includes design, development and transitioning to manufacturing of the product. The term \nencompasses developing the concept of the product and the design and development of its \nmech anical, electronics and  software  components.  \n\uf0b7  After the initial design and development is done, transitioning the product to manufacture it in \nvolumes is considered part  of product engineering.  \n\uf0b7 Product engineers are the technical interface between the comp onent development team and the \nproduction side (Front End and Back End), especially after the development phase and qualifications \nwhen the high volume production is running.  \n\uf0b7 Product engineers improve the product quality and secure the product reliability by balancing the \ncost of tests and tests coverage that could impact the production fall -off. They support failure \nanalysis request from customers.  \n\uf0b7 For example, the engineering of a  digital camera  would include defining the feature set, design of the \noptics , the mechanical and  ergonomic design  of the packaging, developing the electronics that \ncontrol the various component and developing the software that allows the user to see the pictures, \nstore them in memory and download them to a  computer . \n\uf0b7 Product engine ering is an  engineering  discipline that deals with both design \nand manufacturing  aspects of a product.  \nThe job requires the product engineer to have a very good working knowledge of:  \n\uf0b7 Statistical methods and tools  \n\uf0b7 Manufacturing process  \n\uf0b7 Software, hardware an d systems implementation  \n\uf0b7 Product reliability and qualification  \n\uf0b7 Physical analysis methods  \n\uf0b7 Computer -aided design  and simulation programs  \n\uf0b7 Specific technology  \n\uf0b7 Strong product Knowledge  \n29  \n  \uf0b7 Strong analytic work methodology and problem solving skills  \n\uf0b7 Continuous Impro vement Knowledge  \nInformation engineering  (IE) \n\uf0b7 It also known as  Information technology engineering  (ITE), information engineering \nmethodology  (IEM ) or data engineering , is a software engineering  approach to designing and \ndeveloping  information systems . \n\uf0b7 Information technology engineering involves an architectural approach for planning, analyzing, \ndesigning, and implementing applications.  \n\uf0b7 It has been defined by Steven M Davis as: \"An integrated and evolutionary set of tasks and \ntechniques that enhance busines s communication throughout an enterprise enabling it to develop \npeople, procedures and systems to achieve its vision  \nThere are two variants of information technology engineering. These are called the DP -driven variant and \nthe business -driven variant.  \n\uf0b7 DP-driven:  The DP -driven variant of information technology engineering was designed to enable IS \nDepartments to develop information systems that satisfied the information needs of the 1980s - \nwhich was largely a DP -driven development environment. Most of the CA SE tools available today \nsupport this DP -driven variant of ITE.  \ni. Business -driven:  ITE was extended into strategic business planning for the business -driven variant \nof information technology engineering. This variant was designed for rapid change in the clie nt/server, \nobject -oriented environment of the business -driven 1990's.  \nBTL6  \n4 (a ) List the principles of agile software development.", "mimetype": "text/plain", "start_char_idx": 34411, "end_char_idx": 39370, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760": {"__data__": {"id_": "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a5710797cc3bc01de2e185abe042d2394867b3342a57565f18b2814268697610", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e8fe1fc0-cc49-44f2-9bd9-7c030716d637", "node_type": "1", "metadata": {}, "hash": "9c27082dc9f5fb0251cd3fa353ad1206f0a29f07293ed6a82bbc7ec8fe16fe06", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These are called the DP -driven variant and \nthe business -driven variant.  \n\uf0b7 DP-driven:  The DP -driven variant of information technology engineering was designed to enable IS \nDepartments to develop information systems that satisfied the information needs of the 1980s - \nwhich was largely a DP -driven development environment. Most of the CA SE tools available today \nsupport this DP -driven variant of ITE.  \ni. Business -driven:  ITE was extended into strategic business planning for the business -driven variant \nof information technology engineering. This variant was designed for rapid change in the clie nt/server, \nobject -oriented environment of the business -driven 1990's.  \nBTL6  \n4 (a ) List the principles of agile software development.  NOV/DEC 2016  \n1. It describes a set of principles for software development  where,  \nRequirements  and solutions  evolve  through  the collaborative  effort  of self- \n(b) organizing + cross -functional teams  \n(c) It advocates  \nAdaptive  planning  \n1. Evolutionary  development  \n2. Early  delivery  \n3. Continuous  improvement  \n4. Encourages rapid and flexible response to  change  \n(d) These principles support the definition and cont inuing evolution of many software development \nmethods  \n30  \n  (e ) Every project needs to be handled differently  \nExisting methods need to be tailored  to best suit the project requirements  \n(f) Tasks are  divided to time boxes (small time frames) to deliver specific feature s for a  release  \n(g ) Iterative approach is taken &  working software build is delivered after each  iteration  \n(h) Agile Model Pros and Cons  \n(i )  It widely accepted in the software world  recently, however, this method may not always be suitable for all \nproducts.  \n(j)  \n(k) Pros  (l ) Cons \n(m ) Is a very realistic approach to software  \ndevelopment  \n(n) Promotes teamwork and cross  training.  \n(o ) Functionality can be developed rapidly  \nanddemonstrated.  \n(p) Resource requirements are  minimum.  \n(q) Suitable  for fixed  or changing  \nrequirements  \n(r ) Delivers early partial  workingsolutions.  \n(s ) Good  model  for environments  that \nchange  steadily.  \n(t) Minimal  rules,  documentation  easily  \nemployed.  \n(u) Enables concurrent development and \ndelivery within  an \n(v ) overall planned context.  \n(w ) Little or no planning  required  \n(x ) Easy to  manage  \n(y ) Gives flexibility t o developers  (z ) Not suitable  for handling  complex  \ndependencies.  \n(aa ) More  risk of sustainability,  \nmaintainability  and extensibility.  \n(bb) An overall plan, an agile leader and agile \nPM practice is  a \n(cc ) must without which it will not work.  \n(dd) Strict delivery management dictate s the \nscope, functionality to be delivered, and \nadjustments to meet the deadlines.  \n(ee ) Depends  heavily  on customer  interaction,  \nso if customer  is not clear, team can be \ndriven in the wrong  direction.  \n(ff) There is very high individual dependency, \nsince there is min imum documentation  \ngenerated.  \n(gg ) Transfer  of technology  to new team  \nmembers  may be quite  challenging  due \nto lack of documentation.  \n(hh)  \n(i i )  \n(jj)  \n(kk)  \n \n(l l )  \n(mm)  \n \n31  \n \u2022 \n \n \n \n(nn)  \n(oo )  \n(pp)  \n(qq)  \n(rr )  \n(ss )  \n(tt)  \n(uu)  \n(vv )  \n(ww ) Each build is incremental in terms  of features  \n(xx ) Final  build  holds  all the features required by the  customer  \n(yy ) Agile Principles  \n(zz )  The Agile Manifesto is based on twelve principles  \n1. Customer satisfaction by early and continuous delivery of valuable  software  \n2. Welcome changing requirements, even in late  development  \n3. Working software is delivered frequently (weeks rather  than months)  \n4. Close, daily cooperation between business people and  developers  \n5. Projects are built around motivated individuals, who should be  trusted  \n6. Face-to-face conversation is the best form of communication  (co-location)  \n7. Working software is the principal  measure of  progress  \n8. Sustainable development, able to maintain a constant  pace \n9.", "mimetype": "text/plain", "start_char_idx": 38617, "end_char_idx": 42658, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e8fe1fc0-cc49-44f2-9bd9-7c030716d637": {"__data__": {"id_": "e8fe1fc0-cc49-44f2-9bd9-7c030716d637", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "13a52da9974709524143616b7f224f9bc6290c3362956a050c8f1edd581a1800", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f126d84f-d078-45b5-ac88-cc45423d1ad3", "node_type": "1", "metadata": {}, "hash": "91ad599c326a14edadacb19ccced7f0571cbd6483d160c7e9655dc9251b72e02", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Customer satisfaction by early and continuous delivery of valuable  software  \n2. Welcome changing requirements, even in late  development  \n3. Working software is delivered frequently (weeks rather  than months)  \n4. Close, daily cooperation between business people and  developers  \n5. Projects are built around motivated individuals, who should be  trusted  \n6. Face-to-face conversation is the best form of communication  (co-location)  \n7. Working software is the principal  measure of  progress  \n8. Sustainable development, able to maintain a constant  pace \n9. Continuous attention to technical excellence and good  design  \n10.Simplicity \u2014the art of maximizing the amount of work not done \u2014is essential  \n11.Best architectures, requirements, and desi gns emerge from self -organizing  teams \n12.Regularly, the team reflects on how to become more effective, and adjusts  accordingly  \n \n \n32  \n 5 Write note on business process engineering and product engineering? MAY/JUN -13 , APRIL/MAY -\n15 \nBusiness Engineering  \ni. Business pro cess engineering is a way in which organizations study their current business processes \nand develop new methods to improve productivity, efficiency, and operational costs.  \nii.  As a business process engineer, you will examine the way an organization operates, its long -term \nperformance goals, and recommend ways it can work more seamlessly to achieve overall improvement.  \ni i i. Many business process engineers work as consultants contracted by companies seeking \nimprovements to their methodology and infrastructure.  \nProdu ct engineering   \n4. It refers to the process of designing and developing a device, assembly, or system such that it is produced \nas an item for sale through some production  manufacturing  process.  \n5. Prod uct engineering  usually entails activity dealing with issues of cost, reducibility, quality, \nperformance, reliability, serviceability, intended lifespan and user features.  \n6. These product characteris tics are generally all sought in the attempt to make the resulting product \nattractive to its intended  market  and a successful contributor to the business of the organization that \nintends to o ffer the product to that market.  \n7.  It includes design, development and transitioning to manufacturing of the product. The term \nencompasses developing the concept of the product and the design and development of its mechanical, \nelectronics and  software  components.  \n8.  After the initial design and development is done, transitioning the product to manufacture it in volumes \nis considered part  of product engineering.  \n9. Product engineers are the technical interface  between the component development team and the \nproduction side (Front End and Back End), especially after the development phase and qualifications \nwhen the high volume production is running.  \n10. Product engineers improve the product quality and secure the pro duct reliability by balancing the \ncost of tests and tests coverage that could impact the production fall -off. They support failure analysis \nrequest from customers.  \n11. For example, the engineering of a  digital camera  would include defining the feature set, design of the \noptics, the mechanical and  ergonomic design  of the packaging, developing the electronics that control the \nvarious compone nt and developing the software that allows the user to see the pictures, store them in \nmemory and download them to a  computer . \n12. Product engineering is an  engineering  discipline that deals with both design \nand manufacturing  aspects of a product.  \nThe job requires the product engineer to have a very good working knowledge of:  \nii. Statistical met hods and tools  \n33  \n iii. Manufacturing process  \niv. Software, hardware and systems implementation  \nv. Product reliability and qualification  \nvi. Physical analysis methods  \nvii. Computer -aided design  and simulation prog rams  \nviii. Specific technology  \nix. Strong product Knowledge  \nx. Strong analytic work methodology and problem solving skills  \nxi. Continuous Improvement Knowledge  \n6 Explain in detail about spiral model with a neat sketch and describe why this model comes under \nboth evolution ary and RAD models. APRIL/MAY -15, NOV/DEC 2017  \nREFER PART B Q1  \n7 Which process model is best suited for risk management? Discuss in detail with an example. Give its \nadvantages and disadvantages? NOV/DEC 2016,APRIL/MAY 2018  \nThere are two characteristics of  risk i.e. uncertainty and loss.  \n \nFollowing are the categories of the risk:  \n \n1. Project risk  \n1. If the project risk is real then it is probable that the project schedule will slip and the cost of the \nproject will increase.  \n2.", "mimetype": "text/plain", "start_char_idx": 42090, "end_char_idx": 46795, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f126d84f-d078-45b5-ac88-cc45423d1ad3": {"__data__": {"id_": "f126d84f-d078-45b5-ac88-cc45423d1ad3", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e8fe1fc0-cc49-44f2-9bd9-7c030716d637", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4ca71cd5892e654d7a8150060e6612d5298bf1a4793c4801a5b8fb95ddf3e0be", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f5723f22-83cc-491d-b119-a74c448dceaa", "node_type": "1", "metadata": {}, "hash": "0e8d68ec7fb43c00e9903649f5253ca07d34618f7b8f5a2578343e8c2f5324a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Specific technology  \nix. Strong product Knowledge  \nx. Strong analytic work methodology and problem solving skills  \nxi. Continuous Improvement Knowledge  \n6 Explain in detail about spiral model with a neat sketch and describe why this model comes under \nboth evolution ary and RAD models. APRIL/MAY -15, NOV/DEC 2017  \nREFER PART B Q1  \n7 Which process model is best suited for risk management? Discuss in detail with an example. Give its \nadvantages and disadvantages? NOV/DEC 2016,APRIL/MAY 2018  \nThere are two characteristics of  risk i.e. uncertainty and loss.  \n \nFollowing are the categories of the risk:  \n \n1. Project risk  \n1. If the project risk is real then it is probable that the project schedule will slip and the cost of the \nproject will increase.  \n2. It identifies the potential schedule , resource, stakeholders and the requirements problems and their \nimpact on a software project.  \n2. Technical risk  \n\uf0b7 If the technical risk is real then the implementation becomes impossible.  \n\uf0b7 It identifies potential design, interface, verification and maintenan ce of the problem.  \n3. Business risk  \nIf the business risk is real then it harms the project or product.  \n \nThere are five sub -categories of the business risk:  \n \n1. Market risk - Creating an excellent system that no one really wants.  \n2. Strategic risk - Creatin g a product which no longer fit into the overall business strategy for companies.  \n3. Sales risk - The sales force does not understand how to sell a creating product.  \n4. Management risk - Loose a support of senior management because of a change in focus.  \n5. Budget risk - losing a personal commitment.  \n34  \n Other risk categories  \nThese categories suggested by Charette.  \n \n1. Known risks :  These risk are unwrapped after the project plan is evaluated.  \n2. Predictable risks :  These risks are estimated from previous projec t experience.  \n3. Unpredictable risks :  These risks are unknown and are extremely tough to identify in advance.  \nPrinciples of risk management  \nMaintain a global perspective - View software risks in the context of a system and the business problem \nplanned to solve.  \n \nTake a forward looking view \u2013 Think about the risk which may occur in the future and create future plans \nfor managing the future events.  \n \nEncourage open communication \u2013 Encourage all the stakeholders and users for suggesting risks at any \ntime.  \n \nIntegrate \u2013 A consideration of risk should be integrated into the software process.  \n \nEmphasize a continuous process \u2013 Modify the identified risk than the more information is known and add \nnew risks as better insight is achieved.  \n \nDevelop a shared product visi on \u2013 If all the stakeholders share the same vision of the software then it is \neasier for better risk identification.  \n \nEncourage teamwork \u2013 While conducting risk management activities pool the skills and experience of all \nstakeholders.  \nRisk Identification  \nIt is a systematic attempt to specify threats to the project plans.  \n \nTwo different types of risk:  \n \n1. Generic risks  \no These risks are a potential threat to each software project.  \n2.  Product -specific risks  \n- These risks are recognized by those with a clear unde rstanding of the technology, the people and the \nenvironment which is specific to the software that is to be built.  \n- A method for recognizing risks is to create item checklist.  \n \n35  \n 8 Consider 7 functions with their estimated lines of code. Average productivity  based on historical \ndata is 620 LOC/pm and  labour  rate is Rs. 8000  per mnth.  Find  the total  estimates  \nproject cost and effort?  F1 \u2013 2340 , F2 \u2013 5380, F3 \u2013 6800 , F4 \u20133350 , F5 -4950 , F6 -2140 , F7 \u2013 8400  \n  \nThere are many techniques that can be used to rigorously estimate or measure effortand cost \nfor a software project, such as:  \n-Function Point (FP)  \n-Source Lines of Code (SLOC).  \n-COnstructive COst MOdel (COCOMO)  \n -Delphi  \n SLOC Technique(Source Line of Code Technique) -The SLOC technique is an objecti ve \nmethod of estimating or calculating the size of the project.  \n-The project size helps determine the resources, effort, cost, and duration required to \ncomplete the project.  \n -It is also used to directly calculate the effort to be spent on a project.  \n -W e can use it when the programming language and the technology to be used are \npredefined.", "mimetype": "text/plain", "start_char_idx": 46024, "end_char_idx": 50395, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f5723f22-83cc-491d-b119-a74c448dceaa": {"__data__": {"id_": "f5723f22-83cc-491d-b119-a74c448dceaa", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f126d84f-d078-45b5-ac88-cc45423d1ad3", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1473cb945c74b2a5df2451845abc4076f8dc8968ddcfcd61d8171a7dfcc7a424", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "29c4130d-4a8f-42c3-9f6c-83eee33e9c77", "node_type": "1", "metadata": {}, "hash": "de241c306faa6f2a01dadc723be153de36b43780a84a6dca5df07c58eb86ac48", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "-COnstructive COst MOdel (COCOMO)  \n -Delphi  \n SLOC Technique(Source Line of Code Technique) -The SLOC technique is an objecti ve \nmethod of estimating or calculating the size of the project.  \n-The project size helps determine the resources, effort, cost, and duration required to \ncomplete the project.  \n -It is also used to directly calculate the effort to be spent on a project.  \n -W e can use it when the programming language and the technology to be used are \npredefined.  \n-This technique includes the calculation of lines of codes(LOC), documentation of pages, \ninputs, outputs, and components of a software program.  \n Counting SLOC -The us e of SLOC techniques can be used in the case of the technology or \nlanguage  remains unchanged throughout the project.  \nGenerally, it can be used when you are using third -generation language, such as FORTRAN \nor COBOL.  \n-To count the SLOC the following must b e considered: \n The count includes: - \nThe SLOC delivered to client.  \n-The SLOC written only by the development team are counted -The declaration statements \nare counted as source lines of code  \nThe count excludes: -The code created by application generators.  \n -The comments inserted to improve the readability of program.  \n-Once, you get the numbers of line of code of SLOC, you can estimate or calculate the total \neffort and cost to complete the given project.  \nExample: -Assume estimated lines of code of a system is:  33,600 LOC -Average productivity \nfor system of this type is: 620 LOC/person -month - \nThere are 7 developers -Labor rate is: $ 8000per person -month \n Calculate the total effort \nand cost required to complete the above project  \nSolution+Way1=>  \n36  \n   Total Effort =Total LOC/Productivity = 33600/620=54.19 \u2248 54 person -months=> \n7developers  \n \nEffort = Tot al Effort/6= 54/7= 7months=> Total Cost=Total Effort * Labor Rate = 54 * \n8000\u2248 $43,2000+Way2=> Cost per LOC =Labor Rate/Productivity=8000/620=$12.9\u2248 $13  \n> Total Cost = Total LOC * Cost perLOC =33,600* 13=$436800  \n9 (i) What is the impact of reusability in soft ware development process?  \n(ii) Explain the component based software development model with a neat sketch. \nNOV/DEC  2017  \nComponent -based software engineering  (CBSE ) \n\uf0b7 It also called  components -based development  (CBD ), is a branch of software \nengineering that emphas izes the  separation of concerns  with respect to the wide -\nranging functionality available throughout a given  software system . \n\uf0b7  It is a reuse -based approach to defining, implementing and composing loosely \ncoupled independent components into systems.  \n\uf0b7 This practice aims to bring about an equally wide -ranging degree of benefits in bot h \nthe short -term and the long -term for the software itself and for organizations that \nsponsor such software.  \n\uf0b7 Software engineering practitioners regard components as part of the starting platform \nfor service -orientation .  \n\uf0b7 Components play this role, for example, in  web services , and more recently, \nin service -oriented architectures  (SOA), whereby a component is converted by the \nweb service into a  service  and subsequently inherits further characteristics beyond that \nof an ordinary component . \n\u2022 C O T S (C om m erci al  Off The Shelf ) software  com ponents, devel oped by vendors who offer them as  products \ncan  be us ed when  software  is to built.  \n\u2022 Provides interfaces targeted  functionality with well defined  \n\u2022 Incorporates model many of the characteristics of Sp iral model  \n\u2022 R e g a r d l e s s  of technology  to be  used,  it must follow  the s teps   like \u2013 Available  component\nb as ed products  are res earch ed  and evaluated for the current  application  \nCom ponent integration i s s u e s  is to dealt \n\u2013 A software  architecture  is desi gned  to accomm odate  the components.  \n\u2013 Com ponents  are i ntegrated i nto th e  archi tecture  \n\u2013 C om prehen sive   testing  is conducted  to ensure proper functionality.  \n\u2013 Component Based Software Engineering(CBSE) is a process that emphasis the \ndesign and construction of computer based system using reusable software \n\u201ccomponents\u201d.", "mimetype": "text/plain", "start_char_idx": 49915, "end_char_idx": 54046, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "29c4130d-4a8f-42c3-9f6c-83eee33e9c77": {"__data__": {"id_": "29c4130d-4a8f-42c3-9f6c-83eee33e9c77", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f5723f22-83cc-491d-b119-a74c448dceaa", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "670d73a3e77d590234339bd9339b91db096c5372428468a74c35243cdb83996a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "777ebdba-4ab9-4e95-a585-c670b16d9353", "node_type": "1", "metadata": {}, "hash": "afcb264d537fd8ca75c10f3f1db60d95dd20b5128503b67df021943f355e77bc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\u2022 Provides interfaces targeted  functionality with well defined  \n\u2022 Incorporates model many of the characteristics of Sp iral model  \n\u2022 R e g a r d l e s s  of technology  to be  used,  it must follow  the s teps   like \u2013 Available  component\nb as ed products  are res earch ed  and evaluated for the current  application  \nCom ponent integration i s s u e s  is to dealt \n\u2013 A software  architecture  is desi gned  to accomm odate  the components.  \n\u2013 Com ponents  are i ntegrated i nto th e  archi tecture  \n\u2013 C om prehen sive   testing  is conducted  to ensure proper functionality.  \n\u2013 Component Based Software Engineering(CBSE) is a process that emphasis the \ndesign and construction of computer based system using reusable software \n\u201ccomponents\u201d.  \n37  \n  \u2022 It emerged from the failure of object -oriented development to support effective \nreuse. Single object classes are too detailed and specific.  \n \u2022 CBSE embodies the \u201cbuy , don\u2019t built\u201d philosophy.  \n \n \n \n\u2022 The p rocess begins when a software team establish requirements for a system \nto be built using conventional requirements elicitation techniques. An \narchitectural design is established , but rather than moving immediately into \nmore detailed tasks , the team exami nes requirements to determine what \nsubset is directly amenable to composition , rather than construction.  \n\u2022 For those requirements that can be addressed with available components the \nfollowing activities take place:  \n 1. Component qualification  \n 2. Component adaptation  \n3. Component composition  \n4. Component update  \n COMPONENT CHARACTERISTICS  \n1. Standardised  \n2. Independent  \n 3. Compassable  \n 4. Deployable  \n38  \n 5. Documented  \n \n10 (i) How function point analysis methodology is applied in estimation of software size \n?Expla in. Why FPA methodology is better than LOC methodology  ? \nIf LOC is simply a count of the number of lines then figure shown below contains 18 LOC . \n(ii) A line of code is any line of program text that is not a comment or blank line, regardless \nof the number of s tatements or fragments of statements on the line. This specifically includes \nall lines containing program header, declaration, and executable and non -executable \nstatements\u201d.  \nFunction Count  \nAlan Albrecht while working for IBM, recognized the problem in size  measurement in the \n1970s, and developed a technique (which he called Function Point Analysis), which \nappeared to be a solution to the size  \nmeasurement problem.  \nThe five functional units are divided in two categories:  \n(i) Data function types  \n# Internal Log ical Files (ILF): A user identifiable group of logical related data or control \ninformation maintained within the system.  \n# External Interface files (EIF): A user identifiable group of logically related data or control \ninformation referenced by the system, but maintained within another system. This means \nthat EIF counted for one system, may be an ILF in another system.  \nThe weighting factors are identified for all functional units and multiplied with \nthe functional units accordingly. The procedure for the cal culation of Unadjusted \nFunction Point (UFP) is given in table shown above.  \nhe procedure for the calculation of UFP in mathematical  \n(iii) form is given below:UFP = \u2211\u2211 Z ij w ij  \ni = 1 J = 1  \nWhere i indicate the row and j indicates the column of Table 1  \nW ij : It i s the entry of the i th row and j th column of the table 1  \nZij : It is the count of the number of functional units of Type i that have been \nclassified as having the complexity corresponding to column j.  \nOrganizations that use function point methods develop  a criterion for  \n39  \n determining whether a particular entry is Low, Average or High.  \nNonetheless, the determination of complexity is somewhat subjective.  \nFP = UFP * CAF  \nWhere CAF is complexity adjustment factor and is equal to [0.65 +  \n0.01 x \u03a3F i ]. The F i (i=1 to 14) are the degree of influence  \n(iv) An application has the following:10 low external inputs, 12 high external \noutputs, 20 low internal logical files, 15 high external interface files, 12 average \nexternal inquiries and a value adj ustment factor of 1.10 . What is the unadjusted and \nadjusted function point count ?", "mimetype": "text/plain", "start_char_idx": 53295, "end_char_idx": 57530, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "777ebdba-4ab9-4e95-a585-c670b16d9353": {"__data__": {"id_": "777ebdba-4ab9-4e95-a585-c670b16d9353", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "29c4130d-4a8f-42c3-9f6c-83eee33e9c77", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5d83ce4054fbd49474bc4c5d58ed09b5fd7123dd7b25fb2994a85d33bb4e53a7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e", "node_type": "1", "metadata": {}, "hash": "f044474e51b412aa65849ed5705908cdc86656b12bed7dd362bd72a01c6fcd15", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Nonetheless, the determination of complexity is somewhat subjective.  \nFP = UFP * CAF  \nWhere CAF is complexity adjustment factor and is equal to [0.65 +  \n0.01 x \u03a3F i ]. The F i (i=1 to 14) are the degree of influence  \n(iv) An application has the following:10 low external inputs, 12 high external \noutputs, 20 low internal logical files, 15 high external interface files, 12 average \nexternal inquiries and a value adj ustment factor of 1.10 . What is the unadjusted and \nadjusted function point count ? APRIL/MAY  2017  \nSolution  \nUnadjusted function point counts may be calculated using  \nas: \n \nUFP = \u2211\u2211 Z ij w ij  \n           i = 1 J = 1  \nFP \n= 10 x 3 + 12 x 7 + 20 x 7 + 15 + 10 + 12  x 4 \n= 30 + 84 +140 + 150 + 48  \n= 452  \n= UFP x CAF  \n= 452 x 1.10 = 497.2.  \n11 What is a process model ? Describe the process model that you would choose to \nmanufacture a car. Explain giving suitable reasons. APRIL/MAY 2017  \nA structured set of activities requi red to develop a software system.  \n\u2022 Many different software processes but all involve:  \n\u2022Specification \u2013 defining what the system should do;  \nDesign and implementation \u2013 defining the organization of the system and  \nimplementing the system;  \nValidation \u2013 checki ng that it does what the customer wants;  \nEvolution \u2013 changing the system in response to changing customer needs.  \n\u2022 A software process model is an abstract representation of a process. It  \npresents a description of a process from some particular perspective  \nWhen we describe and discuss processes, we usually talk about the activities  \nin these processes such as specifying a data model, designing a user  \ninterface, etc. and the ordering of these activities.  \n\u2022 Process descriptions may also include:  \n\u2022Products, whi ch are the outcomes of a process activity;  \nRoles, which reflect the responsibilities of the people involved in the process;  \nPre- and post -conditions, which are statements that are true before and after a process \nactivity has been enacted or a product produ ced. \n12 Explain how breakdown structure is used in software engineering .Discuss how \nsoftware project scheduling helps in timely release of a product. APRIL/MAY 2018  \n40  \n A Work Breakdown Structure  includes dividing a large and complex project into simpler, \nmanageable and independent tasks. The root of this tree (structure) is labelled by the Project \nname itself. For constructing a work breakdown structure, each node is recursively \ndecomposed into smaller sub -activities, until at the leaf level, the activities becomes \nundividable and independent. It follows a Top -Down approach.  \nSteps:  \n3. Step -1: Identify the major activities of the project.  \n4. Step -2: Identify the sub -activities of the major activities.  \n5. Step -3: Repeat till undividable, simple and independent activitie s are created.  \n6. \n  \nConstruction of Work Breakdown Structure:  \nFirstly, the project managers and top level management identifies the main deliverables of the project. \nAfter this important step, these main deliverables are broke down into smaller higher -level t asks and \nthis complete process is done recursively to produce much smaller independent tasks. It depends on \nthe project manager and team that upto which level of detail they want to break down their project.  \nGenerally the lowest level tasks are the most si mplest and independent tasks and takes less than two \nweeks worth of work. Hence, there is no rule for upto which level we may build the work breakdown \nstructure of the project as it totally depends upon the type of project we are working on and the \nmanagem ent of the company. The efficiency and success of the whole project majorly depends on the \nquality of the Work Breakdown Structure of the project and hence, it implies its importance.  \nUses:  \n\uf0b7 It allows doing a precise cost estimation of each activity.  \n\uf0b7 It allows estimating the time that each activity will take more precisely.  \n\uf0b7 It allows easy management of the project.  \n\uf0b7 It helps in proper organization of the project by the top management.  \n \n13 Give detail explanation about agile process?", "mimetype": "text/plain", "start_char_idx": 57024, "end_char_idx": 61146, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e": {"__data__": {"id_": "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "777ebdba-4ab9-4e95-a585-c670b16d9353", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0d1254200ac6991b096686f931ca3391fcbedf31a0e58b1bad5bf8f46bac57d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a759a57f-61f7-4325-a448-57876fef0e48", "node_type": "1", "metadata": {}, "hash": "ce4ab078ae9c213b15d3dff51736eba38e7e05b94f208d3d7182ebd308bcc3a9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It depends on \nthe project manager and team that upto which level of detail they want to break down their project.  \nGenerally the lowest level tasks are the most si mplest and independent tasks and takes less than two \nweeks worth of work. Hence, there is no rule for upto which level we may build the work breakdown \nstructure of the project as it totally depends upon the type of project we are working on and the \nmanagem ent of the company. The efficiency and success of the whole project majorly depends on the \nquality of the Work Breakdown Structure of the project and hence, it implies its importance.  \nUses:  \n\uf0b7 It allows doing a precise cost estimation of each activity.  \n\uf0b7 It allows estimating the time that each activity will take more precisely.  \n\uf0b7 It allows easy management of the project.  \n\uf0b7 It helps in proper organization of the project by the top management.  \n \n13 Give detail explanation about agile process?  \nCombination of iterative and incremental process models  \n Focus of adaptability and customer satisfaction  \n Break into small incremental builds  \n iteration typically lasts 1 -3 weeks  \n Cross functional teams working  \n End of the iteration, a working product is displayed to the customer  \nAdvantage  \n Realistic appr oach  \n Promotes teamwork and cross training.  \n Functionality developed rapidly and demonstrated.  \n41  \n \n Resource requirements are minimum.  \n Suitable for fixed or changing requirements  \n Delivers early partial working solutions.  \n Good model for environments th at change steadily.  \n Minimal rules, documentation easily employed.  \n Little or no planning required.  \n Easy to manage.  \n Gives flexibility to developers.  \n Not suitable for handling complex dependencies.  \n Strict delivery management dictates the scope, fu nctionality to be  \ndelivered, and adjustments to meet the deadlines.  \n Depends heavily on customer interaction, so if customer is not clear,  \nteam can be driven in the wrong direction.  \n Transfer of technology to new team members may be quite  \nchallenging due  to lack of documentation.  \nAgile Framework  \n Rational Unified Process (1994),  \n Scrum (1995),  \n Extreme Programming (1996),  \n Adaptive Software Development,  \n Feature Driven Development,  \n Dynamic Systems Development Method (DSDM) (1995).  \n Rational Unifie d Process (1994),  \n Scrum (1995),  \n Extreme Programming (1996),  \n Adaptive Software Development,  \n Feature Driven Development,  \n Dynamic Systems Development Method (DSDM) (1995).  \n14 Describe in detail about Extreme programming ?  \nE x t r e m e  P r o g r a m m i n g  ( X P ) \n42  \n \uf0b7 Ma n a gem en t -P ra cti ce s  \nOn-Site Cu st om er:    Acentral  customer  contact  must alw ay s  be \nacce ssi ble  in order to clarify requirements and questions directly.  \nPlanning Gam e: Projects, in acco rd ance  with X P ,  r u n  iteratively \n(repeatedly) and incrementally (gradually build on e ach  other). The \ncontents  of the next step are planned  before  each iteration. All  project  \nmembers  (incl. the customer)  participate.  \nShort  Relea ses:  New deliveries  should  be m ade at short \nintervals. Con seq uen tl y , customers receive the required \nfunctions quicker  and can therefore  give feedback  on the \ndevelopment  quicke r. \n\uf0b7 T e a m-P r a c t i c e s \nMetaphor: Only a few clear metaphors should describe the system  \nbeing developed  so that the nitty-gritty  of the system  is clear to all of \nthe project  members.  \nCol l ecti v e Ownership: The whole team is responsible for the system, not \nindividuals.  E ac h developer  must have ac ce s s to all lines of code so that \neach developer  is able to take over the task of another  developer.  \n\uf0b7 Continuous  In tegra ti on :  All ch anges  to the system  are integrated  \nPromptly so that not too many dependencies between ch ange s occur. \nCoding  Standards:  Reg ard ing  the common  responsibility  for the code, \nthere should  be a given common  standard  for writing  the code. \nSustainable P a c e :  XP builds on the creativity of the individual      \nproject members. This creativity cannot be achieved if the project \nteam constantly  works  overtime.  Overtime  is to be avoided.", "mimetype": "text/plain", "start_char_idx": 60213, "end_char_idx": 64408, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a759a57f-61f7-4325-a448-57876fef0e48": {"__data__": {"id_": "a759a57f-61f7-4325-a448-57876fef0e48", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "b8ad49c9b6e8012ba7d26da5e6788c644f5a4857615b29bc51c2331c3ac8c87a", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3b40ad02-ea55-4fc5-9749-5002848e5e89", "node_type": "1", "metadata": {}, "hash": "f016104dc65a98c90ede13782d71e575d3f494268c607bdf7de5ba7163617556", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Col l ecti v e Ownership: The whole team is responsible for the system, not \nindividuals.  E ac h developer  must have ac ce s s to all lines of code so that \neach developer  is able to take over the task of another  developer.  \n\uf0b7 Continuous  In tegra ti on :  All ch anges  to the system  are integrated  \nPromptly so that not too many dependencies between ch ange s occur. \nCoding  Standards:  Reg ard ing  the common  responsibility  for the code, \nthere should  be a given common  standard  for writing  the code. \nSustainable P a c e :  XP builds on the creativity of the individual      \nproject members. This creativity cannot be achieved if the project \nteam constantly  works  overtime.  Overtime  is to be avoided.  \n\uf0b7 D e s i g n \nWriting unit tests before programming and keepi ng  all of the tests \nrunning  at all times.  Th e  unit tests are automated  and eliminates  \ndefects e arl y , thus reducing  the co sts. \nStarting  with a simple  de sig n  just enough  to code the features at hand and \nredesigning when required.  \n \n\uf0b7 D es i g n :  User Stor ies \n43  \n \uf0b7  \n\uf0b7 Developm ent  \nPro g ram m in g  in pairs (called pair programm ing) , with two prog rammers  atone  screen ,  taking  \nturns to use  the keyboard. While one of them is at the keyboard, the other constantly reviews \nand provides  inputs. \nIntegrating and testing the whole  sy stem   s eve ral  times a d a y . \n\uf0b7 Pai r Pro g r am m i n g  \ntwo prog ram mers  work together  atone workstation.  \nOn e , the d r i v e r, writes  code while  the other, the o b s e r v e r  or n a v i g a t o r , reviews  e ach line of co d e  as it is \ntyped  in. \nTh e two prog rammers  switch  roles frequently.  \nWhile reviewing, the observer also co n si de rs the \"strategic \" direction of the work, com ing up \nwith ide as for improvements  and likely future  problems to ad d re s s . \nTh i s  frees the driver to focus all of their attention on the \"tactical\"  as p e c t s  of completing  the \ncurrent task, using the observer  as a safety net and  guide \n\uf0b7 Pai r Pro g r am m i n g  \nPai r programm ing i n c re as e s  the m an-hours required to deliver code com pared  to prog ramme rs  \nworking  individually  from up to between  15% and 1 0 0 % . \nH o w e v e r ,  the resulting  code h as about  15% fewer defects. \n\uf0b7 Production  \n44  \n Putting a minimal worki ng sy s tem  into the production  quickly  and upgrading    it \nwhenever  required.  \nK e e p i n g   the customer  involved  all the time and obtaining constant  feed back .  \n \nExtreme Programming \u2212 A way to handle the common shortcomings  \nSoftware Engineering involves \u2212  \n\uf0b7 Creativity  \n\uf0b7 Learning and improving through trials and errors  \n\uf0b7 Iterations  \nExtreme Programming builds on these activities and coding. It is the detailed (not the only ) \ndesign activity with multiple tight feedback loops through effective implementation, testing \nand refactoring continuously.  \nExtreme Programming is based on the following values \u2212  \n\uf0b7 Communication  \n\uf0b7 Simplicity  \n\uf0b7 Feedback  \n\uf0b7 Courage  \n\uf0b7 Respect  \nWhat is Extreme Programmin g? \nXP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development methodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self -organize. \nExtreme Programming provides specific core practices  where \u2212  \n\uf0b7 Each practice is simple and self -complete.  \n\uf0b7 Combination of practices produces more complex and emergent behavior.  \n45  \n Embrace Change  \nA key assumption of Extreme Programming is that the cost of changing a program can be \nheld mostly constant over time.", "mimetype": "text/plain", "start_char_idx": 63683, "end_char_idx": 67563, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3b40ad02-ea55-4fc5-9749-5002848e5e89": {"__data__": {"id_": "3b40ad02-ea55-4fc5-9749-5002848e5e89", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a759a57f-61f7-4325-a448-57876fef0e48", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fe2d099d702594a91a3471976817b1ecfd52af385e4d6a489152daee790576a3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "19f001be-31d3-4844-88e7-a2d0e988d470", "node_type": "1", "metadata": {}, "hash": "cfb23365acf21ca112d0fa507ca8240f91492d997066ae5fc6aa8a4f8f08ee18", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "XP is a lightweight, efficient, low -risk, flexible, predictable, scientific, and fun way to \ndevelop software.  \neXtreme Programming (XP) was conceived and developed to address the specific needs of \nsoftware development by small teams in the face of vague and changing requirements.  \nExtreme Programming is one of the Agile software development methodologies. It provides \nvalues and principles to guide the team behavior. The team is expected to self -organize. \nExtreme Programming provides specific core practices  where \u2212  \n\uf0b7 Each practice is simple and self -complete.  \n\uf0b7 Combination of practices produces more complex and emergent behavior.  \n45  \n Embrace Change  \nA key assumption of Extreme Programming is that the cost of changing a program can be \nheld mostly constant over time.  \nThis can be achieved with \u2212  \n\uf0b7 Emphasis on continuous feedback from the customer  \n\uf0b7 Short iterations  \n\uf0b7 Design and redesign  \n\uf0b7 Coding and testing frequently  \n\uf0b7 Eliminating defects early, thus reducing costs  \n\uf0b7 Keeping the customer involved throughout the development  \n\uf0b7 Deliveri ng working product to the customer  \n \n15 Explain about Extreme Programming using nutshell.?  \nExtreme Programming involves \u2212  \n\uf0b7 Writing unit tests before programming and keeping all of the tests running at all times. \nThe unit tests are automated and eliminates d efects early, thus reducing the costs.  \n\uf0b7 Starting with a simple design just enough to code the features at hand and redesigning \nwhen required.  \n\uf0b7 Programming in pairs (called pair programming), with two programmers at one \nscreen, taking turns to use the keyboar d. While one of them is at the keyboard, the \nother constantly reviews and provides inputs.  \n\uf0b7 Integrating and testing the whole system several times a day.  \n\uf0b7 Putting a minimal working system into the production quickly and upgrading it \nwhenever required.  \n\uf0b7 Keepin g the customer involved all the time and obtaining constant feedback.  \nIterating facilitates the accommodating changes as the software evolves with the changing \nrequirements.  \n \n46  \n       UNIT \u2013 2 PART \u2013A \n \n \n \n \nS.NO  QUESTIONS  \n1 What is Software Prototyping? NOV/ DEC -10 , APR/MAY -11, MAY/JUNE -13 \nIt is a rapid software development for validating the  \nrequirements. It is to help customers & developers to understand the system requirements.  \n2 Define functional and non - Functional requirements. NOV/DEC -10 \nFunctional re quirements describe all the functionality or system services. It should \nbe clear how system should react to particular inputs and how particular systems behave in \nparticular situation. Non functional requirements define the system properties and constraint s. \nIt is divided in to product, organizational  & \nexternal requirements.  \n3 What is meant by functional requirement? APR/MAY -11 Functional requirements \ndescribe all the functionality or system services. It should be clear how system should react to \nparticul ar \ninputs and how particular systems behave in particular situation.  \n4 Name the metrics for specifying Non -functional requirements? NOV/DEC -11 \nSpeed, size, ease of use, reliability, robustness, portability  \n5 Draw  the DFD  for  the following  (i) External  entity (ii) Data items NOV/DEC -11 \nExternal entity  \nData items  \n47  \n 6 What do requirements processes involve? APR/MAY -12 \nIt involves  feasibility  study,  discovery,  analysis &validation of system  \nrequirements.  \n7 Define non -functional requirements. APR/MAY -12 \nNon functional requirements define the system properties and constraints.  It is divided in to \nproduct, organizational  & \nexternal requirements  \n8 Distinguish  between  the term  inception,  elicitation,  & elaboration with reference to \nrequirements?  NOV/DEC -12 \nInception \u2013 set of questions are asked to establish basic understanding of problem.  \nElicitation - collaborative requirements gathering & quality function deployment  \nElaboration \u2013 It focuses on developing a  refined technical   model   of   software   function , \nfeatures & constraints.  \n9 An SRS is traceable ?comment NOV/DEC -12,MAY/JUNE 2016  An SRS is correct if, and only if, \nevery requirement stated therein is one that the software shall meet. Traceability makes \nthis procedure easier and less prone  \nto error.  \n10 What is data dictionary? MAY/JUN -13 , APR/MAY 2016 ,  NOV/DEC 2016, APRIL/MAY 2017  \nIt is organized collection of all the data elements of the system with precise and rigorous \ndefinition so that user & system analyst will have a common understanding of inp uts, outputs,  \ncomponents of stores and intermediate calculations.", "mimetype": "text/plain", "start_char_idx": 66769, "end_char_idx": 71387, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "19f001be-31d3-4844-88e7-a2d0e988d470": {"__data__": {"id_": "19f001be-31d3-4844-88e7-a2d0e988d470", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3b40ad02-ea55-4fc5-9749-5002848e5e89", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62102dbdab1daf92715a6aecd63e90f55cbb82e2fd053863e07bf8498313c25c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9bf26669-ce55-49ba-90fd-b14ff8bd7f98", "node_type": "1", "metadata": {}, "hash": "b784b42c925fbe93eea5465cb9c5fbf3671241f3046db8da53a803a3ce130d2e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Elicitation - collaborative requirements gathering & quality function deployment  \nElaboration \u2013 It focuses on developing a  refined technical   model   of   software   function , \nfeatures & constraints.  \n9 An SRS is traceable ?comment NOV/DEC -12,MAY/JUNE 2016  An SRS is correct if, and only if, \nevery requirement stated therein is one that the software shall meet. Traceability makes \nthis procedure easier and less prone  \nto error.  \n10 What is data dictionary? MAY/JUN -13 , APR/MAY 2016 ,  NOV/DEC 2016, APRIL/MAY 2017  \nIt is organized collection of all the data elements of the system with precise and rigorous \ndefinition so that user & system analyst will have a common understanding of inp uts, outputs,  \ncomponents of stores and intermediate calculations.  \n11 What are the benefits of prototyping?  \ni. Prototype  serves  as a basis  for deriving  system specification. ii. Design quality \ncan be improved.  \niii. System can be maintained easily.  \n iv. Develo pment efforts may get reduced.  \nv. System usability can be improved.  \n48  \n 12 What are the prototyping approaches in software process? MAY/JUNE 2016,APRIL/MAY 2018  \n \ni. Evolutionary prototyping \u2013 In this approach of system development, the initial prototype is \nprepared and it is then refined through number of stages to final  stage.  \nii. Throw -away prototyping \u2013 Using this approach a rough practical implementation of the \nsystem is produced. The requirement problems can be identified from this implementation. It is then \ndiscard ed.System is then developed using some  different  \nengineering paradigm.  \n13 List the characteristics of good SRS? APR/MAY 2016  \n \n\uf0b7 Correct  \n\uf0b7 Unambiguous  \n\uf0b7 Complete  \n\uf0b7 Consistent  \n\uf0b7 Ranked for importance and/or  stability  \n\uf0b7 Verifiable  \n\uf0b7 Modifiable  \n\uf0b7 Traceable  \n14 Classify  the following  as functional  / non-functional requirements for a banking \nsystem? NOV / DEC  2016  \n(a) Verifying bank  balance  \u2013 functional  requirements  \n(b) Withdrawing money from bank \u2013 functionalrequirements  \n(c) Completion of transaction in less than 1 sec \u2013 non-functional re quirements  \n(d) Extending system by providing more tellers for customers - \n non-functional requirements  \n49  \n 15 What is the linkage between Dataflow and ER diagram? APR/MAY 2016  \n \nAn ER diagram is the Entity Relationship Diagram, showing the relationship    between     different     \nentities     in     a     process.  A Data Flow diagram is a symbolic structure showing how the  flow  \nof data is used in different process  \n16 List the steps in user interface design? Golden rules of UI design APR/MAY 2015,  \nNOV/DEC2015  \nPlace the User in Control  \nReduce the User's Memory Load Make the Interface Consistent  \n17 How are requirements validated? APR/MAY 2015  Requirements validation: Have we got \nthe requirements right?  \nIn the validation phase, the work products produced as a consequ ence of requirements engineering are \nexamined for consistency, omissions, and ambiguity. The basic objective is to ensure that the SRS \nreflects the actual requirements accurately and  \nclearly.  \n18 What is a state transition diagram?  \nState transition diagram  is basically a collection of states and events. The events cause the \nsystem to change its state. It  also \nrepresents what actions are to be taken based on the transition.  \n19 What is DFD?  \nData Flow Diagram depicts the information flow and the transforms th at are applied on the \ndata as it moves from input to  \noutput.  \n20 What is waterfall model?  \nThe Waterfall Model was first Process Model to be introduced. It is also referred to as a linear -\nsequential life cycle model . \n50  \n  It is very simple to understand and us e. \nIn a waterfall model, each phase must be completed fully before the next phase can begin. This type \nof model is basically used for the for the project which is small and there are no uncertain \nrequirements.  \nIn this model the testing starts only after th e development is complete.  \nIn waterfall model phases do not overlap.  \n21 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is mainly used in database applications.  \n22 What is data modeling?  \nData m odeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing.", "mimetype": "text/plain", "start_char_idx": 70615, "end_char_idx": 74974, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9bf26669-ce55-49ba-90fd-b14ff8bd7f98": {"__data__": {"id_": "9bf26669-ce55-49ba-90fd-b14ff8bd7f98", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "19f001be-31d3-4844-88e7-a2d0e988d470", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "31985293d096cb92fff8a0bdf16350aabe9ff4779eda3ba1d5e945b1050d619b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0", "node_type": "1", "metadata": {}, "hash": "16d3ffe83ee8193c19f5a072ef0c7e7169f5b7af0a5ee1affedceba3db3b8e7e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "20 What is waterfall model?  \nThe Waterfall Model was first Process Model to be introduced. It is also referred to as a linear -\nsequential life cycle model . \n50  \n  It is very simple to understand and us e. \nIn a waterfall model, each phase must be completed fully before the next phase can begin. This type \nof model is basically used for the for the project which is small and there are no uncertain \nrequirements.  \nIn this model the testing starts only after th e development is complete.  \nIn waterfall model phases do not overlap.  \n21 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is mainly used in database applications.  \n22 What is data modeling?  \nData m odeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing. The data model represents how data are related with  \none another.  \n23 What is requirement engineering?  \nRequirement engineering is  the process of establishing the  \nservices that the customer requires from the system and the constraints under which it operates and is \ndeveloped.  \n24 What are the various Rapid prototyping techniques?  April  \n/May 2015  \ni. Dynamic high level language  developmen t. \nii. Database programming.  \niii. Component and application  assembly.  \n25 What is data modeling?  \nData modeling is the basic step in the analysis modeling. In data modeling the data objects are \nexamined independently of processing. The data model  represents how data  are related with  \none another.  \n51  \n 26 What  are the   various   types   of   traceability  in software engineering? April/may  2018  \ni v. Source traceability \u2013 These are basically the links from requirement to  stakeholders  \nv. Requirements traceability \u2013 These are links b etween dependant  requirements.  \nvi . Design traceability \u2013 These are links from  requirements  \nto design.  \n27 What is cardinality in data modeling?  \nCardinality in data modeling, cardinality specifies how  \nthe number of occurrences of one object is related to the nu mber of occurrences of another object.  \n28 What are the objectives of Analysis  modeling?  \ni. To describe what the customer  requires.  \nii. To establish a basis for the creation of software  design.  \niii. To devise a set of valid requirements after which the software can be  built.  \n29 How the limitations of waterfall model overcome? April /May  2015  \nThis type of model is basically used for the for the project which is small and there are no uncertain \nrequirements.Where no overlapping of  phases.  \nAt the end of each phase, a rev iew takes place to determine if the  \nproject is on the right path and whether or not to continue or discard the project.  \n30 What is feasibility study? NOV/DEC2015 , APR/MAY 2016  \nsoftware feasibility has four solid dimensions:  \nTechnology \u2014 Is a project techn ically feasible? Is it within the state of the art? Can defects be reduced \nto a level matching the application\u2019s needs?  \nFinance \u2014Is it \ufb01nancially feasible? Can development be completed  \n52  \n  at a cost the software organization, its client, or the market can afford?  \nTime \u2014Will the project\u2019s time -to-market beat the competition? Resources \u2014Does the organization \nhave the resources nee ded to succeed?  \nBefore starting any project the feasibility study team ought to carry initial architecture and design of \nthe high -risk requirements to the point at which it can answer these questions. In some cases, when \nthe team gets negative answers, a r eduction in requirements may be  \nnegotiated.  \n31 Define Quality function decelopment(QFD). NOV/DEC 2017  \nQuality Function Deployment ( QFD ) is a structured approach to defining customer needs or \nrequirements and translating them into specific plans to produce  products to meet those needs. The \n\u201cvoice of the customer\u201d is the term to describe  \nthese stated and unstated customer needs or requirements.  \n32 Differentiate between normal and exciting requirements ? APRIL/MAY 2017  \nNormal requirements  \n\uf0b7 The objective and g oal are stated for the system through  the meetings with the  customer.  \n\uf0b7 For the customer satisfaction these requirements should  be there.  \nExciting requirements  \n\uf0b7 These features are beyond the expectation of the  customer.  \n \n\uf0b7 The developer adds some additional fea tures or unexpected feature into the software to make \nthe customer more satisfied.  \nFor example, the mobile phone with standard features, but  the developer adds few additional \nfunctionalities like voice searching, multi -touch screen etc.", "mimetype": "text/plain", "start_char_idx": 74111, "end_char_idx": 78724, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0": {"__data__": {"id_": "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9bf26669-ce55-49ba-90fd-b14ff8bd7f98", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "38399bbbef53689e72749086a51e47f3c13f1fb8cf2bf47f56b5733e47edb0f4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f30f2602-a16c-4487-8c4b-bcafab8959b4", "node_type": "1", "metadata": {}, "hash": "b1216547569308b121c719d9dd4d112d86a1720c3799ba1098fa46845ba7c058", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The \n\u201cvoice of the customer\u201d is the term to describe  \nthese stated and unstated customer needs or requirements.  \n32 Differentiate between normal and exciting requirements ? APRIL/MAY 2017  \nNormal requirements  \n\uf0b7 The objective and g oal are stated for the system through  the meetings with the  customer.  \n\uf0b7 For the customer satisfaction these requirements should  be there.  \nExciting requirements  \n\uf0b7 These features are beyond the expectation of the  customer.  \n \n\uf0b7 The developer adds some additional fea tures or unexpected feature into the software to make \nthe customer more satisfied.  \nFor example, the mobile phone with standard features, but  the developer adds few additional \nfunctionalities like voice searching, multi -touch screen etc. then the customer m ore exited about \nthat feature.  \n  \n53  \n 33 How do you design a software project for  reuse? (Nov/Dec  2007)  \n\uf0b7 A clear and well -defined product vision is an  essential foundation to  an \nsoftware  project.  \n\uf0b7 An evolutionary implementation strategy would be a  more pragmati c strategy  \nfor the company.  \n\uf0b7 There exist a need for continuous management support  and leadership  to \nensure success.  \n34 What are the standards for documentation? Briefly explain (Nov/Dec 2007)  \nIEEE Std 1028 -2008  \nThis standard defines five types of software reviews and procedures for  their  \nexecution. Review types include management reviews, technical reviews,  \ninspections, walk -throughs and audits. IEEE Std 1012 -2004  \nThis standard describes software verification and validation processes that are  \nused to determ ine if software products of an activity meets the requirements of the  \nactivity and to determine if software satisfies the user's needs for the intended  \nusage. The scope includes analysis, evaluation, review, inspection, assessment  \nand testing of both produ cts and processes.  \n35 What are context free questions? How it differs from meta questions?  \n(Nov/Dec 2009)  \nContext free questions are questions that can be  used regardless of the  project  \nunder consideration. They are general questions about  the nature of t he project  and \nthe environment in which the final product will be used.Meta questions are very  \ncomplex and detailed questions about the project model  \n54  \n  \n36  \n \nDefine behaviouralmodelling(Nov/Dec 2012)  \nAll behavioural models really do is describe the control structure of a system.  \nThis can be things like:  \n\uf0a7 Sequence of  operations  \n\uf0a7 Object states  \n\uf0a7 and Object  interactions  \nFurthermore, this modelling layer can also be called Dynamic Modelling. The  \nactivity of creating a behavioural model is commonly known as behaviour al \nmodelling. As well as this, a system should also only have one behavioural  \nmodel \u2013 much like functional modelling.  \n37 what are the types of prototypes  \n\u2022 Evolutionary prototyping \u2013 the initial prototype is prepared and it is then  refined  \nthrough number of  stages to final stage.  \n\u2022 Throw -away prototyping \u2013 a rough practical implementation of the system  is \nproduced. The requirement problems can be identified from  \nthis implementation  \n38 Define behaviouralmodelling(Nov/Dec 2012)  \nAll behavioural models really do is describe the control structure of a system.  \nThis can be things like:  \n\uf0a7 Sequence of  operations  \n\uf0a7 Object states  \n\uf0a7 and Object  interactions  \nFurthermore, this modelling layer can also be called Dynamic Modelling. The  \nactivity of creating a behavioural model is com monly known as behavioural  \nmodelling. As well as this, a system should also only have one behavioural  \nmodel \u2013 much like functional modelling.  \n39 What is the major distinction between user requirement and system  \nrequirement? (April/May 2008)  \nUser requireme nts may be a set of statements or use case scenarios presented  \nby the client in layman\u2019s terms of which the client can easily  \n elaborate and are  \nusually free of technical jargon. System requirements are built from the clients input  \nbeing what they have sp ecified in the user requirements.  \n55  \n 40 Which style of prototyping is most appropriate when the requirement are not  \nwell-understood? (April/May 2008)  \nUser Interface prototyping is most appropriate.This prototyping is used to prespecify  \nthe look and feel of u ser interface in an effective way.  \n41 Specify at least four questionnaire which supports to select the prototyping  \napproach. (Nov/Dec 2009)  \n\uf0b7 Prototype serves as a basis for deriving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be mainta ined easily.  \n\uf0b7 Development efforts may get reduced.", "mimetype": "text/plain", "start_char_idx": 77970, "end_char_idx": 82584, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f30f2602-a16c-4487-8c4b-bcafab8959b4": {"__data__": {"id_": "f30f2602-a16c-4487-8c4b-bcafab8959b4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ce44e3fac3d7794966ac77ac063159d67b5b26480d2625891c83c87bce5921af", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b1a9726d-ec99-4834-970d-5f151350e4e7", "node_type": "1", "metadata": {}, "hash": "9331020b994570103eac9bf37de3f3743b49d28953f16881bd2510c1f4ba713f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "System requirements are built from the clients input  \nbeing what they have sp ecified in the user requirements.  \n55  \n 40 Which style of prototyping is most appropriate when the requirement are not  \nwell-understood? (April/May 2008)  \nUser Interface prototyping is most appropriate.This prototyping is used to prespecify  \nthe look and feel of u ser interface in an effective way.  \n41 Specify at least four questionnaire which supports to select the prototyping  \napproach. (Nov/Dec 2009)  \n\uf0b7 Prototype serves as a basis for deriving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be mainta ined easily.  \n\uf0b7 Development efforts may get reduced.  \n\uf0b7 System usability can be  improved.  \n42 What is the purpose of domain analysis. (April/May 2010)  \nDomain analysis, or product line analysis, is the process of analysing related  \nsoftware systems in a domain to find their common and variable parts. It is a model  \nof wider business context for the system  \n43 what are the types of prototypes  \n\u2022 Evolutionary prototyping \u2013 the initial prototype is prepared and it is then  refined  \nthrough number of stages to final stage.  \n\u2022 Throw -away prototyping \u2013 a rough practical implementation of the system  is \nproduced. The requirement problems can be identified from  \nthis implementation  \n44 list two advantage of employing prototyping in software process?  \n\uf0b7 Prototype serves as a basis for der iving  system specification.  \n\uf0b7 Design quality can be  improved.  \n\uf0b7 System can be maintained  easily.  \n\uf0b7 Development efforts may get reduced.  \n\uf0b7 System usability can be  improved.  \n56  \n 45 State the different criteria applied to evaluate an effective modular system.  \n(May/June 2006)  \n\uf0b7 A system is considered modular if it consists of  discreet components so  that each \ncomponent can be implemented separately, and a change to one  component has  \nminimal impact on other components.  \n\uf0b7 Modularity is a clearly a desirable property in a  system . Modularity helps in  system \ndebugging. Isolating the system problem to a component is easier if  the system is \nmodular.   \n46 What is meant by structural analysis?  \nThe structural analysis is mapping of problem domain to flows and transformations. \nThe system  can be modeled by using Entity Relationship diagram, Data flow \ndiagram and Control flow  \ndiagrams.   \n47 What is the outcome of feasibility study?  \nThe outcome of feasibility study is the results obtained from the following questions: \nx Which system contribu tes to organizational objectives? x Whether the system can \nbe engineered? Is it within  the budget? x Whether the system can be integrated with  \nother  \nexisting system?   \n48 What are nonfunctional requirements?  \nNonfunctional requirements are constraints on t he services or functions offered by \nthe system such as timing  constraints,  \nconstraints on the development process, standards, etc\u2026   \n49 What are the advantages of evolutionary prototyping?  \ni. Fast delivery of the working system. ii. User is involved while developing the \nsystem. iii. More useful system can be delivered. iv. Specification,  design and \nimplementation work in co -ordinate  \nmanner.   \n50 What are the various Rapid prototyping techniques?  \ni. Dynamic  high level  language  development.  ii. Database   \n programming. iii. Component and application assembly.   \n \n \n \n \n57  \n  \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 Discuss any four process models with suitable application.  NOV/DEC -10 , \nAPR/MAY -11, NOV/DEC -12, MAY/JUN -13 \nA software process model is a standardised format for  \n\u2022 planning  \n\u2022 organising, and  \n\u2022 running a development project  \nHundreds of different models exist and are used, but many are minor variations \non a small number of basic models.  \n1.1. Plan ning with Models  \n(a ) SE projects usually live with a fixed financial budget. (An exception is \nmaintenance?) Additionally, time -to-market places a strong time \nconstraint. There will be other project constraints such as staff.", "mimetype": "text/plain", "start_char_idx": 81908, "end_char_idx": 85923, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b1a9726d-ec99-4834-970d-5f151350e4e7": {"__data__": {"id_": "b1a9726d-ec99-4834-970d-5f151350e4e7", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f30f2602-a16c-4487-8c4b-bcafab8959b4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4cccd09a2a1f7e00faefb291e4bde4d6ffbb13c46aa3f42284c0a36f6deb8111", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b7dc2c22-2136-4b93-9585-28ed9a27df46", "node_type": "1", "metadata": {}, "hash": "73b27ad7f3beb4d278f6dd140612b53db48f135dbb6d27f36956afa8df3a250e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "50 What are the various Rapid prototyping techniques?  \ni. Dynamic  high level  language  development.  ii. Database   \n programming. iii. Component and application assembly.   \n \n \n \n \n57  \n  \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 Discuss any four process models with suitable application.  NOV/DEC -10 , \nAPR/MAY -11, NOV/DEC -12, MAY/JUN -13 \nA software process model is a standardised format for  \n\u2022 planning  \n\u2022 organising, and  \n\u2022 running a development project  \nHundreds of different models exist and are used, but many are minor variations \non a small number of basic models.  \n1.1. Plan ning with Models  \n(a ) SE projects usually live with a fixed financial budget. (An exception is \nmaintenance?) Additionally, time -to-market places a strong time \nconstraint. There will be other project constraints such as staff.  \nProject planning is the art of sch eduling/constraint solving the project \nparameters, along various dimensions: time, money, staff \u2026 in order to optimize:  \n \u2022 project risk [low]  \n\u2022 profit [high]  \n\u2022customer satisfaction [high]  \n \u2022 Worker satisfaction [high]  \n\u2022 long/short -term company goals  \nProject parameters describe the whole project, but we must at least describe:  \n \u2022 resources needed (people, money, equipment, etc)  \n \u2022 dependency & timing of work (flow graph, work packages)  \n \u2022 rate of delivery (reports, code, etc)  \n \nIn addition to project member s, the following may need access to parts of the \nproject plan:  \n\u2022 Management  \n \u2022 Customers  \n58  \n \u2022 Subcontractors (outsourcing)  \n\u2022 Suppliers (e.g. licenses, strategic partners)  \n \u2022 Investors (long term investment)  \n\u2022 Banks (short term cash)  \n1.2. Project Visibilit y \nUnlike other engineers (e.g. civil, electronic, chemical \u2026 etc.) software \nengineers do not produce anything physical.  \nThis means that SE projects must produce additional deliverables (artifacts) \nwhich are visible, such as:  \n\u2022 Design documents/ prototypes   \n\u2022 Reports  \n\u2022 Project/status meetings  \n\u2022 Client surveys (e.g. satisfaction level)  \nA (software/system) process model is a description of the sequence of activities \ncarried out in an SE project, and the relative order of these activities.  \nIt provides a fixe d generic framework that can be tailored to a specific project. \nProject specific parameters will include:  \n \u2022 Size, (person -years)  \n\u2022 Budget,  \n Duration.  \n project plan = process model + project parameters  \nThere are hundreds of different process models to ch oose from, e.g:  \n\u2022 waterfall,  \n \u2022 code-and-fix  \n\u2022 spiral \n \u2022 rapid prototyping  \n \u2022 unified process (UP)  \n \u2022 agile methods, extreme programming (XP)  \n\u2022 COTS \u2026  \nBut most are minor variations on a small number of basic models . \nBy changing the process model, we ca n improve and/or tradeoff:  \n \u2022 Development speed (time to market)  \n59  \n \u2022 Product quality  \n Project visibility  \n \u2022 Administrative overhead  \n \u2022 Risk exposure  \n \u2022 Customer relations, etc.  \nNormally, a process model covers the entire lifetime of a product.  \nFrom birth of a commercial idea to final de -installation of last release i.e.  \nThe three main phases:  \n \u2022 design,  \n\u2022 build,  \n\u2022 maintain .  \nWe can sometimes combine process models  \ne.g. 1. waterfall inside evolutionary \u2013 onboard shuttle software  \n 2. Evolutionary inside waterfall \u2013 e.g. GUI prototyping  \nWe can also evolve the proc ess model together with the product to \naccount for product maturity, e.g. rapid prototyping \u2192 waterfall  \n2 Explain the execution of seven distinct functions accomplished in requirement \nengineering process / Explain briefly the requirement engineering proce ss with neat \nsketch and describe each process with an example.  APRIL/MAY -15 NOV/DEC -15, \nNOV/DEC 2017, APRIL/MAY  2017  \nIntroduction to requirement engineering  \niv. The process of collecting the software requirement from the client then understand, \nevaluate and do cument it is called as requirement engineering.  \nv. Requirement engineering constructs a bridge for design and construction.  \nRequirement engineering consists of seven different tasks as follow:  \n \n1. Inception  \n\uf0b7 Inception is a task where the requirement engineerin g asks a set of questions to \nestablish a software process.  \n\uf0b7 In this task, it understands the problem and evaluates with the proper solution.  \n\uf0b7 It collaborates with the relationship between the customer and the developer.  \n\uf0b7 The developer and customer decide the overall scope and the nature of the question.  \n2.", "mimetype": "text/plain", "start_char_idx": 85098, "end_char_idx": 89561, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b7dc2c22-2136-4b93-9585-28ed9a27df46": {"__data__": {"id_": "b7dc2c22-2136-4b93-9585-28ed9a27df46", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b1a9726d-ec99-4834-970d-5f151350e4e7", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5e51bf906d5d9c6067852301dba86be43778c26e276bc012a008c51d01f28a05", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d51d616a-59b2-446e-a90a-62b5768c9948", "node_type": "1", "metadata": {}, "hash": "b180bfa216cbf71f58ea09b3160e5d23059223186f1f295873ab0ec81eaecde7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "APRIL/MAY -15 NOV/DEC -15, \nNOV/DEC 2017, APRIL/MAY  2017  \nIntroduction to requirement engineering  \niv. The process of collecting the software requirement from the client then understand, \nevaluate and do cument it is called as requirement engineering.  \nv. Requirement engineering constructs a bridge for design and construction.  \nRequirement engineering consists of seven different tasks as follow:  \n \n1. Inception  \n\uf0b7 Inception is a task where the requirement engineerin g asks a set of questions to \nestablish a software process.  \n\uf0b7 In this task, it understands the problem and evaluates with the proper solution.  \n\uf0b7 It collaborates with the relationship between the customer and the developer.  \n\uf0b7 The developer and customer decide the overall scope and the nature of the question.  \n2. Elicitation  \n60  \n Elicitation means to find the requirements from anybody.  \nThe requirements are difficult because the  following problems occur in elicitation . \n \nProblem of scope:  The customer give the unnecessary t echnical detail rather than \nclarity of the overall system objective.  \n \nProblem of understanding:  Poor understanding between the customer and the \ndeveloper regarding various aspect of the project like capability, limitation of the \ncomputing environment.  \n \nProblem of volatility:  In this problem, the requirements change from time to time \nand it is difficult while developing the project.  \n \n3. Elaboration  \n\uf0b7 In this task, the information taken from user during inception and elaboration and are \nexpanded and refined in elaboration.  \n\uf0b7 Its main task is developing pure model of software using functions, feature and \nconstraints of a software.  \n4. Negotiation  \n\uf0b7 In negotiation task, a software engineer decides the how will the   project be achieved \nwith limited business resources.  \n\uf0b7 To create rough guesses of development and access the impact of the requirement on \nthe project cost and delivery time.  \n5. Specification  \n\uf0b7 In this task, the requirement engineer constructs a final work product.  \n\uf0b7 The work product is in the form of software requi rement specification.  \n\uf0b7 In this task, formalize the requirement of the proposed software such as informative, \nfunctional and behavioral.  \n\uf0b7 The requirement are formalize in both graphical and textual formats.  \n6. Validation  \n\uf0b7 The work product is built as an output  of the requirement engineering and that is \naccessed for the quality through a validation step.  \n\uf0b7 The formal technical reviews from the software engineer, customer and other \nstakeholders helps for the primary requirements validation mechanism.  \n7. Requirement  management  \n\uf0b7 It is a set of activities that help the project team to identify, control and track the \nrequirements and changes can be made to the requirements at any time of the ongoing \nproject.  \n\uf0b7 These tasks start with the identification and assign a unique i dentifier to each of the \nrequirement.  \n61  \n \uf0b7 After finalizing the requirement traceability table is developed.  \n\uf0b7 The examples of traceability table are the features, sources, dependencies, subsystems \nand interface of the requirement  \n3 What is data dictionary? Expl ain. How to select the appropriate  prototyping\n approach? APR/MAY -11, APR/MAY -12, NOV/DEC2015  \nIs a reference work of data about data (metadata), one that is compiled by  \nthe systems analyst to guide them through the analysis and design.  \nIs the information you  see in the data dictionary.  \n\u2022 It is where the systems analyst goes to define or look up information about  \nentities, attributes and relationships on the ERD (Entity Relationship Design).  \nImportance of a Data Dictionary  \nAvoid duplication  \n\u2022 Allows better com munication between organizations who shares the same  \ndatabase.  \n\u2022 Makes maintenance straightforward  \n\u2022 It is valuable for their capacity to cross -referencing data items.  \nUses of Data Dictionary  \nValidates the date flow diagram for completeness and accuracy  \n\u2022 Provides starting point for developing screen and reports.  \n\u2022 Determine the contents of data stored files  \n\u2022 Develop the logic for data flow diagram processes.  \nThe Data Repository  \n \n4 How does the analysis modeling help to capture unambiguous & consistent \nrequirements? Discuss several methods for requirements validation? NOV/DEC -11 \nData modeling is a  process  used to define and analyze data  requirements  needed to support \nthe business processes  within the scope of corresponding information systems in \norganizations. Therefore, the process of data modeling involves professional data modelers \nworking closely with business stakeholders, as well as potential users of the information \nsystem.  \nThere are three different types of data models produced while pr ogressing from \nrequirements to the actual database to be used for the information system.", "mimetype": "text/plain", "start_char_idx": 88764, "end_char_idx": 93608, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d51d616a-59b2-446e-a90a-62b5768c9948": {"__data__": {"id_": "d51d616a-59b2-446e-a90a-62b5768c9948", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b7dc2c22-2136-4b93-9585-28ed9a27df46", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e79f502118a27ebf8fe2178318d0659172c36be969ca6768ab29401531c0f5f6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32", "node_type": "1", "metadata": {}, "hash": "08901eb58ed3a9cd98ffa02b7e7bcdbdd4feaae3c7c3c4bceb7ed0afe01f54b5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Uses of Data Dictionary  \nValidates the date flow diagram for completeness and accuracy  \n\u2022 Provides starting point for developing screen and reports.  \n\u2022 Determine the contents of data stored files  \n\u2022 Develop the logic for data flow diagram processes.  \nThe Data Repository  \n \n4 How does the analysis modeling help to capture unambiguous & consistent \nrequirements? Discuss several methods for requirements validation? NOV/DEC -11 \nData modeling is a  process  used to define and analyze data  requirements  needed to support \nthe business processes  within the scope of corresponding information systems in \norganizations. Therefore, the process of data modeling involves professional data modelers \nworking closely with business stakeholders, as well as potential users of the information \nsystem.  \nThere are three different types of data models produced while pr ogressing from \nrequirements to the actual database to be used for the information system.[2] The data \nrequirements are initially recorded as a  conceptual data model  which is essentially a set of \ntechnology independent specifications about the data and is used to discuss initial \nrequirements with the business stakeholders. The  conceptual model  is then translated into \na logical data model , which documents structures of the data that can be implemented in \ndatabases. Implementation of one conceptual data model may require multiple logical data \nmodels. The last step in data modeling is transforming the logical data model to a  physical \ndata model  that organizes the data into tables, and accounts for access, performance and \n62  \n storage details. Data modeling defines not just data elements, but also their structures and \nthe relationships b etween them.[3] \nData modeling techniques and methodologies are used to model data in a standard, \nconsistent, predictable manner in order to manage it as a resource. The use of dat a modeling \nstandards is strongly recommended for all projects requiring a standard means of defining \nand analyzing data within an organization, e.g., using data modeling:  \n\uf0b7 to assist business analysts, programmers, testers, manual writers, IT package \nselecto rs, engineers, managers, related organizations and clients to understand and use \nan agreed semi -formal model the concepts of the organization and how they relate to \none another  \n\uf0b7 to manage data as a resource  \n\uf0b7 for the integration of information systems  \n\uf0b7 for des igning databases/data warehouses (aka data repositories)  \nData modeling may be performed during various types of projects and in multiple phases of \nprojects. Data models are progressive; there is no such thing as the final data model for a \nbusiness or appli cation. Instead a data model should be considered a living document that \nwill change in response to a changing business. The data models should ideally be stored in \na repository so that they can be retrieved, expanded, and edited over time.    \n\uf0b7 Strategic dat a modeling: This is part of the creation of an information systems strategy, \nwhich defines an overall vision and architecture for information systems.  Information \ntechnology engineering  is a methodology that embraces this approach.  \n\uf0b7 Data modeling during systems analysis: In  systems analysis  logical data mo dels are created \nas part of the development of new databases.  \nData modeling is also used as a technique for detailing business  requirements  for specific  databases . \nIt is sometimes called  database modeling  because a  data model  is eventually implemented in a \ndatabase.  \n \n5 Explain prototyping in t he software process. APRIL/MAY -15 MAY/JUNE 2016  \nThe prototyping model  is applied when detailed  information  related to input and output \nrequirements of the system is not available. In this model, it is assumed that all the \nrequirements may not be known at the start of the development of the system. It is usually \nused when a system does not exist or in case of a lar ge and complex system where there is no \nmanual process to determine the requirements. This model allows the users to interact and \nexperiment with a working model of the system known as  prototype.  The prototype gives the \nuser an actual feel of the system.  \nAt any stage, if the user is not satisfied with the prototype, it can be discarded and an entirely new \nsystem can be developed. Generally, prototype can be prepared by the approaches listed below.  \n\u2022 By creating main user interfaces without any substantial c oding so that users can get a feel of how \nthe actual system will appear.  \n\u2022 By abbreviating a version of the system that will perform limited subsets of functions.  \n\u2022 By using system components to illustrate the functions that will be included in the system to be \ndeveloped .  \n63  \n  Using the prototype, the client can get an actual feel of the system. So, this case of model is \nbeneficial in the case when requirements cannot be freezed initially.", "mimetype": "text/plain", "start_char_idx": 92648, "end_char_idx": 97605, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32": {"__data__": {"id_": "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d51d616a-59b2-446e-a90a-62b5768c9948", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "dd3e1693c3191fd3fb2e2391f427f0a25a35054185d7686e234eda5e0990d5e2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f910cc61-52c5-4ad7-b537-a5033fcddf73", "node_type": "1", "metadata": {}, "hash": "3932fd50a631362a49ff6b463ef9bae9bd4debd3e53873c5466b34944c34cfb0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This model allows the users to interact and \nexperiment with a working model of the system known as  prototype.  The prototype gives the \nuser an actual feel of the system.  \nAt any stage, if the user is not satisfied with the prototype, it can be discarded and an entirely new \nsystem can be developed. Generally, prototype can be prepared by the approaches listed below.  \n\u2022 By creating main user interfaces without any substantial c oding so that users can get a feel of how \nthe actual system will appear.  \n\u2022 By abbreviating a version of the system that will perform limited subsets of functions.  \n\u2022 By using system components to illustrate the functions that will be included in the system to be \ndeveloped .  \n63  \n  Using the prototype, the client can get an actual feel of the system. So, this case of model is \nbeneficial in the case when requirements cannot be freezed initially.  \n This prototype is developed based on the currently known requirements.  Development of the \nprototype obviously undergoes design, coding, and testing,   but each of these phases is not done \nvery formally or thoroughly.   \nBy using this prototype, the client can get an actual feel of the system, because the interactions with \nthe p rototype can enable the client to better understand the requirements of the desired system . \n \n6 Explain the functional & behavioral model for software  \n requirements  process?  NOV/DEC -12, MAY/JUN - 13,NOV/DEC 2013  \n functional requirement  specifies something that the application or system should do. \nOften, this is defined as a behavior of the system that takes input and provides output. For \nexample, a traveler fills out a form in an airline's mobile application with his/her name and \npassport details (input), s ubmits the form, and the application generates a boarding pass \nwith the traveler's details (output).  \nNon-functional requirements , sometimes also called quality requirements, describe how \nthe system should be, as opposed to what it should do. Non -functional  requirements of a \nsystem include performance (e.g., response time), maintainability and scalability, among \nmany others. In the airline application example, the requirement that the application must \ndisplay the boarding pass after a maximum of five seconds  from the time the traveler \npresses the 'submit' button would be a non -functional requirement.  \n \n7 Explain metrics for specifying non -functional requirements? IEEE standarad \nsoftware requirement document? MAY/JUN - 13 \nAccording to IEEE standard 729, a requi rement is defined as follows:  \n\uf0b7 A condition or capability needed by a user to solve a problem or achieve an objective  \n\uf0b7 A condition or capability that must be met or possessed by a system or system component to \nsatisfy a contract, standard, specification or ot her formally imposed documents  \n\uf0b7 A documented representation of a condition or capability as in 1 and 2.  \nA software requirement can be of 3 types:  \n\uf0b7 Functional requirements  \n\uf0b7 Non-functional requirements  \n\uf0b7 Domain requirements  \nFunctional Requirements:  These are the requirements that the end user specifically demands as \nbasic facilities that the system should offer. All these functionalities need to be necessarily \nincorporated into the system as a part of the contract. These are represented or stated in the form of \ninput to be given to the system, the operation performed and the output expected. They are basically \nthe requirements stated by the user which one can see directly in the final product, unlike the non -\nfunctional requirements.  \nFor example, in a hospital manag ement system, a doctor should be able to retrieve the information \nof his patients. Each high -level functional requirement may involve several interactions or dialogues \nbetween the system and the outside world. In order to accurately describe the functional  \nrequirements, all scenarios must be enumerated.  \nThere are many ways of expressing functional requirements e.g., natural language, a structured or \n64  \n formatted language with no rigorous syntax and formal specification language with proper syntax.  \nNon-function al requirements:  These are basically the quality constraints that the system must \nsatisfy according to the project contract. The priority or extent to which these factors are \nimplemented varies from one project to other. They are also called non -behavioral  requirements.  \nThey basically deal with issues like:  \n\uf0b7 Portability  \n\uf0b7 Security  \n\uf0b7 Maintainability  \n\uf0b7 Reliability  \n\uf0b7 Scalability  \n\uf0b7 Performance  \n\uf0b7 Reusability  \n\uf0b7 Flexibility  \nNFR\u2019s are classified into following types:  \n\uf0b7 Interface constraints  \n\uf0b7 Performance constraints: response time, s ecurity, storage space, etc.  \n\uf0b7 Operating constraints  \n\uf0b7 Life cycle constraints: maintainability, portability, etc.", "mimetype": "text/plain", "start_char_idx": 96714, "end_char_idx": 101529, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f910cc61-52c5-4ad7-b537-a5033fcddf73": {"__data__": {"id_": "f910cc61-52c5-4ad7-b537-a5033fcddf73", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1539dc9a528c2231bc272b2ad98a2bbe266a29ecebffafadfb9f9f35998e327c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "ca460780-de4d-4596-abca-57b8306cce6f", "node_type": "1", "metadata": {}, "hash": "41b58e4646a82369594ff53e9e2fd90ed623a72db2bb303d74513524475ad33a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "There are many ways of expressing functional requirements e.g., natural language, a structured or \n64  \n formatted language with no rigorous syntax and formal specification language with proper syntax.  \nNon-function al requirements:  These are basically the quality constraints that the system must \nsatisfy according to the project contract. The priority or extent to which these factors are \nimplemented varies from one project to other. They are also called non -behavioral  requirements.  \nThey basically deal with issues like:  \n\uf0b7 Portability  \n\uf0b7 Security  \n\uf0b7 Maintainability  \n\uf0b7 Reliability  \n\uf0b7 Scalability  \n\uf0b7 Performance  \n\uf0b7 Reusability  \n\uf0b7 Flexibility  \nNFR\u2019s are classified into following types:  \n\uf0b7 Interface constraints  \n\uf0b7 Performance constraints: response time, s ecurity, storage space, etc.  \n\uf0b7 Operating constraints  \n\uf0b7 Life cycle constraints: maintainability, portability, etc.  \n\uf0b7 Economic constraints  \nThe process of specifying non -functional requirements requires the knowledge of the functionality \nof the system, as well as t he knowledge of the context within which the system will operate.  \nDomain requirements:  Domain requirements are the requirements which are characteristic of a \nparticular category or domain of projects. The basic functions that a system of a specific domain \nmust necessarily exhibit come under this category. For instance, in academic software that maintains \nrecords of a school or college, the functionality of being able to access the list of faculty and list of \nstudents of each grade is a domain requirement. T hese requirements are therefore identified from \nthat domain model and are not user specific.  \n \n \n \n8 What is requirements elicitation ? Explain various activities performed in it with \nwatch system that facilitates to set time and alarm as an example? NOV/DEC 2016, \nAPRIL/MAY  2017, APRIL/MAY 2018  \nRequirements  elicitation  is perhaps the most difficult, most error -prone and most communication \nintensive software development. It can be successful only through an effective customer -developer \npartnership. It is needed  to know what the users really need.  \nThere are a number of requirements elicitation methods. Few of them are listed below \u2013 \n1. Interviews  \n2. Brainstorming Sessions  \n3. Facilitated Application Specification Technique (FAST)  \n4. Quality Function Deployment (QFD)  \n5. Use Case Approach  \nThe success of an elicitation technique used depends on the maturity of the analyst, developers, \nusers and the customer involved.  \n1. Interviews:  \nObjective of conducting an interview is to understand the customer\u2019s expectations from the \nsoftware.  \nIt is impossible to interview every stakeholder hence representatives from groups are selected based \n65  \n on their expertise and credibility.  \nInterviews maybe be open ended or structured.  \n1. In open ended interviews there is no pre -set agenda. Context free question s may be asked to \nunderstand the problem.  \n2. In structured interview, agenda of fairly open questions is prepared. Sometimes a proper \nquestionnaire is designed for the interview.  \n2. Brainstorming Sessions:  \n\uf0b7 It is a group technique  \n\uf0b7 It is intended to generate lo ts of new ideas hence providing a platform to share views  \n\uf0b7 A highly trained facilitator is required to handle group bias and group conflicts.  \n\uf0b7 Every idea is documented so that everyone can see it.  \n\uf0b7 Finally a document is prepared which consists of the list of requirements and their priority if \npossible.  \n3. Facilitated Application Specification Technique:  \nIt\u2019s objective is to bridge the expectation gap \u2013 difference between what the developers think they \nare supposed to build and what customers think they are goi ng to get.  \nA team oriented approach is developed for requirements gathering.  \nEach attendee is asked to make a list of objects that are - \n1. Part of the environment that surrounds the system  \n2. Produced by the system  \n3. Used by the system  \nEach participant prepares hi s/her list, different lists are then combined, redundant entries are \neliminated, team is divided into smaller sub -teams to develop mini -specifications and finally a draft \nof specifications is written down using all the inputs from the meeting.  \n4. Quality F unction Deployment:  \nIn this technique customer satisfaction is of prime concern, hence it emphasizes on the requirements \nwhich are valuable to the customer.  \n3 types of requirements are identified \u2013 \n\uf0b7 Normal  requirements  \u2013 In this the objective and goals of t he proposed software are \ndiscussed with the customer.", "mimetype": "text/plain", "start_char_idx": 100633, "end_char_idx": 105222, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ca460780-de4d-4596-abca-57b8306cce6f": {"__data__": {"id_": "ca460780-de4d-4596-abca-57b8306cce6f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f910cc61-52c5-4ad7-b537-a5033fcddf73", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "504b40fec89ea933378344346ef339877a572f054fe24b0a3aec0d2e9626d9dc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d8d48aae-3f6f-4321-bbdc-689c17b657af", "node_type": "1", "metadata": {}, "hash": "b60f7a9e6bc8795660282369c48ba3202aff9cdb5c1c8261fca6f59b468e340a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A team oriented approach is developed for requirements gathering.  \nEach attendee is asked to make a list of objects that are - \n1. Part of the environment that surrounds the system  \n2. Produced by the system  \n3. Used by the system  \nEach participant prepares hi s/her list, different lists are then combined, redundant entries are \neliminated, team is divided into smaller sub -teams to develop mini -specifications and finally a draft \nof specifications is written down using all the inputs from the meeting.  \n4. Quality F unction Deployment:  \nIn this technique customer satisfaction is of prime concern, hence it emphasizes on the requirements \nwhich are valuable to the customer.  \n3 types of requirements are identified \u2013 \n\uf0b7 Normal  requirements  \u2013 In this the objective and goals of t he proposed software are \ndiscussed with the customer. Example \u2013 normal requirements for a result management system \nmay be entry of marks, calculation of results etc  \n\uf0b7 Expected  requirements  \u2013 These requirements are so obvious that the customer need not \nexplic itly state them. Example \u2013 protection from unauthorised access.  \n\uf0b7 Exciting  requirements  \u2013 It includes features that are beyond customer\u2019s expectations and \nprove to be very satisfying when present. Example \u2013 when an unauthorised access is detected, it \nshould backup and shutdown all processes.  \nThe major steps involved in this procedure are \u2013 \n1. Identify all the stakeholders, eg. Users, developers, customers etc  \n2. List out all requirements from customer.  \n3. A value indicating degree of importance is assigned to each req uirement.  \n4. In the end the final list of requirements is categorised as \u2013 \n\uf0b7 It is possible to achieve  \n\uf0b7 It should be deferred and the reason for it  \n\uf0b7 It is impossible to achieve and should be dropped off  \n5. Use Case Approach:  \nThis technique combines text and pictu res to provide a better understanding of the requirements.  \nThe use cases describe the \u2018what\u2019, of a system and not \u2018how\u2019. Hence they only give a functional \nview of the system.  \nThe components of the use case deign includes three major things \u2013 Actor, Use cas es, use case \n66  \n diagram.  \n1. Actor  \u2013 It is the external agent that lies outside the system but interacts with it in some way. \nAn actor maybe a person, machine etc. It is represented as a stick figure. Actors can be primary \nactors or secondary actors.  \n\uf0b7 Primary acto rs \u2013 It requires assistance from the system to achieve a goal.  \n\uf0b7 Secondary actor \u2013 It is an actor from which the system needs assistance.  \n2. Use cases  \u2013 They describe the sequence of interactions between actors and the system. They \ncapture who(actors) do what(i nteraction) with the system. A complete set of use cases specifies \nall possible ways to use the system.  \n3. Use case diagram  \u2013 A use case diiagram graphically represents what happens when an \nactor interacts with a system. It captures the functional aspect of t he system.  \n\uf0b7 A stick figure is used to represent an actor.  \n\uf0b7 An oval is used to represent a use case.  \n\uf0b7 A line is used to represent a relationship between an actor and a use case  \n \n \n9 What is the purpose of data flow diagrams? What are the notations used for the  \nsame. Explain by constructing a context flow diagram level -0 DFD and level -1 DFD \nfor a library management system? NOV/DEC 2016  \nIn Software engineering DFD(data flow diagram) can be drawn to represent the system of different \nlevels of abstraction. Higher level DFDs are partitioned into low levels -hacking more information \nand functional elements. Levels in DFD are numbered 0, 1, 2 or beyond. Here, we will see mainly 3 \nlevels in data flow diagram, which are: 0 -level DFD, 1 -level DFD, and 2 -level DFD.  \n0-level  DFD:  \nIt is also known as context diagram.It\u2019s designed to be an abstraction view, showing the system as a \nsingle process with its relationship to external entities. It represent the entire system as single bubble \nwith input and output data indicated by in coming/outgoing arrows.  \n \n1-level  DFD:  \nIn 1-level DFD, context diagram is decomposed into multiple bubbles/processes.in this level we \nhighlight the main functions of the system and breakdown the high level process of 0 -level DFD \ninto subprocesses.", "mimetype": "text/plain", "start_char_idx": 104373, "end_char_idx": 108634, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d8d48aae-3f6f-4321-bbdc-689c17b657af": {"__data__": {"id_": "d8d48aae-3f6f-4321-bbdc-689c17b657af", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "ca460780-de4d-4596-abca-57b8306cce6f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "971f11800e73bd72cabe5f3bdf6d9c64d840301626ac8c1d5fd56fb2a026ed67", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "04d37175-a2ff-4c7f-963c-0b0566728f32", "node_type": "1", "metadata": {}, "hash": "19b21a23dd151c13207690fd98d11c7f591d465f2056a04b5704c9742f1672e4", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Higher level DFDs are partitioned into low levels -hacking more information \nand functional elements. Levels in DFD are numbered 0, 1, 2 or beyond. Here, we will see mainly 3 \nlevels in data flow diagram, which are: 0 -level DFD, 1 -level DFD, and 2 -level DFD.  \n0-level  DFD:  \nIt is also known as context diagram.It\u2019s designed to be an abstraction view, showing the system as a \nsingle process with its relationship to external entities. It represent the entire system as single bubble \nwith input and output data indicated by in coming/outgoing arrows.  \n \n1-level  DFD:  \nIn 1-level DFD, context diagram is decomposed into multiple bubbles/processes.in this level we \nhighlight the main functions of the system and breakdown the high level process of 0 -level DFD \ninto subprocesses.  \n \n67  \n \n \n2-level  DFD:  \n2-level DFD goes one step deeper into parts of 1 -level DFD.It can be used to plan or record \nthe specific/necessary detail about the system\u2019s functioning.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n68  \n  \n \n \n \n10 Consider the process of ordering a pizza over the phone. Draw the us e case diagram \nand also sketch the activity diagram representing each step of the process, from the \nmoment you pick up the phone to the point where you start eating the pizza. Include \nactivities that others need to perform. Add exception handling to the ac tivity \ndiagram you developed. Consider at least two exceptions.(Ex : Delivery person wrote \ndown wrong address, deliver person brings wrong pizza). NOV/DEC 2017  \n \n \n69  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n70  \n  \n \n11 Explain the feasibility studies. What are the outcomes? Does it have implicit or \nexplicit effects on software requirement  \ncollection. APRIL/MAY 2017  \nA feasibility study is carried out to select the best system that meets perfo rmance requirements.  \nThe main aim of the feasibility study activity is to determine whether it would be financially and \ntechnically feasible to develop the product. The feasibility study activity involves the analysis of \nthe problem and collection of all r elevant information relating to the product such as the different \ndata items which would be input to the system, the processing required to be carried out on these \ndata, the output data required to be produced by the system as well as various constraints o n the \nbehaviour of the system.  \n \n \nTechnical Feasibility  \nThis is concerned with specifying equipment and software that will successfully satisfy the user \nrequirement. The technical needs of the system may vary considerably, but might include :  \n\u2022 The facility  to produce outputs in a given time.  \n\u2022 Response time under certain conditions.  \n\u2022 Ability to process a certain volume of transaction at a particular speed.  \n\u2022 Facility to communicate data to distant locations.  \nIn examining technical feasibility, configuratio n of the system is given more importance than the \nactual make of hardware. The configuration should give the complete picture about the system\u2019s \nrequirements:  \nHow many workstations are required, how these units are interconnected so that they could operate  \nand communicate smoothly.  \nWhat speeds of input and output should be achieved at particular quality of printing.  \n \n \nEconomic Feasibility  \nEconomic analysis is the most frequently used technique for evaluating the effectiveness of a \nproposed system. More comm only known as Cost / Benefit analysis, the procedure is to determine \nthe benefits and savings that are expected from a proposed system and compare them with costs. If \nbenefits outweigh costs, a decision is taken to design and implement the system. Otherwis e, further \njustification or alternative in the proposed system will have to be made if it is to have a chance of \nbeing approved. This is an outgoing effort that improves in accuracy at each phase of the system \nlife cycle.  \n \n \nOperational Feasibility  \nThis is mainly related to human organizational and political aspects. The points to be considered \nare: \n\u2022 What changes will be brought with the system?  \n\u2022 What organizational structure are disturbed?  \n71  \n \u2022 What new skills will be required? Do the existing staff members have these skills? If not, can \nthey be trained in due course of time?  \nThis feasibility study is carried out by a small group of people who are familiar with information \nsystem technique and are skilled in system analysis and design process.  \nProposed projec ts are beneficial only if they can be turned into information system that will meet \nthe operating requirements of the organization. This test of feasibility asks if the system will work \nwhen it is developed and installed.", "mimetype": "text/plain", "start_char_idx": 107846, "end_char_idx": 112526, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "04d37175-a2ff-4c7f-963c-0b0566728f32": {"__data__": {"id_": "04d37175-a2ff-4c7f-963c-0b0566728f32", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d8d48aae-3f6f-4321-bbdc-689c17b657af", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e764b5e9f0f7f78964da5dabd153cb31b662185ca7271ebe2f66a562e9cb60ba", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3", "node_type": "1", "metadata": {}, "hash": "dfd0fb11e583a248c16772a1dc6de150e2c645ceaf67f7a8452f8063eefda7a1", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "This is an outgoing effort that improves in accuracy at each phase of the system \nlife cycle.  \n \n \nOperational Feasibility  \nThis is mainly related to human organizational and political aspects. The points to be considered \nare: \n\u2022 What changes will be brought with the system?  \n\u2022 What organizational structure are disturbed?  \n71  \n \u2022 What new skills will be required? Do the existing staff members have these skills? If not, can \nthey be trained in due course of time?  \nThis feasibility study is carried out by a small group of people who are familiar with information \nsystem technique and are skilled in system analysis and design process.  \nProposed projec ts are beneficial only if they can be turned into information system that will meet \nthe operating requirements of the organization. This test of feasibility asks if the system will work \nwhen it is developed and installed.  \n \n \n \n \n \n12 What is SRS?Explain in de tail about various component of an SRS.  \nThe output of the requirements phase of the software development process is  Software \nRequirements Specification (SRS)  (also known as  requirements  document).  This document lays \na foundation for software engineering ac tivities and is created when entire requirements are elicited \nand analyzed. SRS is a formal document, which acts as a representation of software that enables \nthe users to review whether it (SRS) is according to their requirements. In addition, it includes user \nrequirements for a system as well as detailed specifications of the system requirements.  \nIEEE  defines software requirements specification as, 'a document that clearly and precisely \ndescribes each of the essential requirements (functions, performance, design constraints and quality \nattributes) of the software and the external interfaces. Each requirement is defined in such a way that \nits achievement can be objectively verified by a prescribed method, for example, inspection, \ndemonstration, analysis or t est.' Note that requirements specification can be in the form of a \nwritten  document, a mathematical model, a collection of graphical models, a prototype,  and so on.  \nEssentially, what passes from requirements analysis activity to the specification activity is the \nknowledge acquired about the system. The need for maintaining a requirements document is that the \nmodeling activity essentially focuses on the problem structure and not its structural behavior. While \nin SRS, performance constraints, design constrain ts, and standard compliance recovery are clearly \nspecified. This  information  helps in developing a proper des ign of the system. Various other \npurposes served by SRS are listed below.  \n1. Feedback:  Provides a feedback, which ensures to the user that the organization (which \ndevelops the software) understands the issues or problems to be solved and the software behavior  \nnecessary to address those problems.  \n2. Decompose problem into components:  Organizes the information and divides the problem \ninto its component parts in an orderly manner.  \n3. Validation:  Uses validation strategies applied to the requirements to acknowledge that  \nrequirements are stated properly.  \n4. Input to design:  Contains sufficient detail in the functional system requirements to devise a \ndesign solution.  \n5. Basis for agreement between the  user and  the organization:  Provides a complete \ndescription of the functions to  be performed by the system. In addition, it helps the users to \ndetermine whether the specified requirements are accomplished.  \n6. Reduce the development effort:  Enables developers to consider user requirements before \nthe designing of the system commences. As a result, 'rework' and inconsistencies in the later stages \ncan be reduced.  \n7. Estimating costs and schedules:  Determines the requirements of the system and thus \nenables the developer to have a 'rough' estimate of the total cost and schedule of the project.  \nSRS is used by various individuals in the organization. System customers need SRS to specify and \n72  \n verify whether requirements meet the desired needs. In addition, SRS enables the managers to plan \nfor the system development processes. System engineers need a r equirements document to \nunderstand what system is to be developed. These engineers also require this document to develop \nvalidation tests for the required system. Lastly, requirements document is needed by system \nmaintenance engineers to use the requiremen t and the relationship between its parts.  \nCharacteristics of SRS  \nSoftware requirements specification should be accurate, complete, efficient, and of high quality, so \nthat it does not affect the entire project plan. An SRS is said to be of high quality when  the \ndeveloper and user easily understand the prepared document. Other characteristics of SRS are \ndiscussed below.  \n1. Correct:  SRS is correct when all user requirements are stated in the requirements \ndocument. The stated requirements should be according to th e desired system.", "mimetype": "text/plain", "start_char_idx": 111638, "end_char_idx": 116657, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3": {"__data__": {"id_": "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "04d37175-a2ff-4c7f-963c-0b0566728f32", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "59f7c91c310c7f8f10f122916d573d568bdc95c7fafb77294c6279a60330e150", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a", "node_type": "1", "metadata": {}, "hash": "1075970934fecd38579d7cfdbab5c5a779d2d13f1bd866ac0eb0b25fbc38c8fc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In addition, SRS enables the managers to plan \nfor the system development processes. System engineers need a r equirements document to \nunderstand what system is to be developed. These engineers also require this document to develop \nvalidation tests for the required system. Lastly, requirements document is needed by system \nmaintenance engineers to use the requiremen t and the relationship between its parts.  \nCharacteristics of SRS  \nSoftware requirements specification should be accurate, complete, efficient, and of high quality, so \nthat it does not affect the entire project plan. An SRS is said to be of high quality when  the \ndeveloper and user easily understand the prepared document. Other characteristics of SRS are \ndiscussed below.  \n1. Correct:  SRS is correct when all user requirements are stated in the requirements \ndocument. The stated requirements should be according to th e desired system. This implies that each \nrequirement is examined to ensure that it (SRS) represents user requirements. Note that there is no \nspecified tool or procedure to assure the correctness of SRS. Correctness ensures that all specified \nrequirements a re performed correctly.  \n2. Unambiguous:  SRS is unambiguous when every stated requirement has only one \ninterpretation. This implies that each requirement is uniquely interpreted. In case there is a term used \nwith multiple meanings, the requirements document sh ould specify the meanings in the SRS so that \nit is clear and easy to understand.  \n3. Complete:  SRS is complete when the requirements clearly define what the software is \nrequired to do. This includes all the requirements related to performance, design and funct ionality.  \n4. Ranked for importance/stability:  All requirements are not equally important, hence each \nrequirement is identified to make differences among other requirements. For this, it is essential to \nclearly identify each requirement. Stability implies the probability of changes in the requirement in \nfuture.  \n5. Modifiable:  The requirements of the user can change, hence requirements document should \nbe created in such a manner that those changes can be modified easily, consistently maintaining the \nstructure and s tyle of the SRS.  \n6. Traceable:  SRS is traceable when the source of each requirement is clear and facilitates the \nreference of each requirement in future. For this, forward tracing and backward tracing are used. \nForward tracing implies that each requirement sh ould be traceable to design and code elements. \nBackward tracing implies defining each requirement explicitly referencing its source.  \n7. Verifiable:  SRS is verifiable when the specified requirements can be verified with a cost -\neffective process to check whethe r the final software meets those requirements. The requirements \nare verified with the help of reviews. Note that unambiguity is essential for verifiability.  \n8. Consistent:  SRS is consistent when the subsets of individual requirements defined do not \nconflict w ith each other. For example, there can be a case when different requirements can use \ndifferent terms to refer to the same object. There can be logical or temporal conflicts between the \nspecified requirements and some requirements whose logical or temporal characteristics are not \nsatisfied. For instance, a requirement states that an event 'a' is to occur before another event 'b'. But \nthen another set of requirements states (directly or indirectly by transitivity) that event 'b' should \noccur before event 'a'.  \nStructure of SRS  \nThe requirements document is devised in a manner that is easier to write, review, and maintain. It is \norganized into independent sections and each section is organized into modules or units. Note that \nthe level of detail to be included in  the SRS depends on the type of the system to be developed and \nthe process model chosen for its development. For example, if a system is to be developed by an \nexternal contractor, then critical system specifications need to be precise and detailed. Similar ly, \n73  \n when flexibility is required in the requirements and where an in -house development takes place, \nrequirements documents can be less detailed.  \nSince the requirements document serves as a foundation for subsequent software development \nphases, it is import ant to develop the document in the prescribed manner. For this, certain guidelines \nare followed while preparing SRS. These guidelines are listed below.  \n1. Functionality:  It should be separate from implementation.  \n2. Analysis model:  It should be developed accordi ng to the desired behavior of a system. This \nshould include data and functional response of a system to various inputs given to it.  \n3. Cognitive model:  It should be developed independently of design or implementation \nmodel.", "mimetype": "text/plain", "start_char_idx": 115741, "end_char_idx": 120562, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a": {"__data__": {"id_": "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "8017b308972112b43aa7685e0181c1ad7f0b5ed99031ee9d5ab1cd85692da219", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f4504b97-2ace-4b7f-8028-5f7955354fa6", "node_type": "1", "metadata": {}, "hash": "e341e86b35e8a954b2e01f6875af3303fb35dbd0fb8d8d8fe79155975a7a74cf", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For example, if a system is to be developed by an \nexternal contractor, then critical system specifications need to be precise and detailed. Similar ly, \n73  \n when flexibility is required in the requirements and where an in -house development takes place, \nrequirements documents can be less detailed.  \nSince the requirements document serves as a foundation for subsequent software development \nphases, it is import ant to develop the document in the prescribed manner. For this, certain guidelines \nare followed while preparing SRS. These guidelines are listed below.  \n1. Functionality:  It should be separate from implementation.  \n2. Analysis model:  It should be developed accordi ng to the desired behavior of a system. This \nshould include data and functional response of a system to various inputs given to it.  \n3. Cognitive model:  It should be developed independently of design or implementation \nmodel. This model expresses a system as pe rceived by the users.  \n4. The content and structure  of the  specification:  It should be flexible enough to \naccommodate changes.  \n5. Specification:  It should be robust. That is, it should be tolerant towards incompleteness and \ncomplexity.  \nThe information to be inclu ded in SRS depends on a number of factors, for example, the type of \nsoftware being developed and the approach used in its development. If software is developed using \nthe iterative development process, the requirements document will be less detailed as comp ared to \nthat of the software developed for critical systems. This is because specifications need to be very \ndetailed and accurate in these systems. A number of standards have been suggested to develop a \nrequirements document. However, the most widely used standard is by IEEE, which acts as a \ngeneral framework. This general framework can be customized and adapted to meet the needs of a \nparticular organization.  \nEach SRS fits a certain pattern; thus, it is essential to standardize the structure of the requirem ents \ndocument to make it easier to understand. For this IEEE standard is used for SRS to organize \nrequirements for different projects, which provides different ways of structuring SRS. Note that in \nall requirements documents, the first two sections are the  same.  \nThis document comprises the following sections.  \n1. Introduction:  This provides an overview of the entire information described in SRS. This \ninvolves purpose and the scope of SRS, which states the functions to be performed by the system. In \naddition, it  describes definitions, abbreviations, and the acronyms used. The references used in SRS \nprovide a list of documents that is referenced in the document.  \n2. Overall description:  It determines the factors which affect the requirements of the system. \nIt provides  a brief description of the requirements to be defined in the next section called 'specific \nrequirement'. It comprises the following sub -sections.  \n3. Product perspective:  It determines whether the product is an independent product or an \nintegral part of the l arger product. It determines the interface with hardware, software, system, and \ncommunication. It also defines memory constraints and operations utilized by the user.  \n4. Product functions:  It provides a summary of the functions to be performed by the software . \nThe functions are organized in a list so that they are easily understandable by the user:  \n5. User characteristics:  It determines general characteristics of the users.  \n6. Constraints:  It provides the genera1 description of the constraints such as regulatory \npolicies, audit functions, reliability requirements, and so on.  \n7. Assumption and dependency:  It provides a list of assumptions and factors that affect the \nrequirements as stated in this document.  \n8. Apportioning of requirements:  It determines the requirements that  can be delayed until \nrelease of future versions of the system.  \n9. Specific requirements:  These determine all requirements in detail so that the designers can \ndesign the system in accordance with them. The requirements include description of every input and \noutput of the system and functions performed in response to the input provided. It comprises the \n74  \n following subsections.  \n10. External interface:  It determines the interface of the software with other systems, which \ncan include interface with  operating system  and so on. External interface also specifies  the \ninteraction of the software with users, hardware, or other software. The characteristics of each user \ninterface of the software product are specified in SRS. For the hardware interface, SRS specifies the \nlogical characteristics of each interface among  the software and hardware components. If the \nsoftware is to be executed on the existing hardware, then characteristics such as memory restrictions \nare also specified.", "mimetype": "text/plain", "start_char_idx": 119646, "end_char_idx": 124524, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f4504b97-2ace-4b7f-8028-5f7955354fa6": {"__data__": {"id_": "f4504b97-2ace-4b7f-8028-5f7955354fa6", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f66508c77706d5c2aa400fbdc2135d06065a9ddcfc1bae3b61e2dd367e0c0231", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76", "node_type": "1", "metadata": {}, "hash": "052383752765f9497847683ba645ed40e4b11dd78953a92d44e0be74353aba51", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "9. Specific requirements:  These determine all requirements in detail so that the designers can \ndesign the system in accordance with them. The requirements include description of every input and \noutput of the system and functions performed in response to the input provided. It comprises the \n74  \n following subsections.  \n10. External interface:  It determines the interface of the software with other systems, which \ncan include interface with  operating system  and so on. External interface also specifies  the \ninteraction of the software with users, hardware, or other software. The characteristics of each user \ninterface of the software product are specified in SRS. For the hardware interface, SRS specifies the \nlogical characteristics of each interface among  the software and hardware components. If the \nsoftware is to be executed on the existing hardware, then characteristics such as memory restrictions \nare also specified.  \n11. Functions:  It determines the functional capabilities of the system. For each functional \nrequirement, the accepting and processing of inputs in order to generate outputs are specified. This \nincludes validity checks on inputs, exact sequence of operations, relationship of inputs to output, and \nso on.  \n12. Performance requirements:  It determines the performance constraints of the software \nsystem. Performance requirement is of two types: static requirements and dynamic \nrequirements.  Static requirements  (also known as  capacity requirements)  do not impose \nconstraints on the execution characteristics of t he system. These include requirements like number \nof terminals and users to be supported.  Dynamic requirements  determine the constraints on the \nexecution of the behavior of the system, which includes response time (the time between the start \nand ending of an operation under specified conditions) and throughput (total amount of work done \nin a given time).  \n13. Logical  database  of requirements:  It determines logical requirements to be stored in the \ndatabase. This includes type of information used, frequency of usage, data entities and relationships \namong them, and so on.  \n14. Design constraint:  It determines all design constraints that are imposed by standards, \nhardware limitations, and so on. Standard compliance determines requirements for the system, \nwhich are in compliance with the specified standards. These standards can include accounting \nprocedures and report format. Hardware limit ations implies when the software can operate on \nexisting hardware or some pre -determined hardware. This can impose restrictions while developing \nthe software design. Hardware limitations include hardware configuration of the machine and \noperating system to  be used.  \n15. Software system attributes:  It provide attributes such as reliability, availability, \nmaintainability and portability. It is essential to describe all these attributes to verify that they are \nachieved in the final system.  \n16. Organizing Specific Requi rements:  It determines the requirements so that they can be \nproperly organized for optimal understanding. The requirements can be organized on the basis of \nmode of operation, user classes, objects, feature, response, and functional hierarchy.  \n17. Change manage ment process:  It determines the change management process in order to \nidentify, evaluate, and update SRS to reflect changes in the project scope and requirements.  \n18. Document approvals:  These provide information about the approvers of the SRS document \nwith th e details such as approver's name, signature, date, and so on.  \n19. Supporting information:  It provides information such as table of contents, index, and so \non. This is necessary especially when SRS is prepared for large and complex projects.  \n \n \n  \n13 What is r equirement engineering? State its process and explain requirement elicitation \nproblem. (April/May 2008)  \nRequirement Engineering  \nThe process to gather the software requirements from client, analyze and document them is known \n75  \n as requirement engineering.  \nThe goal of requirement engineering is to develop and maintain sophisticated and descriptive \n\u2018System Requirements Specification\u2019 document.  \nRequirement Engineering Process  \nIt is a four step process, which includes \u2013 \n\uf0b7 Feasibility Study  \n\uf0b7 Requirement Gathering  \n\uf0b7 Softw are Requirement Specification  \n\uf0b7 Software Requirement Validation  \nLet us see the process briefly - \nFeasibility study  \nWhen the client approaches the organization for getting the desired product developed, it comes up \nwith rough idea about what all functions the  software must perform and which all features are \nexpected from the software.  \nReferencing to this information, the analysts does a detailed study about whether the desired \nsystem and its functionality are feasible to develop.  \nThis feasibility study is focu sed towards goal of the organization.", "mimetype": "text/plain", "start_char_idx": 123582, "end_char_idx": 128510, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76": {"__data__": {"id_": "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f4504b97-2ace-4b7f-8028-5f7955354fa6", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "aa62d66d333e186728e52f3c6b56798a63490f2a56d2c102a023da445ea499f4", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "80528e67-82c1-4c11-bb96-2379ea8e806c", "node_type": "1", "metadata": {}, "hash": "e31a45569cd6f6e14d243a33d4fa0334072c45fd01a960224623bfbe19796663", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "(April/May 2008)  \nRequirement Engineering  \nThe process to gather the software requirements from client, analyze and document them is known \n75  \n as requirement engineering.  \nThe goal of requirement engineering is to develop and maintain sophisticated and descriptive \n\u2018System Requirements Specification\u2019 document.  \nRequirement Engineering Process  \nIt is a four step process, which includes \u2013 \n\uf0b7 Feasibility Study  \n\uf0b7 Requirement Gathering  \n\uf0b7 Softw are Requirement Specification  \n\uf0b7 Software Requirement Validation  \nLet us see the process briefly - \nFeasibility study  \nWhen the client approaches the organization for getting the desired product developed, it comes up \nwith rough idea about what all functions the  software must perform and which all features are \nexpected from the software.  \nReferencing to this information, the analysts does a detailed study about whether the desired \nsystem and its functionality are feasible to develop.  \nThis feasibility study is focu sed towards goal of the organization. This study analyzes whether the \nsoftware product can be practically materialized in terms of implementation, contribution of project \nto organization, cost constraints and as per values and objectives of the organizatio n. It explores \ntechnical aspects of the project and product such as usability, maintainability, productivity and \nintegration ability.  \nThe output of this phase should be a feasibility study report that should contain adequate comments \nand recommendations fo r management about whether or not the project should be undertaken.  \nRequirement Gathering  \nIf the feasibility report is positive towards undertaking the project, next phase starts with gathering \nrequirements from the user. Analysts and engineers communicate  with the client and end -users to \nknow their ideas on what the software should provide and which features they want the software to \ninclude.  \nSoftware Requirement Specification  \nSRS is a document created by system analyst after the requirements are collected  from various \nstakeholders.  \nSRS defines how the intended software will interact with hardware, external interfaces, speed of \noperation, response time of system, portability of software across various platforms, \nmaintainability, speed of recovery after cras hing, Security, Quality, Limitations etc.  \nThe requirements received from client are written in natural language. It is the responsibility of \nsystem analyst to document the requirements in technical language so that they can be \ncomprehended and useful by th e software development team.  \nSRS should come up with following features:  \n76  \n \uf0b7 User Requirements are expressed in natural language.  \n\uf0b7 Technical requirements are expressed in structured language, which is used inside the \norganization.  \n\uf0b7 Design description should be w ritten in Pseudo code.  \n\uf0b7 Format of Forms and GUI screen prints.  \n\uf0b7 Conditional and mathematical notations for DFDs etc.  \nSoftware Requirement Validation  \nAfter requirement specifications are developed, the requirements mentioned in this document are \nvalidated. Us er might ask for illegal, impractical solution or experts may interpret the requirements \nincorrectly. This results in huge increase in cost if not nipped in the bud. Requirements can be \nchecked against following conditions - \n\uf0b7 If they can be practically impl emented  \n\uf0b7 If they are valid and as per functionality and domain of software  \n\uf0b7 If there are any ambiguities  \n\uf0b7 If they are complete  \n\uf0b7 If they can be demonstrated  \nRequirement Elicitation Process  \nRequirement elicitation process can be depicted using the folloiwng diag ram: \n \n\uf0b7 Requirements gathering - The developers discuss with the client and end users and know \ntheir expectations from the  software.  \n\uf0b7 Organizing Requirements - The developers prioritize and arrange the requirements in \norder of importance, urgency and convenience.  \n\uf0b7 Negotiation & discussion - If requirements are ambiguous or there are some conflicts in \nrequirements of various sta keholders, if they are, it is then negotiated and discussed with \nstakeholders. Requirements may then be prioritized and reasonably compromised.  \nThe requirements come from various stakeholders. To remove the ambiguity and conflicts, \nthey are discussed for c larity and correctness. Unrealistic requirements are compromised \nreasonably.  \n\uf0b7 Documentation - All formal & informal, functional and non -functional requirements are \ndocumented and made available for next phase processing.  \nRequirement Elicitation Techniques  \nRequirements Elicitation is the process to find out the requirements for an intended software \nsystem by communicating with client, end users, system users and others who have a stake in the \nsoftware system development.  \nThere are various ways to discover req uirements  \n77  \n Interviews  \nInterviews are strong medium to collect requirements. Organization may conduct several types of \ninterviews such as:  \n\uf0b7 Structured (closed) interviews, where every single information to gather is decided in \nadvance, they follow pattern and  matter of discussion firmly.  \n\uf0b7 Non-structured (open) interviews, where information to gather is not decided in advance, \nmore flexible and less biased.", "mimetype": "text/plain", "start_char_idx": 127488, "end_char_idx": 132739, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "80528e67-82c1-4c11-bb96-2379ea8e806c": {"__data__": {"id_": "80528e67-82c1-4c11-bb96-2379ea8e806c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "055a7a3243dcf551e9e93e6ddc86ded3bcb58acad7f4c9a6d399704fa0277e66", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d47afd40-e451-438f-b54e-5a7e3b201736", "node_type": "1", "metadata": {}, "hash": "d4ae2717f79de734e3d4da8f653874827fbeda95226520f1ce6c1f52e4b5e38d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Unrealistic requirements are compromised \nreasonably.  \n\uf0b7 Documentation - All formal & informal, functional and non -functional requirements are \ndocumented and made available for next phase processing.  \nRequirement Elicitation Techniques  \nRequirements Elicitation is the process to find out the requirements for an intended software \nsystem by communicating with client, end users, system users and others who have a stake in the \nsoftware system development.  \nThere are various ways to discover req uirements  \n77  \n Interviews  \nInterviews are strong medium to collect requirements. Organization may conduct several types of \ninterviews such as:  \n\uf0b7 Structured (closed) interviews, where every single information to gather is decided in \nadvance, they follow pattern and  matter of discussion firmly.  \n\uf0b7 Non-structured (open) interviews, where information to gather is not decided in advance, \nmore flexible and less biased.  \n\uf0b7 Oral interviews  \n\uf0b7 Written interviews  \n\uf0b7 One-to-one interviews which are held between two persons across the tab le. \n\uf0b7 Group interviews which are held between groups of participants. They help to uncover any \nmissing requirement as numerous people are involved.  \n \n14 what is prototyping .explain its types types.(Nov/Dec 2009)  \nA prototype is a model version of a product. It\u2019s used as an early, inexpensive sample of a product \nthat helps to test its features or identify defects so improvements can be made to its final version.  \nPrototypes provides the opportunity to gather valuable feedback from stakeholders, partners or \ncustomers about the product. This information can be used to build a product that meets their \nrequirements.  \nFollowing are a few advantages of prototyping  \n\uf0b7 Collect feedback from users/ stakeholders about the functionality of the product before the \npublic release    \n\uf0b7 Reveal areas for improvement and help identify faults and usability issues before the public \nrelease. Help reduce unnecessary costs.   \n\uf0b7 Improve team efficiency and collaboration  \n\uf0b7 Allow the user to interact with a working model of their product  \n\uf0b7 Help conver t an abstract idea into a tangible product in a cost -effective way  \n\uf0b7 Identify if your product idea is a weak one and cost you heavily before actually moving \nforward with it  \nPrototyping Types  \nPrototyping methods and prototyping techniques can be categorized a s low -fidelity prototypes and \nhigh-fidelity prototypes.  \nBased on the resources available to you and the purpose for prototyping, the prototyping method \nyou choose can be either be low -fidelity or high -fidelity.  \nLow-Fidelity Prototypes  \nLow-fidelity prototyp es represent a simple and incomplete version of the final product. In a low -\nfidelity prototype, not all visual features and content elements are conveyed.  \n78  \n While it doesn\u2019t take much time or effort to translate a broad concept to a low -fidelity prototype, i t \ncan be used to gather user feedback during the early stage.  \nLow-fidelity prototyping methods  \nWireframes  \nWireframes are used to represent the basic structure of a website/ web page/ app. It serves as a \nblueprint, highlighting the layout of key elements on  a page and its functionality.   \nWith Creately, you can  create clickable wireframes  by adding links to the wireframe elements, that \nwill allow your users to navigate from one interface to the ot her \n \n \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n79  \n UNIT \u2013 3PART \u2013A \n \n \n \n \n \n \nS.NO  QUESTIONS  \n1 What are the primary interaction styles and state their advantages?  NOV/DEC -10 \n1. Direct manipulation - Easiest to grasp with immediate feedback , Difficult to  \nprogram  \n2. Menu selection  - User effort and errors minimized, large numbers and \ncombinations of choices a  problem  \n3. Form fill -in - Ease of use, simple data entry, Tedious, takes a lot of screen  space  \n4. Command language - Easy to program and process, Difficult to master for \ncasual  users \n5. Natural  language  - Great  for casual  users,  Tedious  for \nexpert users.  \n2 List the architectural  models  that can be developed. NOV/DEC -10 \nData -centered architectures, Data flow architectures, Call and return \narchitectures  \nObject -oriented architectures, Lay ered architectures.  \n3 What is meant by real time system design? APR/MAY -11 \n \n \nA real -time system is a software system where the correct functioning of the system  \ndepends on the results produced by the system and the time at which these \nresults  are \nproduced . \n4 List four design principles of a good design?", "mimetype": "text/plain", "start_char_idx": 131808, "end_char_idx": 136369, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d47afd40-e451-438f-b54e-5a7e3b201736": {"__data__": {"id_": "d47afd40-e451-438f-b54e-5a7e3b201736", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "80528e67-82c1-4c11-bb96-2379ea8e806c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "0388b7a7b7f53777ed16aad8d1cb230d55c14d66d775cf28b2958ad3c9be0ef6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427", "node_type": "1", "metadata": {}, "hash": "5eba136ef06752b4bcf3a37de9e679710822967714a7f4ed6c12143715fb5e0b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Form fill -in - Ease of use, simple data entry, Tedious, takes a lot of screen  space  \n4. Command language - Easy to program and process, Difficult to master for \ncasual  users \n5. Natural  language  - Great  for casual  users,  Tedious  for \nexpert users.  \n2 List the architectural  models  that can be developed. NOV/DEC -10 \nData -centered architectures, Data flow architectures, Call and return \narchitectures  \nObject -oriented architectures, Lay ered architectures.  \n3 What is meant by real time system design? APR/MAY -11 \n \n \nA real -time system is a software system where the correct functioning of the system  \ndepends on the results produced by the system and the time at which these \nresults  are \nproduced . \n4 List four design principles of a good design? APR/MAY - \n11APRIL/MAY 2018  \n80  \n  o Process should not suffer from tunnel  vision.  \no It should be traceable to the analysis  model  \no It should not reinvent the  wheel  \no It should exhibit uniformity &  integration.  \n5 List out design methods. APR/MAY -12 \nArchitectural design , data design , modular design.  \n6 Define data acquisition APR/MAY -12,MAY/JUN -13 \nCollect data from sensors for subsequent processing and analysis.  \n7 How do you apply modularization criteria for a monolit hic software NOV/DEC -12 \nModularity is achieved to various extents by different modularization approaches. Code \nbased modularity allows developers to reuse and repair parts of the application, but \ndevelopment tools are required to perform these maintenance functions .Object based \nmodularity provides the application as a collection of separate executable files which \nmay be independently maintained and replaced without redeploying  the \nentire application.  \n8 What is the design quality attributes \u2018FURPS\u2019 meant?  \nNOV/DEC -12, NOV/DEC2015, NOV/DEC2017  \nFURPS is an acronym representing a model for classifying software   quality   \nattributes    ( functional and non- functional  requirements ) \nFunctionality, Usability, Reliability, Performance and Supportab ility model.  \n81  \n 9 Define data abstraction? MAY/JUN -13 \nData abstraction is a named collection of data that describes the data  object.  \nEg:- Door attribute \u2013 door type, swing direction, weight  \n10 What are the elements of design model?  \ni. Data design  \nii. Architectural  design  \niii. Interface design  \niv. Component -level  design  \n11 What is the benefit of modular design?  \nChanges made during testing and maintenance becomes manageable and they do not \naffect other modules.  \n12 Name the commonly used architectural styles.  \ni. Data centere d architecture. ii. Data flow architecture.  \niii. Call   and return   architecture.  iv. Object -oriented architecture. v. Layered  \narchitecture.  \n13 What is a cohesive module?  \nA cohesive module performs only \u201cone task\u201d in software  \nprocedure with little intera ction with other modules. In other words cohesive module \nperforms only one thing.  \n82  \n 14 What are the different types of Cohesion?  \ni. Coincidentally cohesive \u2013The modules in which the set I \\of tasks are related with \neach other loosely then such modules are calle d coincidentally  cohesive.  \nii. Logically cohesive \u2013 A module that performs the tasks that are logically related \nwith each other is called logically cohesive.  \ni i i. Temporal cohesion \u2013 The module in which the tasks need to be executed in some \nspecific time span is called temporal cohesive.  \ni v. Procedural cohesion \u2013 When processing elements of a module are related with \nprocedural  cohesive.  \nv. Communicational cohesion \u2013 When the processing elements of a module share \nthe data then such module is called  \ncommunicational cohesive.  \n15 What is Coupling?What are the various types of coupling APRIL/MAY -15, \nCoupling is the measure of interconnection among modules in a program structure. It \ndepends on the interface complexity between modules.  \ni. Data coupling \u2013 The data coupling is possibl e by parameter passing or data  \ninteraction.  \nii . Control coupling \u2013 The modules share related control data in control  coupling.  \niii . Common coupling \u2013 The common data or a global data is shared among modules. \niv. Content coupling \u2013 Content coupling occurs when one m odule makes use of data or \ncontrol  information  \nmaintained in another module.  \n83  \n 16 What are the common activities in design process?", "mimetype": "text/plain", "start_char_idx": 135597, "end_char_idx": 139967, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427": {"__data__": {"id_": "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d47afd40-e451-438f-b54e-5a7e3b201736", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e0687df0c0ab5d4ae253bd890086873f2939b9c3cace9a078c8af625147453f0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e2c603ea-be17-435f-85f0-669563edc427", "node_type": "1", "metadata": {}, "hash": "a8d5ce08d72e97f7fc9d05d1bea646e70e81e4cb747888a7312ac6dcd10a3159", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "v. Communicational cohesion \u2013 When the processing elements of a module share \nthe data then such module is called  \ncommunicational cohesive.  \n15 What is Coupling?What are the various types of coupling APRIL/MAY -15, \nCoupling is the measure of interconnection among modules in a program structure. It \ndepends on the interface complexity between modules.  \ni. Data coupling \u2013 The data coupling is possibl e by parameter passing or data  \ninteraction.  \nii . Control coupling \u2013 The modules share related control data in control  coupling.  \niii . Common coupling \u2013 The common data or a global data is shared among modules. \niv. Content coupling \u2013 Content coupling occurs when one m odule makes use of data or \ncontrol  information  \nmaintained in another module.  \n83  \n 16 What are the common activities in design process?  \ni. System structuring \u2013 The system is subdivided into principle subsystems \ncomponents and communications between these subsystem s are identified.  \nii. Control modeling \u2013 A model of control relationships between different parts of \nthe system is established.  \niii. Modular decomposition \u2013 The identified subsystems  are \ndecomposed into modules  \n17 What are the benefits of horizontal partitioning?  \ni. Software that is easy to test. \nii. Software that is easier to  maintain.  \niii. Propagation of fewer sideeffects. iv. Software that is easier to  extend.  \n18 What is vertical partitioning? What are the advantages?  \nVertical partitioning often called factoring suggests t hat the control and work should \nbe distributed top -down in program structure.  \ni. These are easy to maintain changes.  \n ii. They reduce the change impact and error propagation  \n19 If a module has logical cohesion, what kind of coupling is this module likely  to have?  \nAPR/MAY 2016  \n \nIf a module has logical cohesion, then content coupling can be done. In content \ncoupling one module can make use of data or  \ncontrol information maintained in another  \n84  \n 20 Write the best practices for \"coding\u201d? APR/MAY 2015,  NOV/DEC20 15 \n \nBest coding practices are a set of informal rules that the software  development  community \nhas learned over time which can help improve the quality of software. \"The first 90% of the \ncode accounts for the first 90% of the development time. The remaining 10% of the code \naccounts for the other 90% of the development time.\" The size of a project or program has a \nsignificant e ffect on error rates, programmer productivity, and the amount of  \nmanagement needed.  \n21 What architectural styles are preferred for the following system? Why? \nNOV/DEC2016  \n(a) Networking \u2013 Data centered  Architecture  \n(b) Web based systems \u2013 Call and return  architect ure \n(c) Banking system - Data centered  Architecture.  \n22 What is DFD?  \nData Flow Diagram depicts the information flow and the  \ntransforms that are applied on the data as it moves from input to output.  \n23 Name the commonly used architectural styles . \ni. Data cent ered architecture. ii. Data flow architecture.  \niii. Call and return architecture. iv. Object -oriented architecture. v. Layered architecture.  \n24 What is ERD?  \nEntity Relationship Diagram is the graphical representation  \nof the object relationship pair. It is  mainly used in database applications.  \n85  \n 25 What UI design patters are used for the following? NOV/DEC  2016, APRIL/MAY \n2017, APRIL/MAY 2018  \n(a) Page layout \u2013 interface  design  \n(b) Tables - Design  \n(c) Navigation through menus and web pages \u2013 design  \n(d) Shopping cart \u2013 interf ace design, task  analysis  \n26 What are the various elements of data design?  \ni. Data object \u2013 The data objects are identified and relationship among various data \nobjects can be represented using ERD or data  dictionaries.  \nii. Databases \u2013 Using software design model , the data models are translated into data \nstructures and data bases at the application  level.  \ni i i. Data warehouses \u2013 At the business level  useful  \ninformation is identified from various databases and the data warehouses are created.  \n27 List the guidelines for data design.  \ni. Apply systematic analysis on  data.  \nii. Identify data structures and related  operations.  \niii. Establish data  dictionary.  \niv. Use information hiding in the design of data structure.  \nv. Apply a library of useful data structures and  operations.  \n28 What is a Real  time system?", "mimetype": "text/plain", "start_char_idx": 139143, "end_char_idx": 143524, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e2c603ea-be17-435f-85f0-669563edc427": {"__data__": {"id_": "e2c603ea-be17-435f-85f0-669563edc427", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1484188a36d1b749d2241b485fa1942ad48ecd726715817b9df3808d9e5b511e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "912bf6d7-38ff-4919-9a08-dc5a12963b40", "node_type": "1", "metadata": {}, "hash": "5338172b48a8f0e4688a58b864f40bc29dbc238b5e26f8a5bbc0beb01a5dbd95", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "i. Data object \u2013 The data objects are identified and relationship among various data \nobjects can be represented using ERD or data  dictionaries.  \nii. Databases \u2013 Using software design model , the data models are translated into data \nstructures and data bases at the application  level.  \ni i i. Data warehouses \u2013 At the business level  useful  \ninformation is identified from various databases and the data warehouses are created.  \n27 List the guidelines for data design.  \ni. Apply systematic analysis on  data.  \nii. Identify data structures and related  operations.  \niii. Establish data  dictionary.  \niv. Use information hiding in the design of data structure.  \nv. Apply a library of useful data structures and  operations.  \n28 What is a Real  time system?  \nReal time system is a software system in which the correct functionalities of the \nsystem are dependent upon results produced by the system and the time at which these \nresults are produced  \n29 How do you describe software interface? April /May  2015  \n86  \n  Software interface - the languages and codes that the applications use to communicate with \neach other and also with the hardware.  \nThree types of interface may have to be defined  \n\u2022 Procedural  interfaces;  \n\u2022 Data structures that are  exchanged;  \n\u2022 Data repres entations.  \nThe interface describes the behavior of a software component that is obtained by \nconsidering only the interactions of that interface and by hiding all other interactions.  \n30 Explain the qualitative criteria for measuring independence? NOV/DEC -11 \n1. Cohesion: Cohesion is a qualitative indication of the degree to which a module focuses on \njust one thing.  \n2. Coupling: Coupling is the measure of interconnection  among  \nmodules in a program structure. It depends on the interface complexity between modules  \n31 What is the purpose of a petrinet ? APRIL/MAY 2017  \nA Petri net, also known as a place/transition (PT) net, is one of several \nmathematical modeling languages  for the description of distributed systems. It is a class of \ndiscrete event dynamic system.  Petri nets offer a graphical notation  for stepwise processes \nthat \ninclude choice, iteration, and concurrent execution  \n32 What is vertical partitioning?  \nVertical partitioning often called factoring suggests that the control and work should be \ndistributed top -down in program structure.  \n87  \n 33 What are the benefits of horizontal partitionin g? \ni. Software that is easy to test. ii. Software that is easier to maintain. iii. Propagation of \nfewer side effects. iv. Software that is easier to extend.  \n34 What are data acquisition systems?  \n Systems that collect data from sensors for subsequent proc essing and analysis are termed as \ndata acquisition systems. Data collection processes and processing processes may have \ndifferent  \nperiods and deadlines.  \n35 What is interface design?  \nThe interface design describes how the software communicates  \nwithin itsel f, with systems that interoperate with it, and with humans who use it.  \n36 What are the elements of design model?  \nData design  \nii. Architectural  design  \niii. Interface design  \niv. Component -level  design  \n37 What is coupling?  \nCoupling is the measure of interconnection amon g modules in a program structure. It \ndepends on the interface complexity between modules.  \n38 Define design process . \nDesign process is a sequence of steps carried through which the requirements are translated \ninto a system or software model.  \n88  \n 39 What is Tr ansform mapping?  \nThe transform mapping is a set of design steps applied on the DFD  \nin order to map the transformed flow characteristics into specific architectural style.  \n40 What is component level design?  \nThe component level design transforms structural elements of the  \nsoftware architecture into a procedural description of software components.  \n41 What are the objectives of Analysis modeling?  \ni. To describe what the customer requires. ii. To establish a basis  \n for the creation of software design. iii. To  devise a set of valid  \nrequirements after which the software can be built.  \n42 What are the various types of coupling?  \niData coupling \u2013 The data coupling is possible by \nparameter passing or data interaction.  \nii. Control coupling  \u2013 \nThe modules share related con trol data in control coupling.  \niii. Common coupling  \u2013 \nThe common data or a global data is shared among modules.  \niv. Content coupling \u2013 Content coupling occurs \nwhen one module makes use of data or control information maintained in another  module.  \n43 What does modal ity in data modeling indicates?  \nModality indicates whether or not a particular data object must participate in the \nrelationship.", "mimetype": "text/plain", "start_char_idx": 142757, "end_char_idx": 147479, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "912bf6d7-38ff-4919-9a08-dc5a12963b40": {"__data__": {"id_": "912bf6d7-38ff-4919-9a08-dc5a12963b40", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e2c603ea-be17-435f-85f0-669563edc427", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fbea3915c54bc62fb213e58b0d2a5ea21a7190271b1d714c2aef7498a16dd101", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e4c44a77-716c-48e0-bf88-d2945929a9a6", "node_type": "1", "metadata": {}, "hash": "a29ea089461af109210a8945a5dac83dc1cdf696da63c4e4f2d1a94467d39bea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "41 What are the objectives of Analysis modeling?  \ni. To describe what the customer requires. ii. To establish a basis  \n for the creation of software design. iii. To  devise a set of valid  \nrequirements after which the software can be built.  \n42 What are the various types of coupling?  \niData coupling \u2013 The data coupling is possible by \nparameter passing or data interaction.  \nii. Control coupling  \u2013 \nThe modules share related con trol data in control coupling.  \niii. Common coupling  \u2013 \nThe common data or a global data is shared among modules.  \niv. Content coupling \u2013 Content coupling occurs \nwhen one module makes use of data or control information maintained in another  module.  \n43 What does modal ity in data modeling indicates?  \nModality indicates whether or not a particular data object must participate in the \nrelationship.  \n89  \n 44 What does Level0 DFD represent?  \nLevel 0 DFD is called as \u201efundamental system model\u201f or \u201econtext model\u201f. In the context \nmode l the entire software system is represented by a single bubble with input and output \nindicated by  \nincoming and outgoing arrows.  \n45 What are the elements of design model?  \ni. Data design ii. Architectural design iii. Interface design iv. Component -level des ign \n46 What is data modeling?  \nData modeling is the basic step in the analysis modeling. In data modeling the data objects \nare examined independently of processing. The data model represents how data are related \nwith  \none another.  \n47 What is a data object?  \nData object is a collection of attributes that act as an aspect,  \n characteristic,quality, or descriptor of the object  \n48 What are attributes?  \nAttributes are the one, which defines the properties of data object.  \n49 What is cardinality in data modeling?  \nCardinality in data modeling, cardinality specifies how the number of occurrences of one \nobject is related to the number of \noccurrences of another object.  \n50 What is ERD?  \nEntity Relationship Diagram is the graphical representation of the object relationsh ip pair. \nIt is mainly used in database applications  \n  \n \n \n \n90  \n PART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 Explain the core activities involved in User Interface design process with necessary \nblock diagrams MAY/JUNE 2016 ,NOV/DEC2015,  NOV/DEC 2017  \nUser interface is the front -end application view to which user interacts in order to use the software. \nUser can manipulate and control the software as well as hardware by means of user interface. \nToday, user interface is found at almost every place where digital technology exists, r ight from \ncomputers, mobile phones, cars, music players, airplanes, ships etc.  \nUser interface is part of software and is designed such a way that it is expected to provide the user \ninsight of the software. UI provides fundamental platform for human -compute r interaction.  \nUI can be graphical, text -based, audio -video based, depending upon the underlying hardware and \nsoftware combination. UI can be hardware or software or a combination of both.  \nThe software becomes more popular if its user interface is:  \n\uf0b7 Attract ive \n\uf0b7 Simple to use  \n\uf0b7 Responsive in short time  \n\uf0b7 Clear to understand  \n\uf0b7 Consistent on all interfacing screens  \nUI is broadly divided into two categories:  \n\uf0b7 Command Line Interface  \n\uf0b7 Graphical User Interface  \nCommand Line Interface (CLI)  \nCLI has been a great tool of intera ction with computers until the video display monitors came into \nexistence. CLI is first choice of many technical users and programmers. CLI is minimum interface \na software can provide to its users.  \nCLI provides a command prompt, the place where the user ty pes the command and feeds to the \nsystem. The user needs to remember the syntax of command and its use. Earlier CLI were not \nprogrammed to handle the user errors effectively.  \nA command is a text -based reference to set of instructions, which are expected to be executed by \nthe system. There are methods like macros, scripts that make it easy for the user to operate.  \nCLI uses less amount of computer resource as compared to GUI.  \nCLI Elements  \n91  \n \n \nA text -based command line interface can have the following elements:  \n\uf0b7 Command Prompt  - It is text -based notifier that is mostly shows the context in which the \nuser is working. It is generated by the software system.  \n\uf0b7 Curs or - It is a small horizontal line or a vertical bar of the height of line, to represent \nposition of character while typing. Cursor is mostly found in blinking state. It moves as the \nuser writes or deletes something.", "mimetype": "text/plain", "start_char_idx": 146635, "end_char_idx": 151199, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e4c44a77-716c-48e0-bf88-d2945929a9a6": {"__data__": {"id_": "e4c44a77-716c-48e0-bf88-d2945929a9a6", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "912bf6d7-38ff-4919-9a08-dc5a12963b40", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "b28f84dc407ed8de90f61b1efaac968cad231fb0edc000da53aa1f53e6f3fb31", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4baec4eb-bb89-4e9f-92eb-d560c1fe0255", "node_type": "1", "metadata": {}, "hash": "4e64e53caecf5b9dc61cc27bdb6ee22f174df5b47eb9e70b110feb06113316e6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The user needs to remember the syntax of command and its use. Earlier CLI were not \nprogrammed to handle the user errors effectively.  \nA command is a text -based reference to set of instructions, which are expected to be executed by \nthe system. There are methods like macros, scripts that make it easy for the user to operate.  \nCLI uses less amount of computer resource as compared to GUI.  \nCLI Elements  \n91  \n \n \nA text -based command line interface can have the following elements:  \n\uf0b7 Command Prompt  - It is text -based notifier that is mostly shows the context in which the \nuser is working. It is generated by the software system.  \n\uf0b7 Curs or - It is a small horizontal line or a vertical bar of the height of line, to represent \nposition of character while typing. Cursor is mostly found in blinking state. It moves as the \nuser writes or deletes something.  \n\uf0b7 Command  - A command is an executable in struction. It may have one or more parameters. \nOutput on command execution is shown inline on the screen. When output is produced, \ncommand prompt is displayed on the next line.  \nGraphical User Interface  \nGraphical User Interface provides the user graphical m eans to interact with the system. GUI can be \ncombination of both hardware and software. Using GUI, user interprets the software.  \nTypically, GUI is more resource consuming than that of CLI. With advancing technology, the \nprogrammers and designers create com plex GUI designs that work with more efficiency, accuracy \nand speed.  \nGUI Elements  \nGUI provides a set of components to interact with software or hardware.  \nEvery graphical component provides a way to work with the system. A GUI system has following \nelements such as:  \n92  \n \n \n\uf0b7 Window  - An area where contents of application are displayed. Contents in a window can \nbe displayed in the form of icons or lists, if the window represents file structure. It is easier \nfor a user to navigate in the file system in an exploring window. Windows can be \nminimized, resized or maximized to the size of screen. They can be moved anywhere on \nthe screen. A window may contain another wi ndow of the same application, called child \nwindow.  \n\uf0b7 Tabs  - If an application allows executing multiple instances of itself, they appear on the \nscreen as separate windows.  Tabbed Document Interface  has come up to open multiple \ndocuments in the same window. T his interface also helps in viewing preference panel in \napplication. All modern web -browsers use this feature.  \n\uf0b7 Menu  - Menu is an array of standard commands, grouped together and placed at a visible \nplace (usually top) inside the application window. The men u can be programmed to appear \nor hide on mouse clicks.  \n\uf0b7 Icon - An icon is small picture representing an associated application. When these icons \nare clicked or double clicked, the application window is opened. Icon displays application \nand programs installe d on a system in the form of small pictures.  \n\uf0b7 Cursor  - Interacting devices such as mouse, touch pad, digital pen are represented in GUI \nas cursors. On screen cursor follows the instructions from hardware in almost real -time. \nCursors are also named pointers in GUI systems. They are used to select menus, windows \nand other application features.  \nApplication specific GUI components  \nA GUI of an application contains one or more of the listed GUI elements:  \n\uf0b7 Application Window  - Most application windows uses the const ructs supplied by \noperating systems but many use their own customer created windows to contain the \ncontents of application.  \n\uf0b7 Dialogue Box  - It is a child window that contains message for the user and request for \nsome action to be taken. For Example: Applica tion generate a dialogue to get confirmation \n93  \n from user to delete a file.  \n\uf0b7 ext-Box - Provides an area for user to type and enter text -based data.  \n\uf0b7 Buttons  - They imitate real life buttons and are used to submit inputs to the software.  \n \n\uf0b7 Radio -button  - Displays available options for selection. Only one can be selected among \nall offered.  \n\uf0b7 Check -box - Functions similar to list -box. When an option is s elected, the box is marked \nas checked. Multiple options represented by check boxes can be selected.  \n\uf0b7 List-box - Provides list of available items for selection. More than one item can be \nselected.", "mimetype": "text/plain", "start_char_idx": 150330, "end_char_idx": 154675, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4baec4eb-bb89-4e9f-92eb-d560c1fe0255": {"__data__": {"id_": "4baec4eb-bb89-4e9f-92eb-d560c1fe0255", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e4c44a77-716c-48e0-bf88-d2945929a9a6", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e48ac81b2c7c0e441f857e5d70a85f71fdb2a06497534e69e12ab24be975a53d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d1e38ebb-1373-4b28-bd0e-5a468441430e", "node_type": "1", "metadata": {}, "hash": "347331480b074bbb387e3f7e71f1baf756ab35c564ac18ac742f0fa50273e283", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Dialogue Box  - It is a child window that contains message for the user and request for \nsome action to be taken. For Example: Applica tion generate a dialogue to get confirmation \n93  \n from user to delete a file.  \n\uf0b7 ext-Box - Provides an area for user to type and enter text -based data.  \n\uf0b7 Buttons  - They imitate real life buttons and are used to submit inputs to the software.  \n \n\uf0b7 Radio -button  - Displays available options for selection. Only one can be selected among \nall offered.  \n\uf0b7 Check -box - Functions similar to list -box. When an option is s elected, the box is marked \nas checked. Multiple options represented by check boxes can be selected.  \n\uf0b7 List-box - Provides list of available items for selection. More than one item can be \nselected.  \n \nOther impressive GUI components are:  \n\uf0b7 Sliders  \n\uf0b7 Combo -box \n\uf0b7 Data -grid \n\uf0b7 Drop -down list  \n\uf0b7  \n94  \n \n \n \n2 Explain the various modular decomposition and control styles commonly used in any \norganizational model. MAY/JUNE 2016  \nModular decomposition  \nAnother structural level where sub -systems are decomposed into modules. \u25cf Two modular \ndecomposition models covered \u2022 An object model where the system is decomposed into interacting \nobject; \u2022 A pipeline or data -flow model where the system is decomposed into functional modules \nwhich transform inputs to outputs. \u25cf If possible, decisions about concurrency sh ould be delayed \nuntil modules are implemented  \nModular decomposition styles  \nStyles of decomposing sub -systems into modules. \u25cf No rigid distinction between system \norganisation and modular decomposition.  \nSub-systems and modules  \nA sub -system is a system in its  own right whose operation is independent of the services provided \nby other sub -systems. \u25cf A module is a system component that provides services to other \ncomponents but would not normally be considered as a separate system  \nControl styles  \nAre concerned with  the control flow between sub -systems. Distinct from the system \ndecomposition model.  \n95  \n  \u25cf Centralised control \u2022 One sub -system has overall responsibility for control and starts and stops \nother sub -systems.  \n \u25cf Event -based control \u2022 Each sub -system can respond  to externally generated events from other \nsub-systems or the system\u2019s environment.  \nCentralised control  \nA control sub -system takes responsibility for managing the execution of other sub -systems.  \n \u25cf Call -return model  \n \u2022 Top -down subroutine model where contr ol starts at the top of a subroutine hierarchy and moves \ndownwards. Applicable to sequential systems.  \n \u25cf Manager model  \n \u2022 Applicable to concurrent systems.  \n\uf0b7 One system component controls the stopping, starting and coordination of other system \nprocesses. Ca n be implemented in sequential systems as a case statement.  \nEvent -driven systems  \nDriven by externally generated events where the timing of the event is outwith the control \nof the subsystems which process the event.  \n \u25cf Two principal event -driven models  \n \u2022 Broadcast models. An event is broadcast to all subsystems. Any sub -system which can \nhandle the event may do so;  \n \u2022 Interrupt -driven models. Used in real -time systems where interrupts are detected by an \ninterrupt handler and passed to some other component fo r processing  \n. \u25cf Other event driven models include spreadsheets and production systems.  \n3 Discuss the process of translating the analysis model in to a software design, List the golden \nrules of user interface design NOV/DEC2015  \nThe process of implementation of a softwa re may be define as a process of translation old software \nto new software with a new developed software who have extra functions and making it \noperational without any interruption in an organization functioning system. The time period which \nstarts from the  acceptance of the tested design to its satisfactory operated it covers all the time \nperiod. The software implementation is a very big operation and for the implementation of a \nsoftware better planning is must require. The planning of implementation of sof tware should be \nimplemented from a short point and after the success it implemented on whole area. For the \nimplementation of a new software a good knowledge is must require and some requirement of a \nsystem are hardware, file conversion actions and some per sonal needs of software.  \nActivities involved in software implementation  \nWhen old software and new software is modified and implemented then it contains three basic \nactions.  \n1. Personal training  - For the implementation of new software, the training of users a nd \noperators is necessary part. The training activity plays a major part in operating and \nmaintaining the software by user. Thus we can say that operators and user both require \n96  \n training.", "mimetype": "text/plain", "start_char_idx": 153910, "end_char_idx": 158696, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d1e38ebb-1373-4b28-bd0e-5a468441430e": {"__data__": {"id_": "d1e38ebb-1373-4b28-bd0e-5a468441430e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4baec4eb-bb89-4e9f-92eb-d560c1fe0255", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "834648ec46c47459407f994576c66219611465bccad7812a6253fc202258eb40", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "1da6a96c-8932-4b3d-a98a-1548d255fcc4", "node_type": "1", "metadata": {}, "hash": "73bd3e6a24d32a5067ec4b0639feb73a3c02c81258857361139fb5a5057890ea", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The software implementation is a very big operation and for the implementation of a \nsoftware better planning is must require. The planning of implementation of sof tware should be \nimplemented from a short point and after the success it implemented on whole area. For the \nimplementation of a new software a good knowledge is must require and some requirement of a \nsystem are hardware, file conversion actions and some per sonal needs of software.  \nActivities involved in software implementation  \nWhen old software and new software is modified and implemented then it contains three basic \nactions.  \n1. Personal training  - For the implementation of new software, the training of users a nd \noperators is necessary part. The training activity plays a major part in operating and \nmaintaining the software by user. Thus we can say that operators and user both require \n96  \n training.  \no Software operator training  - Most software run smoothly depends on th e \ncomputer user. The training of computer operator gives the satisfaction that he can \ndo every action and data entry. In the process of training a list of problem can be \nfigured out and solution can be provided to then so that they can solve their \nproblems  on their base and build the knowledge about this. If they get unusual \nproblem they can contact the concerned person. With the help of training they \nbecome friendly with software and solve can their problem easily.  \no User training  - User training helps the u ser in operating the system in efficient \nway. During the training a manual is given to every user so that they can \nunderstand the problem and solved it. The content of training is about the use of \ndata that how they can edit, add, query and delete the reco rds. If a user have not \nsufficient capability of working on system then many kind of errors and problems \ncan occur.  \n2. Conversion  - With the help of conversion process a old software can be replaced with new \nsoftware. The process of conversion is useful in on ly that case where new software is fully \ntested and report is positive. It involves many kinds of actions which are:  \no From old to new software system all files and data base converted.  \no Providing the user training of the each staff of the organization which has the right \nof using new software.  \no Conversion of forms. This may involve discarding old data.  \no Converting administration. In the process of converting administration process the \nrole of each member is divided according the needs and the responsibility is also \ndivided according to their job regarding new software.  \n3. Post implementation Review  - After the process of implementation and conversion of \nsoftware some reviews are taken by the user and the experts. This is the normal process of \ngetting the following points:  \no What is the working of a software system?  \no How it has been accepted by the user?  \no Area of updating  \nPerformance of a software measured with the help of a post implementation review. It \nhelps in deciding that software gets the specification with how mu ch efficiency.  \nTypes of implementation  \nWe have three types of implementation method which are given below:  \n1. Fresh implementation  - Fresh implementation of software may be defined as a process \nwhere a manual record are replaced with new software. During the process of fresh \nimplementation some problems come in the form of conversion of files, user training, \naccurate system of files etc.  \n2. Replacement implementation  - When an old software is replaced with a new software \nimplementation that the name of this proce ss is Replacement implementation. This process \nis very difficult and a proper planning is needed for this, otherwise many problems can \narise.  \n97  \n 3. Modified implementation  - When an old software is replaced by new software with some \nalteration then this process is called modified implementation. We can easily handle this \ntype of implementation because area of modification is not so large in files.  \n \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, described by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent com mands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback.", "mimetype": "text/plain", "start_char_idx": 157808, "end_char_idx": 162603, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "1da6a96c-8932-4b3d-a98a-1548d255fcc4": {"__data__": {"id_": "1da6a96c-8932-4b3d-a98a-1548d255fcc4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d1e38ebb-1373-4b28-bd0e-5a468441430e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ea2d6c1d79ce683617c29501ede00e1bf24a895b575bc21dc387872972b86082", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "36e52a11-8c7d-4c84-aa6f-a87b09c220c4", "node_type": "1", "metadata": {}, "hash": "c50412281b878e96e89888dad7064d8b4dc2e290cf08224aa7fe5e80ab147178", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "We can easily handle this \ntype of implementation because area of modification is not so large in files.  \n \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, described by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent com mands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback. For frequent and minor actions, the response must be modest, while for \ninfrequent and major actions, the response must be more substantial.  \n\uf0b7 Design dialog to yield closure  - Sequences of actions should be organized into groups \nwith a beginning, middle, and end. The informative feedback at the completion of a group \nof actions gives the operators the satisfaction of accomplishment, a sense of relief , the \nsignal to drop contingency plans and options from their minds, and this indicates that the \nway ahead is clear to prepare for the next group of actions.  \n\uf0b7 Offer simple error handling  - As much as possible, design the system so the user will not \nmake a s erious error. If an error is made, the system should be able to detect it and offer \nsimple, comprehensible mechanisms for handling the error.  \n\uf0b7 Permit easy reversal of actions  - This feature relieves anxiety, since the user knows that \nerrors can be undone. E asy reversal of actions encourages exploration of unfamiliar \noptions. The units of reversibility may be a single action, a data entry, or a complete group \nof actions.  \n\uf0b7 Support internal locus of control  - Experienced operators strongly desire the sense that \nthey are in charge of the system and that the system responds to their actions. Design the \nsystem to make users the initiators of actions rather than the responders.  \n\uf0b7 Reduce short -term memory load  - The limitation of human information processing in \nshort -term memory requires the displays to be kept simple, multiple page displays be \nconsolidated, window -motion frequency be reduced, and sufficient training time be \nallotted for codes, mnemonics, and sequences of actions.  \n \n4 Explain the basic concepts of softwa re design APR/MAY -11 , NOV/DEC 2017  \nSoftware design is a process to transform user requirements into some suitable form, \nwhich helps the programmer in software coding and implementation.  \nFor assessing user requirements, an SRS (Software Requirement Specifi cation) document \nis created whereas for coding and implementation, there is a need of more specific and \ndetailed requirements in software terms. The output of this process can directly be used \n98  \n into implementation in programming languages.  \nSoftware design i s the first step in SDLC (Software Design Life Cycle), which moves the \nconcentration from problem domain to solution domain. It tries to specify how to fulfill \nthe requirements mentioned in SRS.  \nSoftware Design Levels  \nSoftware design yields three levels of  results:  \n\uf0b7 Architectural Design - The architectural design is the highest abstract version of the \nsystem. It identifies the software as a system with many components interacting with each \nother. At this level, the designers get the idea of proposed solution  domain.  \n\uf0b7 High -level Design - The high -level design breaks the \u2018single entity -multiple component\u2019 \nconcept of architectural design into less -abstracted view of sub -systems and modules and \ndepicts their interaction with each other. High -level design focuses on  how the system along \nwith all of its components can be implemented in forms of modules. It recognizes modular \nstructure of each sub -system and their relation and interaction among each other.  \n\uf0b7 Detailed Design - Detailed design deals with the implementation part of what is seen as a \nsystem and its sub -systems in the previous two designs. It is more detailed towards modules \nand their implementations. It defines logical structure of each module and their interfaces to \ncommunicate with other modules.  \nModularizat ion \nModularization is a technique to divide a software system into multiple discrete and independent \nmodules, which are expected to be capable of carrying out task(s) independently. These modules \nmay work as basic constructs for the entire software. Design ers tend to design modules such that \nthey can be executed and/or compiled separately and independently.", "mimetype": "text/plain", "start_char_idx": 161730, "end_char_idx": 166550, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "36e52a11-8c7d-4c84-aa6f-a87b09c220c4": {"__data__": {"id_": "36e52a11-8c7d-4c84-aa6f-a87b09c220c4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "1da6a96c-8932-4b3d-a98a-1548d255fcc4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "aa176b66552dd242d974c2210589f45afab9762d5b7f3ea1f37e91c700789665", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3478af1b-c91f-4cbe-8293-10136e7c4e2e", "node_type": "1", "metadata": {}, "hash": "dc7c6eb49eeca7222d48a9af1d962535c6ff8f66367b76f969c00138477a7dcc", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "High -level design focuses on  how the system along \nwith all of its components can be implemented in forms of modules. It recognizes modular \nstructure of each sub -system and their relation and interaction among each other.  \n\uf0b7 Detailed Design - Detailed design deals with the implementation part of what is seen as a \nsystem and its sub -systems in the previous two designs. It is more detailed towards modules \nand their implementations. It defines logical structure of each module and their interfaces to \ncommunicate with other modules.  \nModularizat ion \nModularization is a technique to divide a software system into multiple discrete and independent \nmodules, which are expected to be capable of carrying out task(s) independently. These modules \nmay work as basic constructs for the entire software. Design ers tend to design modules such that \nthey can be executed and/or compiled separately and independently.  \nModular design unintentionally follows the rules of \u2018divide and conquer\u2019 problem -solving strategy \nthis is because there are many other benefits attached  with the modular design of a software.  \nAdvantage of modularization:  \n\uf0b7 Smaller components are easier to maintain  \n\uf0b7 Program can be divided based on functional aspects  \n\uf0b7 Desired level of abstraction can be brought in the program  \n\uf0b7 Components with high cohesion can b e re-used again  \n\uf0b7 Concurrent execution can be made possible  \n\uf0b7 Desired from security aspect  \nConcurrency  \nBack in time, all software are meant to be executed sequentially. By sequential execution we mean \nthat the coded instruction will be executed one after anoth er implying only one portion of program \nbeing activated at any given time. Say, a software has multiple modules, then only one of all the \nmodules can be found active at any time of execution.  \nIn software design, concurrency is implemented by splitting the software into multiple independent \nunits of execution, like modules and executing them in parallel. In other words, concurrency \nprovides capability to the software to execute more than one part of code in parallel to each other.  \n99  \n It is necessary for the pro grammers and designers to recognize those modules, which can be made \nparallel execution.  \nExample  \nThe spell check feature in word processor is a module of software, which runs along side the word \nprocessor itself.  \nDesign Verification  \nThe output of software design process is design documentation, pseudo codes, detailed logic \ndiagrams, process diagrams, and detailed description of all functional or non -functional \nrequirements.  \nThe next phase, which is the implementation of software, depends on all outputs ment ioned above.  \nIt is then becomes necessary to verify the output before proceeding to the next phase. The early \nany mistake is detected, the better it is or it might not be detected until testing of the product. If the \noutputs of design phase are in formal n otation form, then their associated tools for verification \nshould be used otherwise a thorough design review can be used for verification and validation.  \nBy structured verification approach, reviewers can detect defects that might be caused by \noverlooking some conditions. A good design review is important for good software design, \naccuracy and quality.  \n \n5 Explain clearly the concept of coupling & cohesion? For each type of coupling give an \nexample of two components coupled  in that way?  \nAPRIL/MAY 2015, APR IL/MAY 2017,  APRIL/MAY  2018  \nDescribe the concept of cohesion and coupling. State the difference b/w cohesion and \ncoupling with a suitable example.  \n(April/May Apr/May 2008)  \nCoupling and Cohesion  \nWhen a software program is modularized, its tasks are divided into several modules based on some \ncharacteristics. As we know, modules are set of instructions put together in order to achieve some \ntasks. They are though, considered as single entity but may refer to each other to work together. \nThere are measures by wh ich the quality of a design of modules and their interaction among them \ncan be measured. These measures are called coupling and cohesion.  \nCohesion  \nCohesion is a measure that defines the degree of intra -dependability within elements of a module. \nThe greater  the cohesion, the better is the program design.  \nThere are seven types of cohesion, namely \u2013 \n\uf0b7 Co-incidental cohesion - It is unplanned and random cohesion, which might be the result \nof breaking the program into smaller modules for the sake of modularization . Because it is \nunplanned, it may serve confusion to the programmers and is generally not -accepted.  \n\uf0b7 Logical cohesion - When logically categorized elements are put together into a module, it \nis called logical cohesion.", "mimetype": "text/plain", "start_char_idx": 165629, "end_char_idx": 170370, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3478af1b-c91f-4cbe-8293-10136e7c4e2e": {"__data__": {"id_": "3478af1b-c91f-4cbe-8293-10136e7c4e2e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "36e52a11-8c7d-4c84-aa6f-a87b09c220c4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62355cebffd58476903a0a1bcc3db9d56c93e79808bf2ae5ab37aa65eb71736f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "84302560-fc91-4f75-961e-51a723ec130b", "node_type": "1", "metadata": {}, "hash": "f85d09e0235bf27b73617b00ed4abd394aed191b2aa1fc5ae4cbb633fa96e60b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "They are though, considered as single entity but may refer to each other to work together. \nThere are measures by wh ich the quality of a design of modules and their interaction among them \ncan be measured. These measures are called coupling and cohesion.  \nCohesion  \nCohesion is a measure that defines the degree of intra -dependability within elements of a module. \nThe greater  the cohesion, the better is the program design.  \nThere are seven types of cohesion, namely \u2013 \n\uf0b7 Co-incidental cohesion - It is unplanned and random cohesion, which might be the result \nof breaking the program into smaller modules for the sake of modularization . Because it is \nunplanned, it may serve confusion to the programmers and is generally not -accepted.  \n\uf0b7 Logical cohesion - When logically categorized elements are put together into a module, it \nis called logical cohesion.  \n10\n0  \n \uf0b7 Temporal Cohesion - When elements of m odule are organized such that they are processed \nat a similar point in time, it is called temporal cohesion.  \n\uf0b7 Procedural cohesion - When elements of module are grouped together, which are executed \nsequentially in order to perform a task, it is called proced ural cohesion.  \n\uf0b7 Communicational cohesion - When elements of module are grouped together, which are \nexecuted sequentially and work on same data (information), it is called communicational \ncohesion.  \n\uf0b7 Sequential cohesion - When elements of module are grouped be cause the output of one \nelement serves as input to another and so on, it is called sequential cohesion.  \n\uf0b7 Functional cohesion - It is considered to be the highest degree of cohesion, and it is highly \nexpected. Elements of module in functional cohesion are gr ouped because they all \ncontribute to a single well -defined function. It can also be reused.  \nCoupling  \nCoupling is a measure that defines the level of inter -dependability among modules of a program. It \ntells at what level the modules interfere and interact w ith each other. The lower the coupling, the \nbetter the program.  \nThere are five levels of coupling, namely - \n\uf0b7 Content coupling - When a module can directly access or modify or refer to the content of \nanother module, it is called content level coupling.  \n\uf0b7 Commo n coupling - When multiple modules have read and write access to some global \ndata, it is called common or global coupling.  \n\uf0b7 Control coupling - Two modules are called control -coupled if one of them decides the \nfunction of the other module or changes its flow o f execution.  \n\uf0b7 Stamp coupling - When multiple modules share common data structure and work on \ndifferent part of it, it is called stamp coupling.  \n\uf0b7 Data coupling - Data coupling is when two modules interact with each other by means of \npassing data (as parameter).  If a module passes data structure as parameter, then the \nreceiving module should use all its components.  \nIdeally, no coupling is considered to be the best.  \n \n6 Write short notes on Architectural & component design. MAY/JUN -15,NOV/DEC2015  \nThe architecture of a system describes its major components, their relationships (structures), and \nhow they interact with each other. Software architecture and design includes several contributory \nfactors such as Business strategy, quality attributes, human dynamics, desig n, and IT environment.  \n10\n1  \n \n \nWe can segregate Software Architecture and Design into two distinct phases: Software \nArchite cture and Software Design. In  Architecture , nonfunctional decisions are cast and separated \nby the functional requirements. In Design, functional requirements are accomplished.  \nSoftware Architecture  \nArchitecture serves as a  blueprint for a system . It provid es an abstraction to manage the system \ncomplexity and establish a communication and coordination mechanism among components.  \n\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attrib utes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions about the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the over all success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elements and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavio ral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork t ogether to fulfill the requirement of the system.", "mimetype": "text/plain", "start_char_idx": 169502, "end_char_idx": 174322, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "84302560-fc91-4f75-961e-51a723ec130b": {"__data__": {"id_": "84302560-fc91-4f75-961e-51a723ec130b", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3478af1b-c91f-4cbe-8293-10136e7c4e2e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "39d30d6fd2270f8a081a8e5f80c6235af5ac43dc5ba7cc584f863d614aeac27f", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "39c3b979-b7a0-43c6-b06a-92172d3c1d6c", "node_type": "1", "metadata": {}, "hash": "2934a4e45092d0e41bbaadb6c31899182e15697056a6d0092778136433d6e2f0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attrib utes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions about the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the over all success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elements and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavio ral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork t ogether to fulfill the requirement of the system. The obje ctives of having a design plan are as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n10\n2  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including deta iled design, coding, integration, and testing.  \nIt comes before the detailed design, coding, integration, and testing and after the domain analysis, \nrequirements analysis, and risk analysis.  \nGoals of Architecture  \nThe primary goal of the architecture is to i dentify requirements that affect the structure of the \napplication. A well -laid architecture reduces the business risks associated with building a technical \nsolution and builds a bridge between business and technical requirements.  \nSome of the other goals ar e as follows \u2212  \n\uf0b7 Expose the structure of the system, but hide its implementation details.  \n\uf0b7 Realize all the use -cases and scenarios.  \n\uf0b7 Try to address the requirements of various stakeholders.  \n\uf0b7 Handle both functional and quality requirements.  \n\uf0b7 Reduce the goal of ow nership and improve the organization\u2019s market position.  \n\uf0b7 Improve quality and functionality offered by the system.  \n\uf0b7 Improve external confidence in either the organization or system.  \nLimitations  \nSoftware architecture is still an emerging discipline within soft ware engineering. It has the \nfollowing limitations \u2212  \n\uf0b7 Lack of tools and standardized ways to represent architecture.  \n\uf0b7 Lack of analysis methods to predict whether architecture will result in an implementation \nthat meets the requirements.  \n\uf0b7 Lack of awareness of the importance of architectural design to software development.  \n\uf0b7 Lack of understanding of the role of software architect and poor communication among \nstakeholders.  \n\uf0b7 Lack of understanding of the design process, design experience and evaluation of design.  \nRole of Software Architect  \nA Software Architect provides a solution that the technical team can create and design for the \nentire application. A software architect should have expertise in the fol lowing areas \u2212  \nDesign Expertise  \n\uf0b7 Expert in software design, including diverse methods and approaches such as object -\noriented design, event -driven design, etc.  \n\uf0b7 Lead the development team and coordinate the development efforts for the integrity of the \ndesign.  \n10\n3  \n \uf0b7 Should be able to review design proposals and tradeoff among themselves . \nComponent -based architecture  \nComponent -based architecture focuses on the decomposition of the design into individual \nfunctional or logical components that represent well -defined commu nication interfaces containing \nmethods, events, and properties. It provides a higher level of abstraction and divides the problem \ninto sub -problems, each associated with component partitions.  \nThe primary objective of component -based architecture is to ensu re component reusability . A \ncomponent encapsulates functionality and behaviors of a software element into a reusable and self -\ndeployable binary unit. There are many standard component frameworks such as COM/DCOM, \nJavaBean, EJB, CORBA, .NET, web services, a nd grid services. These technologies are widely \nused in local desktop GUI application design such as graphic JavaBean components, MS ActiveX \ncomponents, and COM components which can be reused by simply drag and drop operation.  \nComponent -oriented software d esign has many advantages over the traditional object -oriented \napproaches such as \u2212  \n\uf0b7 Reduced time in market and the development cost by reusing existing components.  \n\uf0b7 Increased reliability with the reuse of the existing components.  \nWhat is a Component?  \nA comp onent is a modular, portable, replaceable, and reusable set of well -defined functionality \nthat encapsulates its implementation and exporting it as a higher -level interface.  \nA component is a software object, intended to interact with other components, encap sulating \ncertain functionality or a set of functionalities. It has an obviously defined interface and conforms \nto a recommended behavior common to all components within an architecture.", "mimetype": "text/plain", "start_char_idx": 173330, "end_char_idx": 178470, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "39c3b979-b7a0-43c6-b06a-92172d3c1d6c": {"__data__": {"id_": "39c3b979-b7a0-43c6-b06a-92172d3c1d6c", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "84302560-fc91-4f75-961e-51a723ec130b", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "6cd7323574544b7ce12abec9e6eb961a1ba73855cdf0054ed5658ee8e43f3f15", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7bc0102f-be1d-4787-a7c5-5dde3d0527c7", "node_type": "1", "metadata": {}, "hash": "731e9fd4e8083b261f15b085e90849ad50b86261ccd7dfb214f75f7f4c87c033", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These technologies are widely \nused in local desktop GUI application design such as graphic JavaBean components, MS ActiveX \ncomponents, and COM components which can be reused by simply drag and drop operation.  \nComponent -oriented software d esign has many advantages over the traditional object -oriented \napproaches such as \u2212  \n\uf0b7 Reduced time in market and the development cost by reusing existing components.  \n\uf0b7 Increased reliability with the reuse of the existing components.  \nWhat is a Component?  \nA comp onent is a modular, portable, replaceable, and reusable set of well -defined functionality \nthat encapsulates its implementation and exporting it as a higher -level interface.  \nA component is a software object, intended to interact with other components, encap sulating \ncertain functionality or a set of functionalities. It has an obviously defined interface and conforms \nto a recommended behavior common to all components within an architecture.  \nA software component can be defined as a unit of composition with a co ntractually specified \ninterface and explicit context dependencies only. That is, a software component can be deployed \nindependently and is subject to composition by third parties.  \nViews of a Component  \nA component can have three different views \u2212 object -oriented view, conventional view, and \nprocess -related view.  \nObject -oriented view  \nA component is viewed as a set of one or more cooperating classes. Each problem domain class \n(analysis) and infrastructure class (design) are explained to identify all attributes  and operations \nthat apply to its implementation. It also involves defining the interfaces that enable classes to \ncommunicate and cooperate.  \nConventional view  \nIt is viewed as a functional element or a module of a program that integrates the processing logi c, \nthe internal data structures that are required to implement the processing logic and an interface that \nenables the component to be invoked and data to be passed to it.  \nProcess -related view  \nIn this view, instead of creating each component from scratch, t he system is building from existing \ncomponents maintained in a library. As the software architecture is formulated, components are \n10\n4  \n selected from the library and used to populate the architecture.  \n\uf0b7 A user interface (UI) component includes grids, buttons refe rred as controls, and utility \ncomponents expose a specific subset of functions used in other components.  \n\uf0b7 Other common types of components are those that are resource intensive, not frequently \naccessed, and must be activated using the just -in-time (JIT) app roach.  \n\uf0b7 Many components are invisible which are distributed in enterprise business applications \nand internet web applications such as Enterprise JavaBean (EJB), .NET components, and \nCORBA components.  \nCharacteristics of Components  \n\uf0b7 Reusability  \u2212 Components are usually designed to be reused in different situations in \ndifferent applications. However, some components may be designed for a specific task.  \n\uf0b7 Replaceable  \u2212 Components may be freely substituted with other similar components.  \n\uf0b7 Not context s pecific  \u2212 Components are designed to operate in different environments and \ncontexts.  \n\uf0b7 Extensible  \u2212 A component can be extended from existing components to provide new \nbehavior.  \n\uf0b7 Encapsulated  \u2212 A A component depicts the interfaces, which allow the caller to u se its \nfunctionality, and do not expose details of the internal processes or any internal variables \nor state.  \n\uf0b7 Independent  \u2212 Components are designed to have minimal dependencies on other \ncomponents.  \nPrinciples of Component\u2212Based Design  \nA component -level des ign can be represented by using some intermediary representation (e.g. \ngraphical, tabular, or text -based) that can be translated into source code. The design of data \nstructures, interfaces, and algorithms should conform to well -established guidelines to he lp us \navoid the introduction of errors.  \n\uf0b7 The software system is decomposed into reusable, cohesive, and encapsulated component \nunits.  \n\uf0b7 Each component has its own interface that specifies required ports and provided ports; each \ncomponent hides its detailed im plementation.  \n\uf0b7 A component should be extended without the need to make internal code or design \nmodifications to the existing parts of the component.  \n\uf0b7 Depend on abstractions component do not depend on other concrete components, which \nincrease difficulty in ex pendability.  \n\uf0b7 Connectors connected components, specifying and ruling the interaction among \ncomponents. The interaction type is specified by the interfaces of the components.  \n\uf0b7 Components interaction can take the form of method invocations, asynchronous \ninvoca tions, broadcasting, message driven interactions, data stream communications, and \nother protocol specific interactions.  \n\uf0b7 For a server class, specialized interfaces should be created to serve major categories of \n10\n5  \n clients.", "mimetype": "text/plain", "start_char_idx": 177506, "end_char_idx": 182489, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7bc0102f-be1d-4787-a7c5-5dde3d0527c7": {"__data__": {"id_": "7bc0102f-be1d-4787-a7c5-5dde3d0527c7", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "39c3b979-b7a0-43c6-b06a-92172d3c1d6c", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1bca58a9c685b44a834715982b1b2db307be52bb06590fa1559fb9c733f4cb96", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "94351431-31da-41da-9a05-fac85280d386", "node_type": "1", "metadata": {}, "hash": "a356e394c2fa007baec66b413f7897ade720af18300a17c0a6f399764717181d", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 The software system is decomposed into reusable, cohesive, and encapsulated component \nunits.  \n\uf0b7 Each component has its own interface that specifies required ports and provided ports; each \ncomponent hides its detailed im plementation.  \n\uf0b7 A component should be extended without the need to make internal code or design \nmodifications to the existing parts of the component.  \n\uf0b7 Depend on abstractions component do not depend on other concrete components, which \nincrease difficulty in ex pendability.  \n\uf0b7 Connectors connected components, specifying and ruling the interaction among \ncomponents. The interaction type is specified by the interfaces of the components.  \n\uf0b7 Components interaction can take the form of method invocations, asynchronous \ninvoca tions, broadcasting, message driven interactions, data stream communications, and \nother protocol specific interactions.  \n\uf0b7 For a server class, specialized interfaces should be created to serve major categories of \n10\n5  \n clients. Only those operations that are releva nt to a particular category of clients should be \nspecified in the interface.  \n\uf0b7 A component can extend to other components and still offer its own extension points. It is \nthe concept of plug -in based architecture. This allows a plugin to offer another plugin API. \n \n7 Bring out the necessity of Real -time system design process with appropriate \nexample? APR/MAY -12, MAY/JUNE -13, APRIL/MAY -15 \nSystems Design  \nIt is a process of planning a new business system or replacing an existing system by \ndefining its components o r modules to satisfy the specific requirements. Before planning, \nyou need to understand the old system thoroughly and determine how computers can best \nbe used in order to operate efficiently.  \nSystem Design focuses on  how to accomplish the objective of the system . \nSystem Analysis and Design (SAD) mainly focuses on \u2212  \n\uf0b7 Systems  \n\uf0b7 Processes  \n\uf0b7 Technology  \nWhat is a System?  \nThe word System is derived from Greek word Systema, which means an organized \nrelationship between any set of components to achieve some common cause  or objective.  \nA system is \u201can orderly grouping of interdependent components linked together according \nto a plan to achieve a specific goal.\u201d  \nConstraints of a System  \nA system must have three basic constraints \u2212  \n\uf0b7 A system must have some  structure and behavio r which is designed to achieve a \npredefined objective.  \n\uf0b7 Interconnectivity  and interdependence  must exist among the system components.  \n\uf0b7 The objectives of the organization  have a  higher priority  than the objectives of \nits subsystems.  \nFor example, traffic manag ement system, payroll system, automatic library system, human \nresources information system.  \nProperties of a System  \nA system has the following properties \u2212  \nOrganization  \n10\n6  \n Organization implies structure and order. It is the arrangement of components that helps to \nachieve predetermined objectives.  \nInteraction  \nIt is defined by the manner in which the components operate with each other.  \nFor example, in an organization, purchasing department must interact with production \ndepartment and payroll with personnel department.  \nInterdependence  \nInterdependence means how the components of a system depend on one another. For \nproper functi oning, the components are coordinated and linked together according to a \nspecified plan. The output of one subsystem is the required by other subsystem as input.  \nIntegration  \nIntegration is concerned with how a system components are connected together. It m eans \nthat the parts of the system work together within the system even if each part performs a \nunique function.  \nCentral Objective  \nThe objective of system must be central. It may be real or stated. It is not uncommon for \nan organization to state an objectiv e and operate to achieve another.  \nThe users must know the main objective of a computer application early in the analysis for \na successful design and conversion.  \nElements of a System  \nThe following diagram shows the elements of a system \u2212  \n \n10\n7  \n Outputs and Inputs  \n\uf0b7 The main aim of a system is to produce an output which is useful for its user.  \n\uf0b7 Inputs are the information that enters into the system for processing.  \n\uf0b7 Output is the outcome of processing.  \nProcessor(s)  \n\uf0b7 The processor is the element of a system that involves the actual transformation of \ninput into output.  \n\uf0b7 It is th e operational component of a system. Processors may modify the input either \ntotally or partially, depending on the output specification.  \n\uf0b7 As the output specifications change, so does the processing. In some cases, input is \nalso modified to enable the proces sor for handling the transformation.  \nControl  \n\uf0b7 The control element guides the system.  \n\uf0b7 It is the decision \u2013making subsystem that controls the pattern of activities governing \ninput, processing, and output.", "mimetype": "text/plain", "start_char_idx": 181498, "end_char_idx": 186408, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "94351431-31da-41da-9a05-fac85280d386": {"__data__": {"id_": "94351431-31da-41da-9a05-fac85280d386", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7bc0102f-be1d-4787-a7c5-5dde3d0527c7", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "9a6c603604feeb5574268409feb105a7e3b6bf73cf83a492060aa0d1aff2789b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e7c345aa-3114-4a76-94c1-6df680d972d7", "node_type": "1", "metadata": {}, "hash": "0a26b7751d05cdf2aff9a9d51527098f3cf0104ccff9af6b3aee7765f7e0d7f3", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Inputs are the information that enters into the system for processing.  \n\uf0b7 Output is the outcome of processing.  \nProcessor(s)  \n\uf0b7 The processor is the element of a system that involves the actual transformation of \ninput into output.  \n\uf0b7 It is th e operational component of a system. Processors may modify the input either \ntotally or partially, depending on the output specification.  \n\uf0b7 As the output specifications change, so does the processing. In some cases, input is \nalso modified to enable the proces sor for handling the transformation.  \nControl  \n\uf0b7 The control element guides the system.  \n\uf0b7 It is the decision \u2013making subsystem that controls the pattern of activities governing \ninput, processing, and output.  \n\uf0b7 The behavior of a computer System is controlled by the Operating System and \nsoftware. In order to keep system in balance, what and how much input is needed \nis determined by Output Specifications.  \nFeedback  \n\uf0b7 Feedback provides the control in a dynamic system.  \n\uf0b7 Positive feedback is routine in nature that encourages the performance of the \nsystem.  \n\uf0b7 Negative feedback is informational in nature that provides the controller with \ninformation for action.  \nEnvironment  \n\uf0b7 The environment is the \u201csupersystem\u201d within which an organization operates.  \n\uf0b7 It is the source of external eleme nts that strike on the system.  \n\uf0b7 It determines how a system must function. For example, vendors and competitors \nof organization\u2019s environment, may provide constraints that affect the actual \nperformance of the business.  \nBoundaries and Interface  \n\uf0b7 A system shoul d be defined by its boundaries. Boundaries are the limits that \nidentify its components, processes, and interrelationship when it interfaces with \nanother system.  \n10\n8  \n \uf0b7 Each system has boundaries that determine its sphere of influence and control.  \n\uf0b7 The knowledge of  the boundaries of a given system is crucial in determining the \nnature of its interface with other systems for successful design.  \nTypes of Systems  \nThe systems can be divided into the following types \u2212  \nPhysical or Abstract Systems  \n\uf0b7 Physical systems are tangible entities. We can touch and feel them.  \n\uf0b7 Physical System may be static or dynamic in nature. For example, desks and chairs \nare the physical parts of computer center which are static. A programmed computer \nis a dynamic system in which programs, data, and applications can change \naccording to the user's needs.  \n\uf0b7 Abstract systems are non -physical entities or conceptual that may be formulas, \nrepresentation  or model of a real system.  \nOpen or Closed Systems  \n\uf0b7 An open system must interact with its environment. It receives inputs from and \ndelivers outputs to the outside of the system. For example, an information system \nwhich must adapt to the changing environment al conditions.  \n\uf0b7 A closed system does not interact with its environment. It is isolated from \nenvironmental influences. A completely closed system is rare in reality.  \nAdaptive and Non Adaptive System  \n\uf0b7 Adaptive System responds to the change in the environment i n a way to improve \ntheir performance and to survive. For example, human beings, animals.  \n\uf0b7 Non Adaptive System is the system which does not respond to the environment. \nFor example, machines.  \nPermanent or Temporary System  \n\uf0b7 Permanent System persists for long ti me. For example, business policies.  \n\uf0b7 Temporary System is made for specified time and after that they are demolished. \nFor example, A DJ system is set up for a program and it is dissembled after the \nprogram.  \nNatural and Manufactured System  \n\uf0b7 Natural systems are  created by the nature. For example, Solar system, seasonal \nsystem.  \n\uf0b7 Manufactured System is the man -made system. For example, Rockets, dams, trains.  \nDeterministic or Probabilistic System  \n\uf0b7 Deterministic system operates in a predictable manner and the interact ion between \n10\n9  \n system components is known with certainty. For example, two molecules of \nhydrogen and one molecule of oxygen makes water.  \n\uf0b7 Probabilistic System shows uncertain behavior. The exact output is not known. For \nexample, Weather forecasting, mail deliv ery. \nSocial, Human -Machine, Machine System  \n\uf0b7 Social System is made up of people. For example, social clubs, societies.  \n\uf0b7 In Human -Machine System, both human and machines are involved to perform a \nparticular task. For example, Computer programming.  \n\uf0b7 Machine Syst em is where human interference is neglected. All the tasks are \nperformed by the machine. For example, an autonomous robot.  \nMan\u2013Made Information Systems  \n\uf0b7 It is an interconnected set of information resources to manage data for particular \norganization, under D irect Management Control (DMC).", "mimetype": "text/plain", "start_char_idx": 185683, "end_char_idx": 190418, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "e7c345aa-3114-4a76-94c1-6df680d972d7": {"__data__": {"id_": "e7c345aa-3114-4a76-94c1-6df680d972d7", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "94351431-31da-41da-9a05-fac85280d386", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "af1713175d7bcf335daed6c26006f2eee7eddc32ea79f576da13e4fa8e3a641c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "c4f9b63a-d006-4ecf-beed-4648424b17f1", "node_type": "1", "metadata": {}, "hash": "3719e432b59877befc059aff52e9e49c4241793aea578a61652a765e0ac79e04", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "For example, two molecules of \nhydrogen and one molecule of oxygen makes water.  \n\uf0b7 Probabilistic System shows uncertain behavior. The exact output is not known. For \nexample, Weather forecasting, mail deliv ery. \nSocial, Human -Machine, Machine System  \n\uf0b7 Social System is made up of people. For example, social clubs, societies.  \n\uf0b7 In Human -Machine System, both human and machines are involved to perform a \nparticular task. For example, Computer programming.  \n\uf0b7 Machine Syst em is where human interference is neglected. All the tasks are \nperformed by the machine. For example, an autonomous robot.  \nMan\u2013Made Information Systems  \n\uf0b7 It is an interconnected set of information resources to manage data for particular \norganization, under D irect Management Control (DMC).  \n\uf0b7 This system includes hardware, software, communication, data, and application for \nproducing information according to the need of an organization.  \nMan-made  information systems are divided into three types \u2212  \n\uf0b7 Formal Information System  \u2212 It is based on the flow of information in the form \nof memos, instructions, etc., from top level to lower levels of management.  \n\uf0b7 Informal Information System  \u2212 This is employee ba sed system which solves the \nday to day work related problems.  \n\uf0b7 Computer Based System  \u2212 This system is directly dependent on the computer for \nmanaging business applications. For example, automatic library system, railway \nreservation system, banking system, e tc. \n \n8 What is structured design? Illustrate the structured design process from DFD to structured \nchart with a case study. NOV/DEC 2016,  \nStructured Analysis is a development method that allows the analyst to understand the system and \nits activities in a lo gical way.  \nIt is a systematic approach, which uses graphical tools that analyze and refine the objectives of an \nexisting system and develop a new system specification which can be easily understandable by \nuser.  \nIt has following attributes \u2212  \n\uf0b7 It is graphic which specifies the presentation of application.  \n\uf0b7 It divides the processes so that it gives a clear picture of system flow.  \n\uf0b7 It is logical rather than physical i.e., the elements of system do not depend on vendor o r \nhardware.  \n11\n0  \n \uf0b7 It is an approach that works from high -level overviews to lower -level details.  \nStructured Analysis Tools  \nDuring Structured Analysis, various tools and techniques are used for system development. They \nare \u2212  \n\uf0b7 Data Flow Diagrams  \n\uf0b7 Data Dictionary  \n\uf0b7 Decision Trees  \n\uf0b7 Decision Tables  \n\uf0b7 Structured English  \n\uf0b7 Pseudocode  \n \nData Flow Diagrams (DFD) or Bubble Chart  \nIt is a technique developed b y Larry Constantine to express the requirements of system in a \ngraphical form.  \n\uf0b7 It shows the flow of data between various functions of system and specifies how the \ncurrent system is implemented.  \n\uf0b7 It is an initial stage of design phase that functionally divid es the requirement specifications \ndown to the lowest level of detail.  \n\uf0b7 Its graphical nature makes it a good communication tool between user and analyst or \nanalyst and system designer.  \n\uf0b7 It gives an overview of what data a system processes, what transformation s are performed, \nwhat data are stored, what results are produced and where they flow.  \n11\n1  \n Basic Elements of DFD  \nDFD is easy to understand and quite effective when the required design is not clear and the user \nwants a notational language for communication. Howe ver, it requires a large number of iterations \nfor obtaining the most accurate and complete solution.  \nThe following table shows the symbols used in designing a DFD and their significance \u2212  \nSymbol Name  Symbol  Meaning  \nSquare  \n Source or Destination of Data  \nArrow  \n Data flow  \nCircle  \n Process transforming data flow  \nOpen Rectangle  \n Data Store  \nTypes of DFD  \nDFDs are of two types: Physical DFD and Logical DFD. The following table lists the points that \ndifferentiate a physical DFD from a logical DFD.  \nPhysical DFD  Logical DFD  \nIt is implementation dependent . It shows which functions are performed.  It is implementation independent. It focuses only on the flow of data between \nprocesses.  \nIt provides low level details of hardware, software, files, and people.  It explains events of systems and data required by e ach event.  \nIt depicts how the current system operates and how a system will be implemented.  It shows how business operates; not how the system can be implemented.  \n11\n2  \n Context Diagram  \nA context diagram helps in understanding the entire system by one DFD which  gives the overview \nof a system.", "mimetype": "text/plain", "start_char_idx": 189641, "end_char_idx": 194249, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c4f9b63a-d006-4ecf-beed-4648424b17f1": {"__data__": {"id_": "c4f9b63a-d006-4ecf-beed-4648424b17f1", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "e7c345aa-3114-4a76-94c1-6df680d972d7", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "325c34d816948c15b0bb11df7f1500f22ce97b10e6f866dd4c16fbd9c321971b", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7448f40b-b826-4777-a93c-cba0253fb59f", "node_type": "1", "metadata": {}, "hash": "3155e992a3f8a7a16e37681e36e7a30dc9ff052f63feaabdd4b4aaefa514ede8", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The following table lists the points that \ndifferentiate a physical DFD from a logical DFD.  \nPhysical DFD  Logical DFD  \nIt is implementation dependent . It shows which functions are performed.  It is implementation independent. It focuses only on the flow of data between \nprocesses.  \nIt provides low level details of hardware, software, files, and people.  It explains events of systems and data required by e ach event.  \nIt depicts how the current system operates and how a system will be implemented.  It shows how business operates; not how the system can be implemented.  \n11\n2  \n Context Diagram  \nA context diagram helps in understanding the entire system by one DFD which  gives the overview \nof a system. It starts with mentioning major processes with little details and then goes onto giving \nmore details of the processes with the top -down approach.  \nThe context diagram of mess management is shown below.  \n \nData Dictionary  \nA data dictionary is a structured repository of data elements in the system. It stores the descriptions \nof all DFD data elements that i s, details and definitions of data flows, data stores, data stored in \ndata stores, and the processes.  \nA data dictionary improves the communication between the analyst and the user. It plays an \nimportant role in building a database. Most DBMSs have a data d ictionary as a standard feature. \nFor example, refer the following table \u2212  \nSr.No.  Data Name  Description  \n1 ISBN  ISBN Number  \n2 TITLE  title \n3 SUB  Book Subjects  \n11\n3  \n 4 ANAME  Author Name  15 \nDecision Trees  \nDecision trees are a method fo r defining complex relationships by describing decisions and \navoiding the problems in communication. A decision tree is a diagram that shows alternative \nactions and conditions within horizontal tree framework. Thus, it depicts which conditions to \nconsider first, second, and so on.  \nDecision trees depict the relationship of each condition and their permissible actions. A square \nnode indicates an action and a circle indicates a condition. It forces analysts to consider the \nsequence of decisions and identifies the actual decision that must be made.  \n \nThe major limitation of a decision tree is that it lacks information in its format to descri be what \nother combinations of conditions you can take for testing. It is a single representation of the \nrelationships between conditions and actions.  \nFor example, refer the following decision tree \u2212  \n \n11\n4  \n Decision Tables  \nDecision tables are a method of describing the complex logical relationship in a precise manner \nwhich is easily understandable.  \n\uf0b7 It is useful in situations where the resulting actions depend on the occurrence of one or \nseveral combinations of independent conditions.  \n\uf0b7 It is a matrix containing row or columns for defining  a problem and the actions.  \nComponents of a Decision Table  \n\uf0b7 Condition Stub  \u2212 It is in the upper left quadrant which lists all the condition to be \nchecked.  \n\uf0b7 Action Stub  \u2212 It is in the lower left quadrant which outlines all the action to be carried out \nto meet such condition.  \n\uf0b7 Condition Entry  \u2212 It is in upper right quadrant which pro vides answers to questions asked \nin condition stub quadrant.  \n\uf0b7 Action Entry  \u2212 It is in lower right quadrant which indicates the appropriate action \nresulting from the answers to the conditions in the condition entry quadrant.  \nThe entries in decision table are  given by Decision Rules which define the relationships between \ncombinations of conditions and courses of action. In rules section,  \n\uf0b7 Y shows the existence of a condition.  \n\uf0b7 N represents the condition, which is not satisfied.  \n\uf0b7 A blank - against action states it  is to be ignored.  \n\uf0b7 X (or a check mark will do) against action states it is to be carried out.  \n \n11\n5  \n 9 (a) Describe golden rules for interface design  NOV/DEC  2016  \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, d escribed by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent commands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are  very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback.", "mimetype": "text/plain", "start_char_idx": 193532, "end_char_idx": 198173, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7448f40b-b826-4777-a93c-cba0253fb59f": {"__data__": {"id_": "7448f40b-b826-4777-a93c-cba0253fb59f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "c4f9b63a-d006-4ecf-beed-4648424b17f1", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "2956aefbf950b9a1a8258d096691dcb1830eb646ab6c5ae6fe7b29a3b7b005c7", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "716ebf8f-074c-4c50-91e4-39cc655b3c10", "node_type": "1", "metadata": {}, "hash": "08624dcaabd6471105485cc7662bd782d218dacd08004dbf9257adc00650de75", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "11\n5  \n 9 (a) Describe golden rules for interface design  NOV/DEC  2016  \nUser Interface Golden rules  \nThe following rules are mentioned to be the golden rules for GUI design, d escribed by \nShneiderman and Plaisant in their book (Designing the User Interface).  \n\uf0b7 Strive for consistency  - Consistent sequences of actions should be required in similar \nsituations. Identical terminology should be used in prompts, menus, and help screens. \nConsistent commands should be employed throughout.  \n\uf0b7 Enable frequent users to use short -cuts - The user\u2019s desire to reduce the number of \ninteractions increases with the frequency of use. Abbreviations, function keys, hidden \ncommands, and macro facilities are  very helpful to an expert user.  \n\uf0b7 Offer informative feedback  - For every operator action, there should be some system \nfeedback. For frequent and minor actions, the response must be modest, while for \ninfrequent and major actions, the response must be more su bstantial.  \n\uf0b7 Design dialog to yield closure  - Sequences of actions should be organized into groups \nwith a beginning, middle, and end. The informative feedback at the completion of a group \nof actions gives the operators the satisfaction of accomplishment, a s ense of relief, the \nsignal to drop contingency plans and options from their minds, and this indicates that the \nway ahead is clear to prepare for the next group of actions.  \n\uf0b7 Offer simple error handling  - As much as possible, design the system so the user wil l not \nmake a serious error. If an error is made, the system should be able to detect it and offer \nsimple, comprehensible mechanisms for handling the error.  \n\uf0b7 Permit easy reversal of actions  - This feature relieves anxiety, since the user knows that \nerrors ca n be undone. Easy reversal of actions encourages exploration of unfamiliar \noptions. The units of reversibility may be a single action, a data entry, or a complete group \nof actions.  \n\uf0b7 Support internal locus of control  - Experienced operators strongly desire t he sense that \nthey are in charge of the system and that the system responds to their actions. Design the \nsystem to make users the initiators of actions rather than the responders.  \n(b) Reduce short -term memory load  - The limitation of human information processi ng in short -\nterm memory requires the displays to be kept simple, multiple page displays be consolidated, \nwindow -motion frequency be reduced, and sufficient training time be allotted for codes, \nmnemonics, and sequences of actions   \nRefer class notes  \n10 What  is software architecture ? Describe in detail different types of software architectural \nstyles with illustrations. APRIL/MAY 2017, APRIL/MAY 2018  \nThe architecture of a system describes its major components, their relationships (structures), and \nhow they i nteract with each other. Software architecture and design includes several contributory \nfactors such as Business strategy, quality attributes, human dynamics, design, and IT environment.  \n11\n6  \n \n \nWe can segregate Software Architecture and Design into two distinct phases: Software \nArchitecture and Software Design. In  Architecture , nonfunctional decisions are cast and separated \nby the functional requirements. In Design, functional requirements are accomplished.  \nSoftware Architecture  \nArchitecture serves as a  blueprint for a system . It provides an abstraction to manage the system \ncomplexity and establish a communication and coordina tion mechanism among components.  \n\uf0b7 It defines a  structured solution  to meet all the technical and operational requirements, \nwhile optimizing the common quality attributes like performance and security.  \n\uf0b7 Further, it involves a set of significant decisions abou t the organization related to software \ndevelopment and each of these decisions can have a considerable impact on quality, \nmaintainability, performance, and the overall success of the final product. These decisions \ncomprise of \u2212  \no Selection of structural elem ents and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavioral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork together to fulfill the requirement of the system. The objectives of having a design plan are  as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n11\n7  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including detailed design, coding, integration, and testing.", "mimetype": "text/plain", "start_char_idx": 197334, "end_char_idx": 202167, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "716ebf8f-074c-4c50-91e4-39cc655b3c10": {"__data__": {"id_": "716ebf8f-074c-4c50-91e4-39cc655b3c10", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7448f40b-b826-4777-a93c-cba0253fb59f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5d8a3f909251ca6f911f7aaa9bb5b6ef51e84b1d663971a6430d2c85b053fec1", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a4829875-4df5-4215-bdc3-21c4dbcc8d88", "node_type": "1", "metadata": {}, "hash": "e46ec613ef05d7fe329d9575767432841015f2c54983a14f9daebe216ed45b99", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These decisions \ncomprise of \u2212  \no Selection of structural elem ents and their interfaces by which the system is \ncomposed.  \no Behavior as specified in collaborations among those elements.  \no Composition of these structural and behavioral elements into large subsystem.  \no Architectural decisions align with business objectives.  \no Architectural styles guide the organization.  \nSoftware Design  \nSoftware design provides a  design plan  that describes the elements of a system, how they fit, and \nwork together to fulfill the requirement of the system. The objectives of having a design plan are  as \nfollows \u2212  \n\uf0b7 To negotiate system requirements, and to set expectations with customers, marketing, and \n11\n7  \n management personnel.  \n\uf0b7 Act as a blueprint during the development process.  \n\uf0b7 Guide the implementation tasks, including detailed design, coding, integration, and testing.  \nIt comes before the detailed design, coding, integration, and testing and after the domain analysis, \nrequirements analysis, and risk analysis.  \n \nGoals of Architecture  \nThe primary goal of the architecture is to identify requirements that affect the structure of the \napplication. A well -laid architecture reduces the business risks associated with building a technical \nsolut ion and builds a bridge between business and technical requirements.  \nSome of the other goals are as follows \u2212  \n\uf0b7 Expose the structure of the system, but hide its implementation details.  \n\uf0b7 Realize all the use -cases and scenarios.  \n\uf0b7 Try to address the requirements of various stakeholders.  \n\uf0b7 Handle both functional and quality requirements.  \n\uf0b7 Reduce the goal of ownership and improve the organization\u2019s market position.  \n\uf0b7 Improve quality and functionality offered by the system.  \n\uf0b7 Improve external confidence in either the organi zation or system.  \nLimitations  \nSoftware architecture  is still an emerging discipline within software engineering. It has the \nfollowing limitations \u2212  \n\uf0b7 Lack of tools and standardized ways to represent architecture.  \n\uf0b7 Lack of analysis methods to predict whether architecture will result in an implementation \nthat m eets the requirements.  \n\uf0b7 Lack of awareness of the importance of architectural design to software development.  \n\uf0b7 Lack of understanding of the role of software architect and poor communication among \n11\n8  \n stakeholders.  \n\uf0b7 Lack of understanding of the design process, desi gn experience and evaluation of design.  \n \n11 What is the purpose of DFD ?What are the compoenets of DFD? Construct DFD for the \nfollowing system..  \nAn online shopping system for xyz provides many services and  \nbenefits to its members and staffs. APRIL/MAY 201 8 \nstructure chart is a chart derived from Data Flow Diagram. It represents the system in more detail \nthan DFD. It breaks down the entire system into lowest functional modules, describes functions \nand sub -functions of each module of the system to a greater detail than DFD.  \nStructure chart represents hierarchical structure of modules. At each layer a specific task is \nperformed.  \nHere are the symbols used in construction of structure charts - \n\uf0b7 Module  - It represents process or subroutine or task. A control modul e branches to more \nthan one sub -module. Library Modules are re -usable and invokable from any \nmodule.\n  \n\uf0b7 Condition  - It is represented by small d iamond at the base of module. It depicts that control \nmodule can select any of sub -routine based on some \ncondition.\n  \n\uf0b7 Jump  - An arrow is show n pointing inside the module to depict that the control will jump \n11\n9  \n in the middle of the sub -module.\n  \n\uf0b7 Loop  - A curved arrow represents loop in the module. All sub -modules covered by loop \nrepeat execution of \nmodule.\n  \n\uf0b7 Data flow  - A directed arrow with empty circle at the end represents data \nflow.\n  \n\uf0b7 Control flow  - A directed arrow with filled circle at the end represents control \nflow.\n  \n12\n0  \n HIPO Diagram  \nHIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to \nanalyze the system and provide the means of documentation. HIPO model was  developed by IBM \nin year 1970.  \nHIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO \ndiagram in order to obtain high -level view of system functions. It decomposes functions into sub -\nfunctions in a hierarchical manner. It depicts the functions performed by system.  \nHIPO diagrams are good for documentation purpose. Their graphical representation makes it easier \nfor designers and managers to get the pictorial idea of the system structure.  \n \nIn contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a \nmodule, HIPO does not provide any information about data flow or control f low.", "mimetype": "text/plain", "start_char_idx": 201276, "end_char_idx": 206063, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a4829875-4df5-4215-bdc3-21c4dbcc8d88": {"__data__": {"id_": "a4829875-4df5-4215-bdc3-21c4dbcc8d88", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "716ebf8f-074c-4c50-91e4-39cc655b3c10", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "86627f033a93e2951cd70ff76dd9c37751bef3d22d99c4974a99570126fa5c6d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d", "node_type": "1", "metadata": {}, "hash": "88855692eb0141555181f71fb564cd3768b334faf60afe473a2cb461f59b36da", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "12\n0  \n HIPO Diagram  \nHIPO (Hierarchical Input Process Output) diagram is a combination of two organized method to \nanalyze the system and provide the means of documentation. HIPO model was  developed by IBM \nin year 1970.  \nHIPO diagram represents the hierarchy of modules in the software system. Analyst uses HIPO \ndiagram in order to obtain high -level view of system functions. It decomposes functions into sub -\nfunctions in a hierarchical manner. It depicts the functions performed by system.  \nHIPO diagrams are good for documentation purpose. Their graphical representation makes it easier \nfor designers and managers to get the pictorial idea of the system structure.  \n \nIn contrast to IPO (Input Process Output) diagram, which depicts the flow of control and data in a \nmodule, HIPO does not provide any information about data flow or control f low. \n \n \n \n12\n1  \n \n \n \n  \n12 Describe in detail about architectural styles?  \nArchitectural styles define the components and connectors ( \u2018what?\u2019)  \n \u2022 Less domain specific  \n \u2022 Good architecture makes use of design patterns (on a more finegranular level)  \n \u2022  Usually domain independent  \nAn architectural style is a named collection of architectural design decisions that  \n\u2212 are applicable in a give n development context  \n \u2212 constrain architectural design decisions that are specific to a particular system within that \ncontext  \n \u2212 elicit beneficial qualities in each resulting system  \n\u2022 Reflect less domain specificity than architectural patterns  \n \u2022 Useful in determining everything from subroutine structure to top -level application structure  \n\u2022 Many styles exist and we will discuss them in detail in the next lecture  \nBenefits of Using Styles  \nReuse  \n\u2022 Design: Well -understood solutions applied to new problems  \n\u2022 Code: Shared implementations of invariant aspects of a style  \n  Understandability of system organization  \n \u2022 A phrase such as \u201cclient -server\u201d conveys a lot of information  \n  Interoperability  \n12\n2  \n  \u2022 Supported by style standardization  \n \u2022 Style -specificity  \n \u2022 Anal yses: enabled by the constrained design space  \n \u2022 Visualizations: depictions matching engineers\u2019 mental models  \nBasic Properties of Style s \nA vocabulary of design elements  \n\u2022 Component and connector types; data elements  \n \u2212 e.g., pipes, filters, objects, serve rs \n\u201cArchitectural styles define the components and connectors\u201d  \n \u2022 A software connector is an architectural building block tasked with effecting and regulating \ninteractions among components (Taylor, Medvidovic, Dashofy)  \n \u2022 Procedure call connectors  \n \u2022 Share d memory connectors  \n \u2022 Message passing connectors  \n\u2022 Streaming connectors  \n\u2022 Distribution connectors  \n\u2022 Wrapper/adaptor connectors  \n A set of configuration rules  \n \u2022 Topological constraints that determine allowed compositions of elements  \n \u2212 e.g., a component may be connected to at most two other components  \n A semantic interpretation  \n \u2022 Compositions of design elements have well -defined meanings  \n \u2022 Possible analyses of systems built in a style  \n \n \n \n \n13 Explain transform mapping with suitable example and design steps involved in \nit.(Nov/Dec 2012)  \n \n \nTransform mapping is a set of design steps that allows a DFD with transform flow characteristics to \nbe mapped into a specific architectural style. In this section transform mapping is described by \napplying design steps to an example system \u2014a portion of the SafeHome security software.  \n \nAn Example  \n \nThe SafeHome security system is representative of many computer -based products and systems in \n12\n3  \n use today. The product monitors the real world and reacts to ch anges that it encounters. It also \ninteracts with a user through a series of typed inputs and alphanumeric displays. The level 0 data \nflow diagram for SafeHome, is shown in figure  \n \n \n \n \nDuring requirements analysis, more detailed flow models would be created for SafeHome. In \naddition, control and process specifications, a data dictionary, and various behavioral models would \nalso be created.  \n \nDesign  Steps  \n \nThe preceding example will be used to illustrate each step in transform mapping. The steps begin \nwith a re -evaluation of  work done during requirements analysis and then move to the design of the \nsoftware architecture.  \n \n \nStep 1. Review  the fundamental  system  model.  The fundamental system model encompasses the \nlevel 0 DFD and supporting information. In actuality, the design s tep begins with an evaluation of \nboth the System Specification and the Software Requirements Specification. Both documents \ndescribe information flow and structure at the software interface. Figure 1 and 2   depict level 0 and \nlevel 1 data flow for the SafeH ome software.  \n \n12\n4  \n \n \n \nStep 2. Review  and refine  data  flow diagrams  for the software.  Information obtained from \nanalysis models contained in the Software Requirements Specification is refined to produce greater \ndetail.", "mimetype": "text/plain", "start_char_idx": 205202, "end_char_idx": 210163, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d": {"__data__": {"id_": "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a4829875-4df5-4215-bdc3-21c4dbcc8d88", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c69938e7dda1c57c9f96112850c885565603603f6a80e80a6aab13b2839b21f2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "0bfc9fd9-2fd1-4288-8add-d5869e074b74", "node_type": "1", "metadata": {}, "hash": "a661e422c603555c00bc72aedfd9503c7e3adc4d87652381949b1ef39552a434", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Design  Steps  \n \nThe preceding example will be used to illustrate each step in transform mapping. The steps begin \nwith a re -evaluation of  work done during requirements analysis and then move to the design of the \nsoftware architecture.  \n \n \nStep 1. Review  the fundamental  system  model.  The fundamental system model encompasses the \nlevel 0 DFD and supporting information. In actuality, the design s tep begins with an evaluation of \nboth the System Specification and the Software Requirements Specification. Both documents \ndescribe information flow and structure at the software interface. Figure 1 and 2   depict level 0 and \nlevel 1 data flow for the SafeH ome software.  \n \n12\n4  \n \n \n \nStep 2. Review  and refine  data  flow diagrams  for the software.  Information obtained from \nanalysis models contained in the Software Requirements Specification is refined to produce greater \ndetail. For example, the level 2 DFD for monitor sensors   is exam ined, and a level 3 data flow \ndiagram is derived . At level 3, each transform in the data flow diagram exhibits relatively high \ncohesion. That is, the process implied by a transform performs a single, distinct function that can be \nimplemented as a module9 in the SafeHome software.   Therefore, the DFD in figure   contains \nsufficient detail for a \"first cut\" at the design of architecture for the monitor sensors subsystem, and \nwe proceed without further refinement.  \n \n12\n5  \n \n \n \nStep 3. Determine  whether  the DFD  has transform  or transa ction  flow characteristics.  In \ngeneral, information flow within a system can always be represented as transform. However, when \nan obvious transaction characteristic   is encountered, a different design mapping is recommended. \nIn this step, the designer sele cts global (softwarewide) flow characteristics based on the prevailing \nnature of the DFD. In addition, local regions of transform or transaction flow are isolated. These \nsubflows can be used to refine program architecture derived from a global characterist ic described \npreviously. For now, we focus our attention only on the monitor sensors subsystem data flow \ndepicted in figure.  \n \n \n \nEvaluating the DFD , we see data entering the software along one incoming path and exiting along \nthree outgoing paths. No distinct transaction  center is implied (although the transform establishes \n12\n6  \n alarm conditions that could be perceived as such). Therefore, an overall transform characteristic will \nbe assumed for information flow.  \n \nStep 4. Isolate  the transform  center  by specifying  incoming  and outgoing  flow boundaries.  In \nthe preceding section incoming flow was described as a path in which information is converted \nfrom external to internal form; outgoing flow converts from internal to external form. Incoming and \noutgoing flow boundaries are open  to interpretation. That is, different designers may select slightly \ndifferent points in the flow as boundary locations. In fact, alternative design solutions can be \nderived by varying the placement of flow boundaries. Although care should be taken when \nboundaries are selected, a variance of one bubble along a flow path will generally have little impact \non the final program structure.  \n \nFlow boundaries for the example are illustrated as shaded curves running vertically through the \nflow in the above figure. T he transforms (bubbles) that constitute the transform center lie within the \ntwo shaded boundaries that run from top to bottom in the figure. An argument can be made to \nreadjust a boundary (e.g, an incoming flow boundary separating read sensors and acquire response \ninfo could be proposed). The emphasis in this design step should be on selecting reasonable \nboundaries, rather than lengthy iteration on placement of divisions.  \n \nStep 5. Perform  \"first -level  factoring.\"  Program  structure  represents  a top-down  distribution  \nof control.  Factoring results in a program structure in which top -level modules perform decision \nmaking and low -level modules perform most input, computation, and output work. Middle -level \nmodules perform some control and do moderate amounts of wo rk. \n \nWhen transform flow is encountered, a DFD is mapped to a specific structure (a call and return \narchitecture) that provides control for incoming, transform, and outgoing information processing. \nThis first -level factoring for the monitor sensors subsyst em is illustrated in figure below. A main \ncontroller (called monitor sensors executive) resides at the top of the program structure and \ncoordinates the following subordinate control functions:  \n \n\u2022 An incoming information processing controller, called sensor  input controller, coordinates receipt \nof all incoming data.", "mimetype": "text/plain", "start_char_idx": 209261, "end_char_idx": 214010, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0bfc9fd9-2fd1-4288-8add-d5869e074b74": {"__data__": {"id_": "0bfc9fd9-2fd1-4288-8add-d5869e074b74", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "f2222376127139da4d69523ad805f688ba4dea8c1f51396908c565dcaafa7033", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "2d35f180-3f10-4e08-9917-3b0fe4587833", "node_type": "1", "metadata": {}, "hash": "d28f83cd8d18711f4fed73a49cd3ce9e096e5cabd04bf138973809d1716d432a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Step 5. Perform  \"first -level  factoring.\"  Program  structure  represents  a top-down  distribution  \nof control.  Factoring results in a program structure in which top -level modules perform decision \nmaking and low -level modules perform most input, computation, and output work. Middle -level \nmodules perform some control and do moderate amounts of wo rk. \n \nWhen transform flow is encountered, a DFD is mapped to a specific structure (a call and return \narchitecture) that provides control for incoming, transform, and outgoing information processing. \nThis first -level factoring for the monitor sensors subsyst em is illustrated in figure below. A main \ncontroller (called monitor sensors executive) resides at the top of the program structure and \ncoordinates the following subordinate control functions:  \n \n\u2022 An incoming information processing controller, called sensor  input controller, coordinates receipt \nof all incoming data.  \n\u2022 A transform flow controller, called alarm conditions controller, supervises all operations on data in \ninternalized form (e.g., a module that invokes various data transformation procedures).  \n \u2022 An outgoing information processing controller, called alarm output controller,  \ncoordinates production of output information.  \n \n12\n7  \n \n \n \nAlthough a three -pronged structure is implied by figure complex flows in large systems may dictate \ntwo or more control modules for each of the  generic control functions described previously. The \nnumber of modules at the first level should be limited to the minimum that can accomplish control \nfunctions and still maintain good coupling and cohesion characteristics.  \n \nStep 6. Perform  \"second -level  factoring.\"  Second -level  factoring  is accomplished  by mapping  \nindividual  transforms  (bubbles)  of a DFD  into appropriate  modules  within  the \narchitecture.  Beginning at the transform center boundary and moving outward along incoming and \nthen outgoing paths, tr ansforms are mapped into subordinate levels of the software structure. The \ngeneral approach to second -level factoring for the SafeHome data flow is illustrated in figure.  \n \n \n12\n8  \n \n \n \n \nAlthough the figure illustrates a one -to-one mapping between DFD transforms and software \nmodul es, different mappings frequently occur. Two or even three bubbles can be combined and \nrepresented as one module (recalling potential problems with cohesion) or a single bubble may be \nexpanded to two or more modules. Practical considerations and measures o f design quality dictate \nthe outcome of secondlevel factoring. Review and refinement may lead to changes in this structure, \nbut it can serve as a \"first -iteration\" design.  \n \nSecond -level factoring for incoming flow follows in the same manner. Factoring is a gain \naccomplished by moving outward from the transform center boundary on the incoming flow side. \nThe transform center of monitor sensors subsystem software is mapped somewhat differently. Each \nof the data conversion or calculation transforms of the transf orm portion of the DFD is mapped into \na module subordinate to the transform controller. A completed first -iteration architecture is shown \nin figure.  \n \n12\n9  \n \n \n \n \nThe modules mapped in the preceding manner and shown in figure represent an initial design of \nsoftware architecture. Although modules are named in a manner that implies function, a brief \nprocessing narrative (adapted from the PSPEC created during analysis modeling) should be written \nfor each. The narrative describes  \n\u2022 Information that passes into and out of the module (a n interface description).  \n\u2022 Information that is retained by a module, such as data stored in a local data structure.  \n\u2022 A procedural narrative that indicates major decision points and tasks.  \n\u2022 A brief discussion of restrictions and special features (e.g., f ile I/O, hardwaredependent \ncharacteristics, special timing requirements).  \nThe narrative serves as a first -generation Design Specification. However, further refinement and \nadditions occur regularly during this period of design.  \n \nStep 7. Refine  the first-iteration  architecture  using  design  heuristics  for improved  software  \nquality.  A first -iteration architecture can always be refined by applying concepts of module \nindependence . Modules are exploded or imploded to produce sensible factoring, good cohesion, \nminimal coupling, and most important, a structure that can be implemented without difficulty, \ntested without confusion, and maintained without grief.  \n \nRefinements are dictated by the analysis and assessment methods described briefly , as well as \npractical con siderations and common sense. There are times, for example, when the controller for \nincoming data flow is totally unnecessary, when some input processing is required in a module that \nis subordinate to the transform controller, when high coupling due to glo bal data cannot be avoided, \nor when  \noptimal structural characteristics   cannot be achieved.", "mimetype": "text/plain", "start_char_idx": 213067, "end_char_idx": 218074, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2d35f180-3f10-4e08-9917-3b0fe4587833": {"__data__": {"id_": "2d35f180-3f10-4e08-9917-3b0fe4587833", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "0bfc9fd9-2fd1-4288-8add-d5869e074b74", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "23d17da4199b7c0f9e12513129cd7d8729db799e502adba8ff202877c4f749c5", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "cac64d6e-536a-4c25-b078-89bd17dfef59", "node_type": "1", "metadata": {}, "hash": "115e8c36e85fd859e0cd54f59d2a907f96f4ea463ad7b7f1df02d919373b1f63", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Step 7. Refine  the first-iteration  architecture  using  design  heuristics  for improved  software  \nquality.  A first -iteration architecture can always be refined by applying concepts of module \nindependence . Modules are exploded or imploded to produce sensible factoring, good cohesion, \nminimal coupling, and most important, a structure that can be implemented without difficulty, \ntested without confusion, and maintained without grief.  \n \nRefinements are dictated by the analysis and assessment methods described briefly , as well as \npractical con siderations and common sense. There are times, for example, when the controller for \nincoming data flow is totally unnecessary, when some input processing is required in a module that \nis subordinate to the transform controller, when high coupling due to glo bal data cannot be avoided, \nor when  \noptimal structural characteristics   cannot be achieved. Software requirements coupled with human \njudgment is the final arbiter. Many modifications can be made to the first iteration architecture \ndeveloped for the SafeHom e monitor sensors subsystem. Among many possibilities,  \n \n1. The incoming controller can be removed because it is unnecessary when a single incoming flow \npath is to be managed.  \n \n2. The substructure generated from the transform flow can be imploded into the m odule establish \nalarm conditions (which will now include the processing implied by select phone number). The \ntransform controller will not be needed and the small decrease in cohesion is tolerable.  \n \n3. The modules format display and generate display can be  imploded (we assume that display \nformatting is quite simple) into a new module called produce display.  \n \n13\n0  \n The refined software structure for the monitor sensors subsystem is shown in figure.  \n \n \n \n \nThe objective of the preceding seven steps is to develop an architectural re presentation of software. \nThat is, once structure is defined, we can evaluate and refine software architecture by viewing it as a \nwhole. Modifications made at this time require little additional work, yet can have a profound \nimpact on software quality.  \n \nThe reader should pause for a moment and consider the difference between the design approach \ndescribed and the process of \"writing programs.\" If code is the only representation of software, the \ndeveloper will have great difficulty evaluating or refining at a  global or holistic level and will, in \nfact, have difficulty \"seeing the forest for the trees.\"  \n \n14 Explain the design principles in detail  \nDesign principles are widely applicable laws, guidelines, biases and design considerations which \ndesigners apply wi th discretion. Professionals from many disciplines \u2014e.g., behavioral science, \nsociology, physics and ergonomics \u2014provided the foundation for design principles via their \naccumulated knowledge and experience.  \nTypes of Design Principles  \nDesigners use principles  such as  visibility , findability  and learnability  to address basic human \nbehaviors. We  use some design principles to guide actions . Perceived affordances  such as \nbuttons are an example. That way, we  put users in control in seamless experiences . \nUsability k ingpin Jakob Nielsen identified ten \u201ccommandments\u201d:  \n\uf0b7 Keep users informed  of system status  with constant feedback.  \n\uf0b7 Set information in a logical, natural order . \n\uf0b7 Ensure users can easily undo/redo actions . \n\uf0b7 Maintain consistent standards  so users know what to do next without having to learn new \ntoolsets.  \n\uf0b7 Prevent errors if possible ; wherever you can\u2019t do this,  warn  users before they commit to \nactions.  \n13\n1  \n \uf0b7 Don\u2019t make users remember information  \u2013 keep options, etc.  visible . \n\uf0b7 Make systems flexible  so novices and experts ca n choose  to do more or less on them.  \n\uf0b7 Design with aesthetics and minimalism in mind  \u2013 don\u2019t clutter with unnecessary items.  \n\uf0b7 Provide plain -language error messages  to pinpoint problems and likely solutions.  \n\uf0b7 Offer easy -to-search troubleshooting resources , if needed.  \nEmpathy expert Whitney Hess adds:  \n1. Don\u2019t interrupt or give users obstacles  \u2013 make obvious pathways which offer an easy ride.  \n2. Offer few options  \u2013 don\u2019t hinder users with nice -to-haves; give them needed alternatives instead.  \n3. Reduce distraction s \u2013 let users perform tasks consecutively, not simultaneously.  \n4. Cluster related objects together.  \n5. Have an easy -to-scan visual hierarchy that reflects users\u2019 needs , with commonly used items \nhandily available.  \n6. Make things easy to find.  \n7. Show users where they\u2019ve come from  and where they\u2019re headed with signposts/cues.  \n8. Provide context  \u2013 show how everything interconnects.  \n9.", "mimetype": "text/plain", "start_char_idx": 217161, "end_char_idx": 221878, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cac64d6e-536a-4c25-b078-89bd17dfef59": {"__data__": {"id_": "cac64d6e-536a-4c25-b078-89bd17dfef59", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "2d35f180-3f10-4e08-9917-3b0fe4587833", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "91c99fb23e0ff5027386d0d01911bb84117234203e2719ebf60fe2726850269d", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d06932a8-b777-482b-9c1c-2d42fb497a46", "node_type": "1", "metadata": {}, "hash": "e8d459b7ac11c3d589eea83042a1ba7a312e6520dacf03105fd1218ec0dcbd34", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Provide plain -language error messages  to pinpoint problems and likely solutions.  \n\uf0b7 Offer easy -to-search troubleshooting resources , if needed.  \nEmpathy expert Whitney Hess adds:  \n1. Don\u2019t interrupt or give users obstacles  \u2013 make obvious pathways which offer an easy ride.  \n2. Offer few options  \u2013 don\u2019t hinder users with nice -to-haves; give them needed alternatives instead.  \n3. Reduce distraction s \u2013 let users perform tasks consecutively, not simultaneously.  \n4. Cluster related objects together.  \n5. Have an easy -to-scan visual hierarchy that reflects users\u2019 needs , with commonly used items \nhandily available.  \n6. Make things easy to find.  \n7. Show users where they\u2019ve come from  and where they\u2019re headed with signposts/cues.  \n8. Provide context  \u2013 show how everything interconnects.  \n9. Avoid jargon . \n10. Make designs efficient and streamlined.  \n11. Use defaults wisely  \u2013 when you offer predetermined, well -consider ed options, you help \nminimize users\u2019 decisions and increase efficiency.  \n12. Don\u2019t delay users  \u2013 ensure quick interface responses.  \n13. Focus on emotion  \u2013 pleasure of use is as vital as ease of use; arouse users\u2019 passion to increase \nengagement.  \n14. Use \u201cless  is more\u201d  \u2013 make everything count in the design. If functional and aesthetic elements \ndon\u2019t add to the user experience, forget them.  \n15. Be consistent with navigational mechanisms , organizational structure, etc., to make a stable, \nreliable and predictable design.  \n16. Create a good first impression . \n17. Be trustworthy and credible  \u2013 identify yourself through your design to assure users and \neliminate uncertainty.  \n \n \n \n \n \n \n13\n2  \n .   UNIT \u2013 4 PART  \u2013A \n \n \nS.NO  QUESTIONS  \n1 What  are the characteristics  of good  tester?  NOV/ DEC - 10,MAY/JUN -13 \nAll tests should be traceable to customer requirements. Tests should be planned \nlong before testing begins.  \nThe Pareto principle applies to software testing.  \n2 Define software testing?  \nSoftware testing is a critical element of software quality assurance and represents the ultimate \nreview of specification, design, and coding.  \n3 What are the objectives of testing?  \ni. Testing is a process of executing a program with the intend of finding an error. ii. A good \ntest case is one that has high probability of finding  \n an undiscovered error. iii. A successful test is one that uncovers as an - \nyet undiscovered error.  \n4 What is integration testing?and What are the approaches of integration \ntesting? APR/MAY -11 \n \nIn this testing the individual software  modules are combined and tested as a group. It occurs \nafter unit testing & before system testing.  \n1. The non -incremental  testing.  \n2. Incremental  testing.  \n5 What  is regression  testing?  APR/MAY -15 , NOV/DEC - 11,NOV/DEC  \n    2013,  \nIt tends to verify the software a pplication after a change has been made. It  seeks  to  uncover  \nsoftware  errors  by  partially  retesting  a  modified  \nprogram.  \n13\n3  \n 6 Distinguish between stress and load testing  \nStress testing is subjecting a system to an unreasonable load while denying it the \nresources (e.g., RAM, disc, mips, interrupts, etc.) needed to process that  load.  \nLoad testing is subjecting a system to a statistically representative (usually) load. The \ntwo main reasons for using such loads is in support of software reliability testin g and in \nperformance testing. The term \"load testing\" by itself is too \nvague and imprecise to warrant use.  \n7 Define black box testing? APR/MAY -12,MAY/JUN -13 \nA black -box tests are used to demonstrate that software functions are operational, that \ninput is p roperly accepted and output is correctly produced, and that the integrity of \nexternal  \ninformation.  \n8 What is boundary condition testing? APR/MAY -12 \nIt is tested using boundary value analysis. (check BVA \u2013 16 mark question)  \n \n9 How is software testing res ults related to the reliability of software? NOV/DEC -12 \nApplying fault avoidance, fault tolerance and fault detection  for \nthe project helps to achieve reliability of software.  \n10 What is big -bang approach?  NOV/DEC -12 \nBig bang approach talks about testing as the last  phase of  \ndevelopment.", "mimetype": "text/plain", "start_char_idx": 221066, "end_char_idx": 225266, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d06932a8-b777-482b-9c1c-2d42fb497a46": {"__data__": {"id_": "d06932a8-b777-482b-9c1c-2d42fb497a46", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "cac64d6e-536a-4c25-b078-89bd17dfef59", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "fdefa4ede38d28856f552a7484d65692ba6e14eeab0cf48d326fbf8b2a120d84", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "4a7089d1-ad69-4272-a3b9-000029dced56", "node_type": "1", "metadata": {}, "hash": "d5300df56886bc107d03af3d22e59e1c912fdaa522347c92d74d65a79b9a14e6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The term \"load testing\" by itself is too \nvague and imprecise to warrant use.  \n7 Define black box testing? APR/MAY -12,MAY/JUN -13 \nA black -box tests are used to demonstrate that software functions are operational, that \ninput is p roperly accepted and output is correctly produced, and that the integrity of \nexternal  \ninformation.  \n8 What is boundary condition testing? APR/MAY -12 \nIt is tested using boundary value analysis. (check BVA \u2013 16 mark question)  \n \n9 How is software testing res ults related to the reliability of software? NOV/DEC -12 \nApplying fault avoidance, fault tolerance and fault detection  for \nthe project helps to achieve reliability of software.  \n10 What is big -bang approach?  NOV/DEC -12 \nBig bang approach talks about testing as the last  phase of  \ndevelopment. All the defects are found in the last phase and cost of rework can be huge.  \n13\n4  \n 11 Why does software fail after it has passed from acceptance testing? APR/MAY 2016  \n \nEach acceptance test represents some expected result from th e system. Customers are \nresponsible for verifying the correctness of the acceptance tests and reviewing test scores to \ndecide which failed tests are of highest priority. Acceptance tests are also used as regression \ntests prior to a production release. A us er story is not considered complete until it has passed its \nacceptance tests. This means that new acceptance tests must be created for each iteration or the \ndevelopment team  will \nreport zero progress.  \n12 What are the objectives of testing?  \nxii. Testing is a process of executing a program with the intend of finding an  error.  \nxiii. A good test case is one that has high probability of finding an undiscovered  error.  \nxiv. A successful test is one that uncovers as an -yet undiscovered  \nerror.  \n13 What are the testing principles t he software engineer must apply while  performing\n the software  testing?     MAY/JUNE  2016,  \nAPRIL/MAY 2018  \ni. All tests should be traceable to customer  requirements.  \nii. Tests should be planned long before testing  begins.  \n iii. The pareto principle can be applied t o software testing -80%  \nof all  \nerrors uncovered during testing will likely be traceable to 20% of all program modules. \niv. Testing should begin \u201cin the small\u201d and progress toward testing \u201cin the large\u201d.  \nv. Exhaustive testing is not possible.  \nvi. To be most effecti ve, an independent third party should conduct  testing.  \n13\n5  \n 14 What are the two levels of testing?  \ni. Component testing Individual components are tested. Tests  are \nderived from developer\u201fs experience.  \nii. System Testing The group of components are integrated to create a system or sub - \nsystem is done.These tests are based on the system  specification.  \n15 What are the various testing activities?  \niii. Test planning  \niv. Test case  design \nv. Test execution  \nvi. Data  collection  \nvii. Effective evaluation  \n16 What is equivalence partitioning?  \nEquivalence partitioning is a black box technique that divides the input domain into \nclasses of data. From this data test cases can be derived. Equivalence class represents a set of \nvalid or invalid states for  \ninput conditions.  \n17 What methods are used for breaking very long expression and statements? \nNOV/DEC2016  \nRefactoring is done to break long expression and ststements.  \n16 What are the various testing strategi es for conventional software?  \ni. Unit testing ii. Integration testing. iii. Validation testing. iv. System testing.  \n18 How can refactoring be made more effective? APR/MAY 2016  \n \nRefactoring improves nonfunctional  attributes of the software . Advantages include improved \ncode readability and reduced complexity ; these can improve source -code maintainability  and \ncreate a more  \nexpressive interna l architecture or object model to improve extensibility  \n13\n6  \n 19 How will you tes t a simple loop  NOV/DEC 2015  \n \n\uf0b7 A simple loop is tested in the following  way:  \n\uf0b7 Skip the entire  loop.  \n\uf0b7 Make 1 pass through the loop.  \n\uf0b7 Make 2 passes through the loop.  \n\uf0b7 Make x passes through the loop where x<y, n is the maximum number of passes through \nthe loop.", "mimetype": "text/plain", "start_char_idx": 224467, "end_char_idx": 228629, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "4a7089d1-ad69-4272-a3b9-000029dced56": {"__data__": {"id_": "4a7089d1-ad69-4272-a3b9-000029dced56", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d06932a8-b777-482b-9c1c-2d42fb497a46", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "62ded8caa9380ab627eeeae6e95ba11cc09485b244c807ec92cb8097a1f6e156", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "03b32e81-c345-498d-aa38-548d034c71c7", "node_type": "1", "metadata": {}, "hash": "bc0349c638aced886f2e5e7e447e683ee5e978ddf8278be527906e131ad1a872", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "i. Unit testing ii. Integration testing. iii. Validation testing. iv. System testing.  \n18 How can refactoring be made more effective? APR/MAY 2016  \n \nRefactoring improves nonfunctional  attributes of the software . Advantages include improved \ncode readability and reduced complexity ; these can improve source -code maintainability  and \ncreate a more  \nexpressive interna l architecture or object model to improve extensibility  \n13\n6  \n 19 How will you tes t a simple loop  NOV/DEC 2015  \n \n\uf0b7 A simple loop is tested in the following  way:  \n\uf0b7 Skip the entire  loop.  \n\uf0b7 Make 1 pass through the loop.  \n\uf0b7 Make 2 passes through the loop.  \n\uf0b7 Make x passes through the loop where x<y, n is the maximum number of passes through \nthe loop.  \n\uf0b7 Make \"y\",\"y -1\",\"y+1\" passes through the loop where \"y\" is the maximum number of \nallowable passes through the  loop.  \n20 What are the conditions exists after performing validation testing?  \nAfter  performing  the validation  testing  there  exists  two conditions.  \n\uf0b7 The function or performance characteristics are according to the specifications and are  \naccepted.  \n\uf0b7 The requirement specifications are derived and the deficiency list is created. The \ndeficiencies then can be resolved by  establishing  \nthe proper communication wi th the customer.  \n21 Distinguish between alpha and beta testing.  MAY/JUNE 2016  \n\uf0b7 Alpha and beta testing are the types of acceptance  testing.  \n\uf0b7 Alpha test: The alpha testing is attesting in which the version of complete software is \ntested by the customer under the supervision of developer. This testing is performed  at \ndeveloper\u2019s  site. \n \uf0b7 Beta test: The beta testing is a testing in which the version of the software is tested by \nthe customer without the developer  being  \npresent. This testing is performed at custom er\u2019s site.  \n13\n7  \n  \n22 What are the various types of system testing?  \n3. Recovery testing \u2013 is intended to check the system\u201f s ability  to \nrecover from failures.  \n4. Security testing \u2013 verifies that system protection mechanism prevent  improper  \npenetration or data alteration.  \n5. Stress testing \u2013 Determines breakpoint of a system to establish maximum service  \nlevel.  \n6. Perfo rmance  testing  \u2013 evaluates  the run time performance  of \nthe software, especially real -time software.  \n23 Define debugging and What are the common approaches in debugging?  \nDebugging is defined as the process of removal of defect. It occurs as a consequence o f \nsuccessful testing  \nBrute force method: The memory dumps and run -time tracks are examined and program with  \nwrite statements is loaded to obtain clues to error causes.  \nBack tracking method: The source code is examined by looking backwards from symptom to  \npotential causes of errors.  \nCause elimination method: This method uses binary partitioning to reduce the number of \nlocations where errors can exists.  \n24 Distinguish between verification and validation. NOV/DEC2016,  NOV/DEC 2017, \nAPRIL/MAY 2018  \nVerification  Validation  \n \nEvaluates  the  intermediary  products  Evaluates the final product  to \n \n   to check   whether  it meets  the check whether it meets the specific\n requirements   ofthe business  needs.  \nparticular phase  \n13\n8  \n  \n The \u201cdriver\u201d is a program that accepts t he test data and prints the  \nrelevant results.  \nThe \u201cstub\u201d is a subprogram that uses the module interfaces and performs the minimal data manipulation if \nrequired.  Checks whether the product is  built   It   determines   whether    the  as per the specified \nrequirement and software is fit  for  use  and design  specification.  satisfy the business  \nneed.  \nChecks \u201cAre we building  the product  Checks \u201cAre we building the right\u201d?  right  \nproduct\u201d?  \nThis  is  done  wi thout  executing  the Is done with executing the software  software  \nInvolves  all the static  testing  Includes  all the dynamic techniques  \n    testing  techniques.  \n Examples  includes  reviews,  Example includes all types of inspection  and \nwalkthrough   testing l ike smoke,  regression,  \nfunctional, systems and UAT   \n25 What is meant by structural testing?  \nIn structural testing derivation of test cases is according to program \nstructure. Hence knowledge of the program is used to identify additional test cases.  \n26 Wha t is the need for regression testing?", "mimetype": "text/plain", "start_char_idx": 227889, "end_char_idx": 232224, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "03b32e81-c345-498d-aa38-548d034c71c7": {"__data__": {"id_": "03b32e81-c345-498d-aa38-548d034c71c7", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "4a7089d1-ad69-4272-a3b9-000029dced56", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "dd3a43b46c767ec6fe2a1ff44def6eaf45126d9548a2be3aca32ce8d1a129649", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7955dc08-67b9-494a-b986-394ceab886fd", "node_type": "1", "metadata": {}, "hash": "6b129ed836d85ddee6fac86c56ce0883b23358303ee17a48447a07c48b85737f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "satisfy the business  \nneed.  \nChecks \u201cAre we building  the product  Checks \u201cAre we building the right\u201d?  right  \nproduct\u201d?  \nThis  is  done  wi thout  executing  the Is done with executing the software  software  \nInvolves  all the static  testing  Includes  all the dynamic techniques  \n    testing  techniques.  \n Examples  includes  reviews,  Example includes all types of inspection  and \nwalkthrough   testing l ike smoke,  regression,  \nfunctional, systems and UAT   \n25 What is meant by structural testing?  \nIn structural testing derivation of test cases is according to program \nstructure. Hence knowledge of the program is used to identify additional test cases.  \n26 Wha t is the need for regression testing? APR/MAY 2015  \nThe purpose of regression testing is to confirm that a recent program or code change has \nnot adversely affected existing features. Regression testing is nothing but full or partial \nselection of already exe cuted test  \ncases which are re -executed to ensure existing functionalities work fine.  \n27 Write about drivers and stubs . NOV/DEC 2017  \nDrivers and stub software need to be developed to test incompatible software.  \n13\n9  \n 28 What is cyclomatic complexity?  \nCyclomatic   complexity   is    software  metric   that gives the quantitative  \nMeasure of logical complexity of the program.  \n29 How to compute the cyclomatic complexity?  \nThe cyclomatic complexity can be computed by any one of the following ways. 1. \nThe numbers of regions of the flow graph  correspond to the cyclom atic complexity.  \n2. Cyclomatic complexity (G), for the flow graph G, is defined as: V(G)=E -N+2, E \n-- number of flow graph edges, N -- number of flow graph  nodes  \n3. V(G) = P+1 Where P is the number of predicate  nodes  \ncontained in the flow graph.  \n30 List out the applications of GUI? April /May 2015  \nGUI-Graphical   User   Interface -   is    a    type    of interface that  allows users  to interact\n with electronic  devices through graphical icons \nand visual indicators such as secondary notation , as opposed to text-based interfaces,  typed \ncommand labels or text navigation  \n \nIn addition to computers, GUIs can be found in hand -held devices such as MP3 players, \nportable media players, gaming devices and smaller household, smar tphones office and \nindustry  equipment.  \nEg:Ticket booking, Inventory tool, Billing Machine, Windows OS  \n31 What is flow graph notation and how it is important. April /May  2015  \nA control flow graph (CFG) in computer science is a representation,  Using graph notation, \nof all paths that might be traversed through a program during its execution.  \n \n14\n0  \n 32 What is smoke testing ? APRIL /MAY 2017  \nSmoke Testing , also known as \u201cBuild Verification Testing \u201d, is a type of software testing \nthat comprises of a non -exhaustive set of tests that aim at ensuring that the most important \nfunctions work. The results of this testing is used to decide if a build is stable enough to \nproceed with  \nfurther testing . \n33 List testing strategies that address verification. Which types of testing a ddress \nvalidation ? APRIL/MAY 2017  \nVerification involves all the static testing techniques. Examples includes reviews, \ninspection and walkthrough  \nValidation includes all the dynamic testing techniques. Example includes all types of \ntesting like smoke, regr ession, functional, systems and  UAT  \n33 \nWhat are the types of static testing  tools?  \n \nThere are three types of static testing  tools.  \n \n\uf0d8 Code based testing tools : These tools take source code as input and generate test  \ncases.  \n\uf0d8 Specialized testing tools : Using  this language the detailed test specification can be \nwritten for each test  case.  \n\uf0d8 Requirement -based testing tools : These tools help in designing the as per user  \nrequirements.  \n34 \nWhat is done in test design step?  \n \nThe details of the layout, tooling and sta ndards required for test  \n development are designed in this stage.  \n14\n1  \n 35 Distinguish between verification and validation ? \nVerification refers to the set of activities that ensure that software correctly implements a \nspecific function. Validation refers to a different set of activities that ensure that the \nsoftware that has been built is  \ntraceable to the customer requirements.  \n36 Write about drivers and stubs?  \nDrivers and stub software need to be developed to test incompatible software.", "mimetype": "text/plain", "start_char_idx": 231504, "end_char_idx": 235911, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7955dc08-67b9-494a-b986-394ceab886fd": {"__data__": {"id_": "7955dc08-67b9-494a-b986-394ceab886fd", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "03b32e81-c345-498d-aa38-548d034c71c7", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "084908c5d2d015141f28475e664e40ad8dedd8e6f4140772bd55e33eb729e6b6", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "5fafacf9-f6ce-4140-a5d8-a6b865f91762", "node_type": "1", "metadata": {}, "hash": "439cd56540ec1141a87713911f7763d22f6f4a0c1e12551024bd6e916b42cf01", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0d8 Code based testing tools : These tools take source code as input and generate test  \ncases.  \n\uf0d8 Specialized testing tools : Using  this language the detailed test specification can be \nwritten for each test  case.  \n\uf0d8 Requirement -based testing tools : These tools help in designing the as per user  \nrequirements.  \n34 \nWhat is done in test design step?  \n \nThe details of the layout, tooling and sta ndards required for test  \n development are designed in this stage.  \n14\n1  \n 35 Distinguish between verification and validation ? \nVerification refers to the set of activities that ensure that software correctly implements a \nspecific function. Validation refers to a different set of activities that ensure that the \nsoftware that has been built is  \ntraceable to the customer requirements.  \n36 Write about drivers and stubs?  \nDrivers and stub software need to be developed to test incompatible software. The \u201cdriver\u201d \nis a prog ram that accepts the test data and prints the relevant results. The \u201cstub\u201d is a \nsubprogram that uses the module  \ninterfaces and performs the minimal data manipulation if required.  \n37 Define debugging . \nDebugging is defined as the process of removal of defec t. It occurs as a consequence of \nsuccessful testing.  \n38 \nDefine the terms:  \n \na) Graph  Matrices.  \n \nb) Connection  Matrices.  \n \nGraph Matrices:  \n \n To develop software tool the data structure used is graph  Matrix.  \n \n Square Matrix  \n \n Size equals number of nodes on the Flow  graph \n \nConnection Matrices:  \n \n It Link Weight = 1= > Connection  Exists  \n \n It Link Weight=1=>Connection Does not  Exists . \n14\n2  \n 39 \nWhat errors are commonly found during Unit Testing?  \n \nErrors commonly found during Unit Testing are:  \n \n\uf0b7 Misunderstood or incorrect arithmetic  precedence  \n \n\uf0b7 Mixed Mode  Operations  \n \n\uf0b7 Incorrect  Initializations  \n \n\uf0b7 Precision  Accuracy  \n \n\uf0b7 Incorrect Symbolic representation of  expression.  \n40 \nWhat problems may be encountered when Top -Down Integration is chosen?  \nFollowing problems may be encountered when Top Dow n Integration is chosen:  \n\uf0b7 Develop stubs that perform limited functions that simulate the actual module.  \nIntegrate the software from the bottom of the hierarchy upward  \n41 \nWhat are the Steps in Bottom -Up Integration?  \n \nSteps in Bottom -Up Integration are:  \n \n\uf0b7 Low level components are combined into clusters perform specific software sub  \nfunction.  \n\uf0b7 Driver is written to coordinate test case input and  output.  \n \n\uf0b7 Cluster is tested.  \n14\n3  \n 42 \nWhat is Flow Graph Notation?  \nFlow Graph Notation means Simple notation for representing  Control Flow. It is drawn \nonly when Logical Structure of component is complex.  \n43 \nWhat is acceptance testing  \n \nAcceptance testing : This type of testing involves testing of the system with customer data \nif the system behaves as per customer need then it is  accepted.  \n44 \nWhat are the various testing strategies for conventional software?  \n \nThe various testing strategies are:  \n \n(i) Unit testing  (ii) Integration  testing  \n \n(iii) Validation  testing  (iv) System  testing . \n45 \nList some of the testing done during SDLC.  \n \nWhite box testing, black box testing, integration testing, system testing, installation testing. \nRegression testing, Acceptance testing . \n46 \nWhat is functionality testing?  \n \nIt is a black box testing which exercises the basic functionality of the product f rom an \nexternal; perspective.  \n14\n4  \n 47 \nWhat are the steps carried out in installation  testing?  \n \nAns. The steps carried out in installation testing  are: \n \n\u2022 Packaging  \u2022 Documenting  \n \n\u2022 Installing  \u2022 Verifying  \n48 \nWhat are the objective of Formal Technical Reviews. Ans.  The Objective \nof Formal Technical Reviews are:  \n\uf0b7 Uncover  errors  in function,  logic  and implementation  for representation of  \nsoftware.  \n\uf0b7 Software represented according to predefined  standard.  \n \n\uf0b7 Verify software under review meets  requirements  \n \n\uf0b7 Achieve software d eveloped in Uniform  Manner.  \n \n\uf0b7 Make projects more  manageable.  \n49 \nExplain Integrated testing team model?  \nAns. There in one project manage who manages both the development and the testing \nfunctions  \n50 \nWhat are the common approaches in  debugging? Ans. The \ncommon approaches tin debugging  are: \n\uf0b7 Brute force method: The memory dumps and run - time tracks are examined and \nprogram with write statements in loaded to obtain clues to error  causes.", "mimetype": "text/plain", "start_char_idx": 234999, "end_char_idx": 239453, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "5fafacf9-f6ce-4140-a5d8-a6b865f91762": {"__data__": {"id_": "5fafacf9-f6ce-4140-a5d8-a6b865f91762", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7955dc08-67b9-494a-b986-394ceab886fd", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "67a4fe4a04edb9f868a6a0ada6b1efab5171e56b9c6c81d0efa0b53f6d8a7549", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "174d8f90-db6d-451e-9c85-a550145bb064", "node_type": "1", "metadata": {}, "hash": "a722937cfcd934b97027724d92fca8adefeafca83cdeec786499e0d7ab50e7b0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Ans.  The Objective \nof Formal Technical Reviews are:  \n\uf0b7 Uncover  errors  in function,  logic  and implementation  for representation of  \nsoftware.  \n\uf0b7 Software represented according to predefined  standard.  \n \n\uf0b7 Verify software under review meets  requirements  \n \n\uf0b7 Achieve software d eveloped in Uniform  Manner.  \n \n\uf0b7 Make projects more  manageable.  \n49 \nExplain Integrated testing team model?  \nAns. There in one project manage who manages both the development and the testing \nfunctions  \n50 \nWhat are the common approaches in  debugging? Ans. The \ncommon approaches tin debugging  are: \n\uf0b7 Brute force method: The memory dumps and run - time tracks are examined and \nprogram with write statements in loaded to obtain clues to error  causes.  \n\uf0b7 Back tracking method: The source code is examined by  looking  \n14\n5  \n  backwards f rom symptom to potential causes or errors.  \n \n\uf0b7 Causes eliminations method: This method uses binary partitioning to reduce the \nnumber of location where errors can exists.  \n \n \n \nPART \u2013B \n \n \nS.NO  QUESTIONS  \n1 What is black box & white -box testing ? Explain how basis path testing helps to derive test \ncases to test every statement of a program. NOV/DEC -12, APRIL/MAY 2015, NOV/DEC  \n2017, APRIL/MAY  2017  \nCriteria  Black Box Testing  White Box Testing  \nDefinition  Black Box Testing is a software testing \nmethod in which the internal structure/ \ndesign/ implementation of the item being \ntested is NOT known to the tester  White Box Testing is a software \ntesting method in which the internal \nstructure/ design/ imp lementation of \nthe item being tested is known to the \ntester.  \nLevels \nApplicable To  Mainly applicable to higher levels of \ntesting: Acceptance Testing  \nSystem Testing  Mainly applicable to lower levels of \ntesting: Unit Testing  \nIntegration Testing  \nResponsibility  Generally, independent Software Testers  Generally, Software Developers  \nProgramming \nKnowledge  Not Required  Required  \nImplementation \nKnowledge  Not Required  Required  \nBasis for Test \nCases  Requirement Specifications  Detail Design  \n \n2 Define: Regression testing. Distinguish: top -down and bottom -up integration. How is \ntesting different from debugging ? Justify NOV/DEC -10, APRIL/MAY 2018  \nRegression testin g (rarely  non-regression testing[1]) is re -running  functional  and non-\nfunctional tests  to ensure that previously developed and tested software still performs \nafter a change.[2] If not, that would be called a  regression . Changes that may require \nregression testing include  bug fixes, software enhancements,  configuration  changes, and \n14\n6  \n even substitution of  electronic components .[3] As regression test suites tend to grow with \neach found defect, test automation is frequently involved. Sometimes a  change impact \nanalysis  is performed to determine an appropriate subset of test  \n \n \nBASIS FOR \nCOMPARISON  TOP -DOWN INTEGRATION  \nTESTING  BOTTOM -UP \nINTEGRATION \nTESTING  \nBasic  Uses stubs as the momentary \nreplacements for the invoked modules \nand simulates the behaviour of the \nseparated lower -level modules.  Use test drivers to initiate \nand pass the required data \nto the lower -level of \nmodules.  \nBeneficial  If the significant d efect occurs toward \nthe top of the program.  If the crucial flaws \nencounters towards the \nbottom of the program.  \nApproach  Main function is written at first then the \nsubroutines are called from it.  Modules are created first \nthen are integrated with the \nmain function.  \nImplemented on  Structure/procedure -oriented \nprogramming languages.  Object -oriented \nprogramming languages.  \n14\n7  \n Risk analysation  Collaborating the impact of internal \noperational failures.  Models are used to analyze \nthe individual process.  \nComplexity  Simple  Complex and highly data \nintensive.  \nWorks on  Big to small components.  Small to big components.  \n \n \nTesting  and Debugging  are significant activities during software development and \nmaintenance.  Testing  aims at finding a problem while  Debugging  aims a t solving the \nproblem. Only after the testing team reports the  defect , debugging  can take place.  With \ndebugging, the developer identifies the problem in the system/application/code. Once \nthe developer has fixed the bug, tester re -tests to ensure that the e rror/bug no longer \nexists.", "mimetype": "text/plain", "start_char_idx": 238703, "end_char_idx": 243045, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "174d8f90-db6d-451e-9c85-a550145bb064": {"__data__": {"id_": "174d8f90-db6d-451e-9c85-a550145bb064", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "5fafacf9-f6ce-4140-a5d8-a6b865f91762", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7dc9789d03cce144a260e4f621b6df628f019a8e30a27cab9b88cce8520c2b2c", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "214472ca-989c-40f7-82ed-9b57efb4be8d", "node_type": "1", "metadata": {}, "hash": "0a89a658e458db0ba67b282b3b792f9f9fe9e69e84b7d1cd6e343dc90a5bf717", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Modules are created first \nthen are integrated with the \nmain function.  \nImplemented on  Structure/procedure -oriented \nprogramming languages.  Object -oriented \nprogramming languages.  \n14\n7  \n Risk analysation  Collaborating the impact of internal \noperational failures.  Models are used to analyze \nthe individual process.  \nComplexity  Simple  Complex and highly data \nintensive.  \nWorks on  Big to small components.  Small to big components.  \n \n \nTesting  and Debugging  are significant activities during software development and \nmaintenance.  Testing  aims at finding a problem while  Debugging  aims a t solving the \nproblem. Only after the testing team reports the  defect , debugging  can take place.  With \ndebugging, the developer identifies the problem in the system/application/code. Once \nthe developer has fixed the bug, tester re -tests to ensure that the e rror/bug no longer \nexists. The figure given below demonstrates the fact very well  \n3 Write a note on equivalence partitioning & boundary value analysis of black box \ntesting APR/MAY -16 , NOV/DEC -15 \nEquivalence partitioning (EP) is a specification -based or bl ack-box technique. It can be \napplied at any level of testing and is often a good technique to use first.  \n\uf0b7 The idea behind this technique is to divide (i.e. to partition) a set of test conditions into \ngroups or sets that can be considered the same (i.e. the system should handle them \nequivalently), hence \u2018equivalence partitioning\u2019.  Equivalence partitions  are also known \nas equivalence classes \u2013 the two terms mean exactly the same thing.  \n\uf0b7 In equivalence -partitioning technique we need to test only one condition fr om each \npartition. This is because we are assuming that all the conditions in one partition will be \ntreated in the same way by the software. If one condition in a partition works, we assume \nall of the conditions in that partition will work, and so there is  little point in testing any of \nthese others. Similarly, if one of the conditions in a partition does not work, then we \nassume that none of the conditions in that partition will work so again there is little point \nin testing any more in that partition.  \n \n4 What is unit testing? Why is it important? Explain the unit test consideration and \ntest procedure. APR/MAY - 11,MAY/JUN -13 NOV/DEC2015  \nA unit test  is the smallest testable part of an application like functions, \nclasses,  procedures, interfaces. Unit testing is a method by which individual units of \nsource code are tested to determine if they are fit for use.  \n14\n8  \n \uf0b7 Unit tests are basically written and executed by software developers  to make sure that \ncode meets its design and requirements and behaves as expected.  \n\uf0b7 The goal of unit testing is to segregate each part of the program and test that the \nindividual parts are working correctly.  \n\uf0b7 This means that for any function or procedure when a set of inputs are given then it \nshould return the proper values. It should handle the failures  gracefully during the course \nof execution when any invalid input is given.  \n\uf0b7 A unit test provides a written contract that the piece of code must assure. Hence it has \nseveral benefits.  \n\uf0b7 Unit testing is basically done before integration as shown in  the image below.  \n \nMethod Used for unit testing:  White Box Testing method is used for executing the unit test.  \nWhen Unit testing should be done?  \nUnit testing should be done before Integration testing.  \nBy whom unit testing should be done?  \nUnit testing should be done by the developers.  \nAdvantages of Unit testing:  \n1. Issues are found at early stage. Since unit testing are carried out by developers wher e they test \ntheir individual code before the integration. Hence the issues can be found very early and can be \nresolved then and there without impacting the other piece of codes.  \n2. Unit testing helps in maintaining and changing the code. This is possible b y making the codes \nless interdependent so that unit testing can be executed. Hence chances of impact of changes to \nany other code gets reduced.  \n3. Since the bugs are found early in unit testing hence it also helps in reducing the cost of bug \nfixes. Just im agine the cost of bug found during the later stages of development like during \nsystem testing or during acceptance testing.  \n4. Unit testing helps in simplifying the debugging process. If suppose a test fails then only latest \n14\n9  \n changes made in code needs to b e debugged.  \n \n5 Explain Integration & debugging activities?", "mimetype": "text/plain", "start_char_idx": 242141, "end_char_idx": 246674, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "214472ca-989c-40f7-82ed-9b57efb4be8d": {"__data__": {"id_": "214472ca-989c-40f7-82ed-9b57efb4be8d", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "174d8f90-db6d-451e-9c85-a550145bb064", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a51df3b05f0f765c48b9d437ae174a337cabb886ab38bf64c32c2641969f7ec3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f", "node_type": "1", "metadata": {}, "hash": "7d0b0f153dad2fdf0f1bed2e06b7fc4e7b66d6c400048f5d0449e3de3b54eec9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Since unit testing are carried out by developers wher e they test \ntheir individual code before the integration. Hence the issues can be found very early and can be \nresolved then and there without impacting the other piece of codes.  \n2. Unit testing helps in maintaining and changing the code. This is possible b y making the codes \nless interdependent so that unit testing can be executed. Hence chances of impact of changes to \nany other code gets reduced.  \n3. Since the bugs are found early in unit testing hence it also helps in reducing the cost of bug \nfixes. Just im agine the cost of bug found during the later stages of development like during \nsystem testing or during acceptance testing.  \n4. Unit testing helps in simplifying the debugging process. If suppose a test fails then only latest \n14\n9  \n changes made in code needs to b e debugged.  \n \n5 Explain Integration & debugging activities?  MAY/JUN -15 \n \nIntegration  testing  is the process of testing the interface between two software units or module. \nIt\u2019s focus on determining the correctness of the interface. The purpose of the integra tion testing is \nto expose faults in the interaction between integrated units. Once all the modules have been unit \ntested, integration testing is performed.  \n \nIntegration test approaches \u2013 \nThere are four types of integration testing approaches. Those approac hes are the following:  \n1. Big -Bang Integration Testing \u2013 \nIt is the simplest integration testing approach, where all the modules are combining and verifying \nthe functionality after the completion of individual module testing. In simple words, all the \nmodule s of the system are simply put together and tested. This approach is practicable only for \nvery small systems. If once an error is found during the integration testing, it is very difficult to \nlocalize the error as the error may potentially belong to any of  the modules being integrated. So, \ndebugging errors reported during big bang integration testing are very expensive to fix.  \nAdvantages  \n\uf0b7 It is convenient for small systems.  \nDisadvantages:  \n\uf0b7 There will be quite a lot of delay because you would have to wait for all the modules to \nbe integrated.  \n\uf0b7 High risk critical modules are not isolated and tested on priority since all modules are \ntested at once.  \n2. Bottom -Up Integration Testing \u2013 \nIn bottom -up testing, each module at lower levels is tested with higher modules un til all modules \nare tested. The primary purpose of this integration testing is, each subsystem is to test the \ninterfaces among various modules making up the subsystem. This integration testing uses test \ndrivers to drive and pass appropriate data to the low er level modules.  \nAdvantages:  \n\uf0b7 In bottom -up testing, no stubs are required.  \n\uf0b7 A principle advantage of this integration testing is that several disjoint subsystems can be \ntested simultaneously.  \nDisadvantages:  \n\uf0b7 Driver modules must be produced.  \n\uf0b7 In this testing, the complexity that occurs when the system is made up of a large number \nof small subsystem.  \n3. Top -Down Integration Testing \u2013 \nTop-down integration testing technique used in order to simulate the behaviour of the lower -level \nmodules that are not yet integra ted.In this integration testing, testing takes place from top to \nbottom. First high -level modules are tested and then low -level modules and finally integrating the \nlow-level modules to a high level to ensure the system is working as intended.  \nAdvantages:  \n\uf0b7 Separately debugged module.  \n\uf0b7 Few or no drivers needed.  \n15\n0  \n \uf0b7 It is more stable and accurate at the aggregate level.  \nDisadvantages:  \n\uf0b7 Needs many Stubs.  \n\uf0b7 Modules at lower level are tested inadequately.  \n4. Mixed Integration Testing \u2013 \nA mixed integration testing is also called sandwiched integration testing. A mixed integration \ntesting follows a combination of top down and bottom -up testing approaches. In top -down \napproach, testing can start only after the top -level module have been coded and unit tested. In \nbottom -up app roach, testing can start only after the bottom level modules are ready. This \nsandwich or mixed approach overcomes this shortcoming of the top -down and bottom -up \napproaches. A mixed integration testing is also called sandwiched integration testing.  \nAdvantag es: \n\uf0b7 Mixed approach is useful for very large projects having several sub projects.  \n\uf0b7 This Sandwich approach overcomes this shortcoming of the top -down and bottom -up \napproaches.  \nDisadvantages:  \n\uf0b7 For mixed integration testing, require very high cost because one p art has Top -down \napproach while another part has bottom -up approach.", "mimetype": "text/plain", "start_char_idx": 245767, "end_char_idx": 250425, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f": {"__data__": {"id_": "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "214472ca-989c-40f7-82ed-9b57efb4be8d", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "4f993486bc2a86fd31de6b0bd8319c407c15f08e6523f805abad38cf8fc53f95", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "b272cead-cccd-4b2a-a02d-4503b1471c0a", "node_type": "1", "metadata": {}, "hash": "700a65c618b876d90e2e06d5564ce83181f4184c3171f6750a57be6db444c56f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "A mixed integration \ntesting follows a combination of top down and bottom -up testing approaches. In top -down \napproach, testing can start only after the top -level module have been coded and unit tested. In \nbottom -up app roach, testing can start only after the bottom level modules are ready. This \nsandwich or mixed approach overcomes this shortcoming of the top -down and bottom -up \napproaches. A mixed integration testing is also called sandwiched integration testing.  \nAdvantag es: \n\uf0b7 Mixed approach is useful for very large projects having several sub projects.  \n\uf0b7 This Sandwich approach overcomes this shortcoming of the top -down and bottom -up \napproaches.  \nDisadvantages:  \n\uf0b7 For mixed integration testing, require very high cost because one p art has Top -down \napproach while another part has bottom -up approach.  \n\uf0b7 This integration testing cannot be used for smaller system with huge interdependence \nbetween different modules.  \nDEBUGGING  \nIt is a systematic process of spotting and fixing the number of b ugs, or defects, in a piece of \nsoftware so that the software is behaving as expected. Debugging is harder for complex systems \nin particular when various subsystems are tightly coupled as changes in one system or interface \nmay cause bugs to emerge in anothe r. \nDebugging is a developer activity and effective debugging is very important before testing \nbegins to increase the quality of the system. Debugging will not give confidence that the system \nmeets its requirements completely but testing gives confidence.  \n \n6 Explain software testing types? APR/MAY -16, NOV/DEC 2015  \nPress -Pg-no- 384 \n7 Write elaborately on unit testing and regression testing. How do you develop test \nsuites. APRIL/MAY -15, APRIL/MAY 2018  \nUnit testing, a testing technique using which individual mo dules are tested to determine if there \nare any issues by the developer himself. It is concerned with functional correctness of the \nstandalone modules.  \nThe main aim is to isolate each unit of the system to identify, analyze and fix the defects.  \nUnit Testing  - Advantages:  \n\uf0b7 Reduces Defects in the Newly developed features or reduces bugs when changing the \nexisting functionality.  \n\uf0b7 Reduces Cost of Testing as defects are captured in very early phase.  \n\uf0b7 Improves design and allows better refactoring of code.  \n\uf0b7 Unit Tests,  when integrated with build gives the quality of the build as well.  \n15\n1  \n Unit Testing LifeCyle:  \n \nUnit Testing Techniques:  \n\uf0b7 Black Box Testi ng - Using which the user interface, input and output are tested.  \n\uf0b7 White Box Testing - used to test each one of those functions behaviour is tested.  \n\uf0b7 Gray Box Testing - Used to execute tests, risks and assessment methods.  \nRegression testing a black box testi ng technique that consists of re -executing those tests that are \nimpacted by the code changes. These tests should be executed as often as possible throughout \nthe software development life cycle.  \nTypes of Regression Tests:  \n\uf0b7 Final Regression Tests: - A \"final regression testing\" is performed to validate the build \nthat hasn't changed for a period of time. This build is deployed or shipped to customers.  \n\uf0b7 Regression Tests: - A normal regression testing is performed to verify if the build has \nNOT broken any other pa rts of the application by the recent code changes for defect \nfixing or for enhancement.  \nSelecting Regression Tests:  \n\uf0b7 Requires knowledge about the system and how it affects by the existing functionalities.  \n15\n2  \n \uf0b7 Tests are selected based on the area of frequent def ects. \n\uf0b7 Tests are selected to include the area, which has undergone code changes many a times.  \n\uf0b7 Tests are selected based on the criticality of the features.  \nRegression Testing Steps:  \nRegression tests are the ideal cases of automation which results in better  Return  On Investment \n(ROI).  \n\uf0b7 Select the Tests for Regression.  \n\uf0b7 Choose the apt tool and automate the Regression Tests  \n\uf0b7 Verify applications with Checkpoints  \n\uf0b7 Manage Regression Tests/update when required  \n\uf0b7 Schedule the tests  \n\uf0b7 Integrate with the builds  \n\uf0b7 Analyze the res ults \n \n \n8 i.What is cyclomatic complexity? How to compute cyclomatic complexity \nAPRIL/MAY -15, NOV/DEC 2017  \nCyclomatic complexity is a source code complexity measurement that is being correlated to a \nnumber of coding errors. It is calculated by developing a  Control Flow Graph of the code that \nmeasures the number of linearly -independent paths through a program module.", "mimetype": "text/plain", "start_char_idx": 249593, "end_char_idx": 254102, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "b272cead-cccd-4b2a-a02d-4503b1471c0a": {"__data__": {"id_": "b272cead-cccd-4b2a-a02d-4503b1471c0a", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c966e427d085c9a2caab447d5675748baa63e5df757c38341635322d8571ab91", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8fd746b2-4f60-48bc-81c2-493d1162296e", "node_type": "1", "metadata": {}, "hash": "878584d299b1094bbb632c589b2f9ee52424e543a8a9c9a43f175ab748e6f376", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Tests are selected based on the criticality of the features.  \nRegression Testing Steps:  \nRegression tests are the ideal cases of automation which results in better  Return  On Investment \n(ROI).  \n\uf0b7 Select the Tests for Regression.  \n\uf0b7 Choose the apt tool and automate the Regression Tests  \n\uf0b7 Verify applications with Checkpoints  \n\uf0b7 Manage Regression Tests/update when required  \n\uf0b7 Schedule the tests  \n\uf0b7 Integrate with the builds  \n\uf0b7 Analyze the res ults \n \n \n8 i.What is cyclomatic complexity? How to compute cyclomatic complexity \nAPRIL/MAY -15, NOV/DEC 2017  \nCyclomatic complexity is a source code complexity measurement that is being correlated to a \nnumber of coding errors. It is calculated by developing a  Control Flow Graph of the code that \nmeasures the number of linearly -independent paths through a program module.  \nLower the Program's cyclomatic complexity, lower the risk to modify and easier to understand. \nIt can be represented using the below formula:  \nCyclomatic  complexity = E - N + 2*P  \nwhere , \n  E = number of edges in the flow graph . \n  N = number of nodes in the flow graph . \n  P = number of nodes that have exit points  \nExample :  \nIF A = 10 THEN  \n IF B > C THEN  \n   A = B \n ELSE  \n   A = C \n ENDIF  \nENDIF  \nPrint  A \nPrint B \nPrint  C \n15\n3  \n FlowGraph:  \n \nThe Cyclomatic complexity is calculated using the above control flow diagram that shows seven \nnodes(shapes) and eight edges (lines), hence the cyclomatic complexity is 8 - 7 + 2 = 3  \n \n9 Explain  integration  testing  in detail. MAY/JUN -13, APRIL/MAY \n2017, APRIL/MAY  2018  \nUpon completion of unit testing, the units or modules are to be integrated which give s raise to \nintegration testing. The purpose of integration testing is to verify the functional, performance, \nand reliability between the modules that are integrated.  \nIntegration Strategies:  \n15\n4  \n \uf0b7 Big-Bang Integration  \nBig Bang Integration Testing is an integratio n testing strategy wherein all units are linked at \nonce, resulting in a complete system. When this type of testing strategy is adopted, it is difficult \nto isolate any errors found, because attention is not paid to verifying the interfaces across \nindividual  units.  \nBig Bang Integration - WorkFlow Diagram  \nBig Bang Testing is represented by the following workflow diagram:  \n \nDisadvantage s of Big -Bang Testing  \n\uf0b7 Defects present at the interfaces of components are identified at very late stage as all \ncomponents are integrated in one shot.  \n\uf0b7 It is very difficult to isolate the defects found.  \n\uf0b7 There is high probability of missing some critical defe cts, which might pop up in the \nproduction environment.  \n\uf0b7 It is very difficult to cover all the cases for integration testing without missing even a \nsingle scenario.  \nTop Down Integration  \nTop-down integration testing is an integration testing technique used in  order to simulate the \nbehaviour of the lower -level modules that are not yet integrated. Stubs are the modules that act \nas temporary replacement for a called module and give the same output as that of the actual \nproduct.  \nThe replacement for the 'called' mo dules is known as 'Stubs' and is also used when the software \nneeds to interact with an external system.  \n15\n5  \n Stub - Flow Diagram:  \n \nThe above diag rams clearly states that Modules 1, 2 and 3 are available for integration, whereas, \nbelow modules are still under development that cannot be integrated at this point of time. Hence, \nStubs are used to test the modules. The order of Integration will be:  \n1,2 \n1,3 \n2,Stub 1 \n2,Stub 2 \n3,Stub 3 \n3,Stub 4 \nTesting Approach:  \n+ Firstly , the integration between the modules 1,2 and 3 \n+ Test the integration between the module  2 and stub 1,stub 2 \n+ Test the integration between the module  3 and stub 3,stub 4 \n \nBottom Up Integr ation  \nEach component at lower hierarchy is tested individually and then the components that rely upon \nthese components are tested.  \nBottom Up Integration - Flow Diagram  \n \nThe order of Integration by Bottom -down approach will be:  \n15\n6  \n 4,2 \n5,2 \n6,3 \n7,3 \n2,1 \n3,1 \nTesting Approach :  \n+ Firstly , Test 4,5,6,7 individually using  drivers .", "mimetype": "text/plain", "start_char_idx": 253267, "end_char_idx": 257447, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8fd746b2-4f60-48bc-81c2-493d1162296e": {"__data__": {"id_": "8fd746b2-4f60-48bc-81c2-493d1162296e", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "b272cead-cccd-4b2a-a02d-4503b1471c0a", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "efd32fcda506be99f2dd1fe661b25171ad71dac6119c0082c1e8c0788b334422", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8cfb2b9c-859b-4436-947d-7b1620d50f87", "node_type": "1", "metadata": {}, "hash": "28ddf2b3c8beaf5ff21cb472271b8b1a0354f16d7836752cbf63b66105403b05", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The order of Integration will be:  \n1,2 \n1,3 \n2,Stub 1 \n2,Stub 2 \n3,Stub 3 \n3,Stub 4 \nTesting Approach:  \n+ Firstly , the integration between the modules 1,2 and 3 \n+ Test the integration between the module  2 and stub 1,stub 2 \n+ Test the integration between the module  3 and stub 3,stub 4 \n \nBottom Up Integr ation  \nEach component at lower hierarchy is tested individually and then the components that rely upon \nthese components are tested.  \nBottom Up Integration - Flow Diagram  \n \nThe order of Integration by Bottom -down approach will be:  \n15\n6  \n 4,2 \n5,2 \n6,3 \n7,3 \n2,1 \n3,1 \nTesting Approach :  \n+ Firstly , Test 4,5,6,7 individually using  drivers . \n+ Test 2 such that it calls 4 and 5 separately . If an error o ccurs we know that the problem is in one \nof the modules . \n+ Test 1 such that it calls 3 and If an error occurs we know that the problem is in 3 or in  \nHybrid Integration  \nIntegration Testing is a phase in software testing in which standalone modules are comb ined and \ntested as a single entity. During that phase, the interface and the communication between each \none of those modules are tested. There are two popular approaches for Integration testing which \nis Top down Integration Testing and Bottom up Integratio n Testing.  \nIn Hybrid Integration Testing, we exploit the advantages of Top -down and Bottom -up \napproaches. As the name suggests, we make use of both the Integration techniques.  \n \nHybrid Integration Testing - Features  \n\uf0b7 It is viewed as three layers; viz - The Main Target Layer, a layer above the target layer \nand a layer below the target layer.  \n\uf0b7 Testing is mainly focussed for th e middle level target layer and is selected on the basis of \nsystem characteristics and the structure of the code.  \n\uf0b7 Hybrid Integration testing can be adopted if the customer wants to work on a working \nversion of the application as soon as possible aimed at p roducing a basic working \nsystem in the earlier stages of the development cycle.  \n \n \n10 What is black box testing? Explain the different types of black box testing \nstrategies with example? NOV/DEC 2016  \nBlack -box testing is a method of software testing that ex amines the functionality of an \napplication based on the specifications. It is also known as Specifications based testing. \nIndependent Testing Team usually performs this type of testing during the software testing life \n15\n7  \n cycle.  \nThis method of test can be appl ied to each and every level of software testing such as unit, \nintegration, system and acceptance testing.  \nBehavioural Testing Techniques:  \nThere are different techniques involved in Black Box testing.  \n\uf0b7 Equivalence Class  \nEquivalence Partitioning also called a s equivalence class partitioning. It is abbreviated as ECP. \nIt is a software testing technique that divides the input test data of the application under test into \neach partition at least once of equivalent data from which test cases can be derived.  \nAn adva ntage of this approach is it reduces the time required for performing testing of a \nsoftware due to less number of test cases.  \nExample:  \nThe Below example best describes the equivalence class Partitioning:  \nAssume  that the application accepts an integer in the range 100 to 999 \nValid  Equivalence  Class  partition : 100 to 999 inclusive . \nNon-valid Equivalence  Class  partitions : less than 100, more than 999, decimal  numbers and \nalphabets /non-numeric characters . \n \n\uf0b7 Boundary Value Analysis  \nBoundary value analysis is a ty pe of black box or specification based testing technique in which \ntests are performed using the boundary values.  \nExample:  \nAn exam has a pass boundary at 50 percent, merit at 75 percent and distinction at 85 percent. \nThe Valid Boundary values for this scena rio will be as follows:  \n49, 50 - for pass \n74, 75 - for merit  \n84, 85 - for distinction  \nBoundary values are validated against both the valid boundaries and invalid boundaries.  \nThe Invalid Boundary Cases for the above example can be given as follows:  \n0 - for lower limit boundary value  \n101 - for upper limit boundary value  \n \n\uf0b7 Domain Tests  \nDomain testing is a software testing technique in which selecting a small number of test cases \nfrom a nearly infinite group of test cases. For testing few applications, Domain sp ecific \nknowledge plays a very crucial role.", "mimetype": "text/plain", "start_char_idx": 256784, "end_char_idx": 261137, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8cfb2b9c-859b-4436-947d-7b1620d50f87": {"__data__": {"id_": "8cfb2b9c-859b-4436-947d-7b1620d50f87", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8fd746b2-4f60-48bc-81c2-493d1162296e", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "83f1d8353dfd3c7ecbe70e1fcd2191e0cab2ebbe569e4d1f7e7c87ad42f59ebc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3260bd06-1d45-4647-b57d-4eba192c5dce", "node_type": "1", "metadata": {}, "hash": "695819f25c3983ebad54caa4746424ce07ac4b63eb4ad827c8452beceb3bccf6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "\uf0b7 Boundary Value Analysis  \nBoundary value analysis is a ty pe of black box or specification based testing technique in which \ntests are performed using the boundary values.  \nExample:  \nAn exam has a pass boundary at 50 percent, merit at 75 percent and distinction at 85 percent. \nThe Valid Boundary values for this scena rio will be as follows:  \n49, 50 - for pass \n74, 75 - for merit  \n84, 85 - for distinction  \nBoundary values are validated against both the valid boundaries and invalid boundaries.  \nThe Invalid Boundary Cases for the above example can be given as follows:  \n0 - for lower limit boundary value  \n101 - for upper limit boundary value  \n \n\uf0b7 Domain Tests  \nDomain testing is a software testing technique in which selecting a small number of test cases \nfrom a nearly infinite group of test cases. For testing few applications, Domain sp ecific \nknowledge plays a very crucial role.  \nDomain testing is a type of functional testing and tests the application by feeding interesting \n15\n8  \n inputs and evaluating its outputs.  \nDomain - Equivalence Class Testing  \nEquivalence class carries its own significance  when performing domain testing. Different ways \nof equivalence class are:  \n\uf0d8 Intuitive equivalence  \n\uf0d8 Specified equivalence  \n\uf0d8 Subjective equivalence  \n\uf0d8 Risk-based equivalence:  \n \n \n\uf0b7 Orthogonal Arrays  \nOrthogonal array testing is a systematic and statistical way of a black  box testing technique used \nwhen number of inputs to the application under test is small but too complex for an exhaustive \ntesting.  \nOrthogonal Array Testing Characteristics:  \n\uf0b7 OAT, is a systematic and statistical approach to pairwise interactions.  \n\uf0b7 Executing a well -defined and a precise test is likely to uncover most of the defects.  \n\uf0b7 100% Orthogonal Array Testing implies 100% pairwise testing.  \nExample:  \nIf we have 3 parameters , each can have 3 values then the possible Number  of tests using  \nconventional method is 3^3 = 27 \nWhile  the same using  OAT , it boils down to 9 test cases . \n \n\uf0b7 Decision Tables  \n \n\uf0b7 State Models  \n\uf0b7 Exploratory Testing  \n\uf0b7 All-pairs testing  \n \n15\n9  \n 11 1. (a) Consider the pseudo code for simple subtraction given below: \nNOV/DEC 2016, APRIL/MAY  2018  \n(1) program \u2018simple  subtr action\u2019  \n(2) input  (x,y)  \n(3) output  (x) \n(4) output  (y) \n(5) if x> y then  DO \n(6) x-y = z  \n(7) else y \u2013x = z \n(8) endif  \n(9) output  (z) \n(10) output \u201cend program\u201d  \nPerform basis path testing and generate test cases.  \n(b) What is refactoring? When is it needed? Explain with ex?  \nRefer class notes.  \n12 Explain in detail about system testing  \nSystem Testing is the testing of a complete and fully integrated software product. Usually, \nsoftware is only one element of a larger computer -based system. Ultimately, software is \ninterfaced with other software/hardware  systems. System Testing is actually a series of different \ntests whose sole purpose is to exercise the full computer -based system.  \nTwo Category of Software Testing  \n\uf0b7 Black Box Testing  \n\uf0b7 White Box Testing  \nSystem test falls under the  black box testing  category o f software testing.  \nWhite box testing  is the testing of the internal workings or code of a software application. In \ncontrast, black box or System Testing is the opposite. System test involves the external workings \nof the software from the user's perspectiv e. \n \n  \n13 Explain about the software testing strategies  \nSoftware testing  is an investigation conducted to provide stakeholders with information about \nthe quality  of the  software  product or service under test.[1] Software testing can also provide an \n16\n0  \n objective, independe nt view of the software to allow the business to appreciate and understand \nthe risks of software implementation. Test techniques include the process of executing a program \nor application with the intent of finding  software bugs  (errors or other defects), and verifying that \nthe software product is fit for use.  \nSoftware testing involves the execution of a software component or system component to \nevaluate one or more properties of in terest.", "mimetype": "text/plain", "start_char_idx": 260236, "end_char_idx": 264340, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3260bd06-1d45-4647-b57d-4eba192c5dce": {"__data__": {"id_": "3260bd06-1d45-4647-b57d-4eba192c5dce", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8cfb2b9c-859b-4436-947d-7b1620d50f87", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "c11299f4a45f5c7c8ed529211e3b84ff301c5c5e11297e7a3ad1280a1bfd9c59", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "20fc74ca-3f29-4f9a-856c-72f9009a628b", "node_type": "1", "metadata": {}, "hash": "21761043407f21c3c9a625bff27ff2e4aad6bbe20d862311996c1ac31b7be1c9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "White box testing  is the testing of the internal workings or code of a software application. In \ncontrast, black box or System Testing is the opposite. System test involves the external workings \nof the software from the user's perspectiv e. \n \n  \n13 Explain about the software testing strategies  \nSoftware testing  is an investigation conducted to provide stakeholders with information about \nthe quality  of the  software  product or service under test.[1] Software testing can also provide an \n16\n0  \n objective, independe nt view of the software to allow the business to appreciate and understand \nthe risks of software implementation. Test techniques include the process of executing a program \nor application with the intent of finding  software bugs  (errors or other defects), and verifying that \nthe software product is fit for use.  \nSoftware testing involves the execution of a software component or system component to \nevaluate one or more properties of in terest. In general, these properties indicate the extent to \nwhich the component or system under test:  \n\uf0b7 meets the requirements that guided its design and development,  \n\uf0b7 responds correctly to all kinds of inputs,  \n\uf0b7 performs its functions within an acceptable time , \n\uf0b7 it is sufficiently usable,  \n\uf0b7 can be installed and run in its intended  environments , and  \n\uf0b7 achieves the general result its stakeholders desire.  \nAs the number of pos sible tests for even simple software components is practically infinite, all \nsoftware testing uses some strategy to select tests that are feasible for the available time and \nresources. As a result, software testing typically (but not exclusively) attempts to execute a \nprogram or application with the intent of finding  software bugs  (errors or other defects). The job \nof testing is an iterative process as when one bug is fixed, it can  illuminate other, deeper bugs, or \ncan even create new ones.  \nSoftware testing can provide objective, independent information about the quality of software and \nrisk of its failure to users or sponsors.[1] \nSoftware testing can be conducted as soon as executable software (even if partially complete) \nexists. The  overal l approach to software development  often determines when and how testing is \nconducted. For example, in a phased process, most testing occurs after system requirements have \nbeen defined and then implemented in testable programs. In contrast, under an  agile approach , \nrequirements, programming, and testing are often done concurrently.  \n \n14 Discuss in detail about test strategies for conventional \nsoftware(M ay/June 2011)  \nRefer class notes  \n15 Explain in detail about basic path testing.(May/Jun 2014)  \nPath Testing is a structural testing method based on the source code or algorithm and NOT based \non the specifications. It can be applied at different levels of gr anularity.  \nPath Testing Assumptions:  \n\uf0b7 The Specifications are Accurate  \n\uf0b7 The Data is defined and accessed properly  \n\uf0b7 There are no defects that exist in the system other than those that affect control flow  \nPath Testing Techniques:  \n\uf0b7 Control Flow Graph (CFG) - The P rogram is converted into Flow graphs by \nrepresenting the code into nodes, regions and edges.  \n\uf0b7 Decision to Decision path (D -D) - The CFG can be broken into various Decision to \nDecision paths and then collapsed into individual nodes.  \n16\n1  \n \uf0b7 Independent (basis) paths  - Independent path is a path through a DD -path graph which \ncannot be reproduced from other paths by other methods.  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nUNIT \u2013 5 \nPART \u2013A \n \n \nS.NO  QUESTIONS  \n1 What are the processes of risk management ? NOV/DEC -10, NOV/DEC - 12,\n NOV/DEC  2013,NOV/DEC2015  \nRisk identification  \nRisk projection (estimation)  \nRisk mitigation, monitoring, and management  \n2 State the need for software configuration review. NOV/DEC -11 \nThe intent  of the review is to ensure that all elements of the software \nconfiguration  \nhave been properly developed, cataloged & have necessary detail to bolster \nthe \nsupportpfase of the software lifecycle.  \n16\n2  \n 3 List any five CASE tools classified by function in the tax onomy of CASE tools \nNOV/DEC -11 \n1. project planning  tools  \n2. metrics & management  tools  \n 3. prototyping  tools  \n4. Re- engineering  tools  \n5. documentation  tools.  \n4 Define error, fault and failure. NOV/DEC -10 \nError \u2013 it is a state that can lead to a system behavior that is unexpected by \nthe \nSystem user.  \nFault - it is a characteristic of a software system that can lead to system error.", "mimetype": "text/plain", "start_char_idx": 263361, "end_char_idx": 267937, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "20fc74ca-3f29-4f9a-856c-72f9009a628b": {"__data__": {"id_": "20fc74ca-3f29-4f9a-856c-72f9009a628b", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3260bd06-1d45-4647-b57d-4eba192c5dce", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "e1f209c684b25796bbd2b899490499676673fa27c263cb26c2033a1675828cbc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "bf63c7a4-df67-4efe-b646-b868485d22e9", "node_type": "1", "metadata": {}, "hash": "43472dd9c3898ab17a8d0832d229431616fb02295710027cb41adf47379179dd", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "NOV/DEC -11 \nThe intent  of the review is to ensure that all elements of the software \nconfiguration  \nhave been properly developed, cataloged & have necessary detail to bolster \nthe \nsupportpfase of the software lifecycle.  \n16\n2  \n 3 List any five CASE tools classified by function in the tax onomy of CASE tools \nNOV/DEC -11 \n1. project planning  tools  \n2. metrics & management  tools  \n 3. prototyping  tools  \n4. Re- engineering  tools  \n5. documentation  tools.  \n4 Define error, fault and failure. NOV/DEC -10 \nError \u2013 it is a state that can lead to a system behavior that is unexpected by \nthe \nSystem user.  \nFault - it is a characteristic of a software system that can lead to system error.  \nFailure \u2013 it is an event that occurs at some point in time when the system \ndoes not  \nDeliver a service as per user\u2019s expectation.  \n5 What is pro ject planning? APR/MAY -12, APR/MAY -15 \nThe various types of plan is developed to support main software project plan \nwhich is concerned with schedule & budget. Types of project plan  \nQuality plan, Validation plan, Configuration mgmt plan, Maintenance  \nplan, St aff development plan.  \n6 List the various types of software errors? APR/MAY -11, NOV/DEC -12 \nReports detailing bugs in a program are commonly known as bug reports, \ndefect reports, fault reports, problem reports, trouble reports, change requests.  \n16\n3  \n 7 Different iate between  size oriented  and function  oriented  metrics? \nMAY/JUN -13 MAY/JUNE 2016,NOV/DEC  2015  \nSize oriented metrics \u2013 it considers the size of the software that has been \nproduced. The software organization maintains simple records in tabular form. \nTable entries are LOC, effort, defects, and project name. Function oriented \nmetrics \u2013 it measures the functionality delivered by software. Function point \nbased on software information domain  and \nComplexity.  \n8 Define measure.(APRIL/MAY -2008)  \n Measure is defined  as a quantitative indication of the extent,  \namount, dimension, or size of some attribute of a product or process.  \n9 How is productivity and cost related to function points?  NOV/DEC2016  \n \nSoftware Productivity = Function Points / Inputs (persons/mnth) Cost  = $ / \nFunction Points (FP)  \n10 What are the types of metrics? MAY/JUNE 2016  \nDirect metrics \u2013 It refers to immediately measurable attributes. Example  \n\u2013 Lines of code,execution speed.  \nIndirect metrics \u2013 It refers to the aspects that are not immediately quan tifiable or \nmeasurable.  \nExample \u2013 functionality of a program.  \n16\n4  \n 11 What are the advantages and disadvantages of size measure? Advantages:  \n\uf0b7 Artifact of software development which is easily counted.  \n\uf0b7 Many existing methods use LOC as a key  input.  \n\uf0b7 A large body of  literature and data based on LOC already  exists  \nDisadvantages:  \nThis method is dependent upon the programming language.  \n\uf0a7 This method is well designed but shorter program may get  suffered.  \n\uf0a7 It does not accommodate non procedural  languages.  \n\uf0a7 In early stage of d evelopment it is difficult to estimate LOC.  \n12 Write short note on the various estimation techniques.  \nAlgorithmic cost modeling \u2013 the cost estimation is based on the size of the \nsoftware.  \nExpert judgement  \u2013 The experts  from software  development  \nand  the   application domain  use  their  exoerience  to  predict  software  \n costs.  \nEstimation by analogy \u2013 The cost of a project is computed by comparing \nthe project to a similar project in the same application domain and then cost can be \ncomputed.  \nParkinson\u2019s law \u2013 The cost is determined by available resources rather \nthan by objective assessment.  \nPricing to win \u2013 The project costs whatever the customer ready to  \nspend it.  \n13 What is COCOMO model?  \nCOnstructiveCOstMOdel is a cost model, which gives the estimate of number of \nman- months it will take to develop the software product.  \n16\n5  \n 14 Give the procedure of the Delphi method.  \n1. The co -ordinator presents a specification and estimation form to each  expert.  \n2. Co-ordinator calls a group meeting in which the experts discuss e stimation \nissues with the coordinator and each  other.  \n3. Experts fill out forms  anonymously.  \n4. Co-ordinator prepares and distributes a summary of the estimates.  \n5.", "mimetype": "text/plain", "start_char_idx": 267236, "end_char_idx": 271488, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "bf63c7a4-df67-4efe-b646-b868485d22e9": {"__data__": {"id_": "bf63c7a4-df67-4efe-b646-b868485d22e9", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "20fc74ca-3f29-4f9a-856c-72f9009a628b", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ed7460a1470b3dd0b4f73fce5b21ded18ea69c758c58f773395b27402982c804", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "791b77f1-2ca2-486c-bd66-71802f54fc54", "node_type": "1", "metadata": {}, "hash": "dcdb6e5a34cb5906309ec0c8a1cc30c307c88620f51ba1305a811c3a56e84e4e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Parkinson\u2019s law \u2013 The cost is determined by available resources rather \nthan by objective assessment.  \nPricing to win \u2013 The project costs whatever the customer ready to  \nspend it.  \n13 What is COCOMO model?  \nCOnstructiveCOstMOdel is a cost model, which gives the estimate of number of \nman- months it will take to develop the software product.  \n16\n5  \n 14 Give the procedure of the Delphi method.  \n1. The co -ordinator presents a specification and estimation form to each  expert.  \n2. Co-ordinator calls a group meeting in which the experts discuss e stimation \nissues with the coordinator and each  other.  \n3. Experts fill out forms  anonymously.  \n4. Co-ordinator prepares and distributes a summary of the estimates.  \n5. The Co -ordinator then calls a group meeting.In this meeting the experts mainly \ndiscuss the points wh ere their estimates vary  widely.  \n6. The experts again fill out forms  anonymously.  \n7. Again co -ordinator edits and summarizes the forms,repeating steps5 and  6 until \nthe co-ordinator  is satisfied  with the overallprediction  synthesized  \nfrom experts.  \n15 What are th e metrics computed during error tracking activity?  \nErrors per requirement specification page. Errors per \ncomponent -design level  \nErrors per component -code level DRE -\nrequirement analysis  \nDRE -architectural analysis  \nDRE -component level design  \n DRE -coding.  \n16 What is risk management? NOV/DEC2016  \nRisk   management is   the   identification,   assessment,   and   prioritization of risks \nfollowed by coordinated and economical application of resources to minimize,  monitor, \nand control the probability and/or impact of unfortunate eventsor to maximize the \nrealization of opportunities. Risk management\u2019s objective is to assure uncertainty does \nnot deflect the en deavor from  the \nbusiness goals.  \n17 What is software maintenance?  \nSoftware maintenance is an activity in which program is modified after it has been put \ninto use.  \n16\n6  \n 18 Will exhaustive testing guarantee that the program is 100% correct? APR/MAY \n2016  \nNo,    e ven    exhaustive    testing    will    not    guarantee     that     the program    is    \n100   percent    correct.    There    are    too    many variables to consider.  \n19 What are the types of software maintenance?  \n\uf0b7 Corrective maintenance \u2013 Means the ma intenance for correcting the \nsoftware  faults.  \n\uf0b7 Adaptive maintenance \u2013 Means maintenance for adapting the change in \nenvironment.  \n\uf0b7 Perfective maintenance \u2013 Means modifying or enhancing the system to \nmeet the new  requirements.  \n\uf0b7 Preventive maintenance \u2013 Means cha nges made to  improve  \nfuture maintainability  \n20 How the CASE tools are classified?  \nCASE tools can be classified  by \na. By function or  use \nb. By user type(e.g.  manager,tester),or  \nc. By stage in software engineering process  (e.g.requirements,test).  \n21 Dinguish betwee n direct & indirect measures of metrics.  \nDirect metrics is directly measurable attribute(lines of code execution speed,size \nof memory.  \nIndirect metrics: these are the aspects that are not immediately  \nmeasurable.(functionality,reliabblity,maintainability)  \n22 List down few process and product metrics.  MAY/JUNE 2016  \n1. size metrics -It is used for measuring the size of the software.(local based \nmetric,FP based  metric)  \n2. complexity metric - A software module can be described by a control flow \ngraph.(cyclomatic comple xity, McCabe  complexity)  \n3. quality metric - (Defects,reliabilitymetric,Maintainability)  \n16\n7  \n 23 Define software measure.  \nIt is a numeric value for a attribute of a software product or process.  \nTypes:  \n1.Direct measure 2.indirect measure  \n24 List out the different approaches to size of the software . \n1. LOC -computing the line of code  \n2. FP-computing function point of the  program.  \n25 An organic software occupies 15000 LOC.how many programmers are needed to \ncomplete?(NOV/DEC -12) \nSystem=organic Lines of \ncoding=15k LOC  \nE=a b(KLOC)b b \n=2.4(15)1.05 \n=41 persons per month D=c b(e)d b \n=2.5(41)0.38 \n=10 months P=41/10  \nP=4 persons.  \n 4 persons are needed.  \n26 What is error tracking?", "mimetype": "text/plain", "start_char_idx": 270758, "end_char_idx": 274899, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "791b77f1-2ca2-486c-bd66-71802f54fc54": {"__data__": {"id_": "791b77f1-2ca2-486c-bd66-71802f54fc54", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "bf63c7a4-df67-4efe-b646-b868485d22e9", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ffac73dcedf8f8ee1c16569921dea0662ddfdce45dacc642e155d5d96de30c34", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "d575640e-ff6e-4f34-837d-306d6513c110", "node_type": "1", "metadata": {}, "hash": "fc017da5e0d10280ebccee61d932999288ca45d66a287bffe3935bcf3da93934", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is a numeric value for a attribute of a software product or process.  \nTypes:  \n1.Direct measure 2.indirect measure  \n24 List out the different approaches to size of the software . \n1. LOC -computing the line of code  \n2. FP-computing function point of the  program.  \n25 An organic software occupies 15000 LOC.how many programmers are needed to \ncomplete?(NOV/DEC -12) \nSystem=organic Lines of \ncoding=15k LOC  \nE=a b(KLOC)b b \n=2.4(15)1.05 \n=41 persons per month D=c b(e)d b \n=2.5(41)0.38 \n=10 months P=41/10  \nP=4 persons.  \n 4 persons are needed.  \n26 What is error tracking?(APRIL/MAY -14) \nIt is a process of finding out and correcting the errors that may occur \nduring the software d evelopment process at various stages such as software design,coding \nor documenting.  \n16\n8  \n 27 What are the types of static testing tools?  \nThere are three types of static testing tools.  \n\uf0b7 Code based testing tools \u2013 These tools take source code as input and generate  test \ncases.  \n\uf0b7 Specialized testing tools \u2013 Using this language the detailed test specification can \nbe written for each test  case.  \n\uf0b7 Requirement -based testing tools \u2013 These tools help in designing the test cases as \nper user \nrequirements.  \n28 What are the produc tivity measures and list its type. APRIL/MAY 2017  \nProductivity is an overall measure of the ability to produce a good or service. \nMore specifically, productivity is the measure of how specified resources are managed to \naccomplish timely objectives as state d in terms of quantity and quality. Productivity may \nalso be defined as an index that measures output (goods and services) relative to the input \n(labor, materials, energy, etc., used to produce the output). there are two major ways to \nincrease productivity : increase the numerator (output) or decrease the denominator  \n(input).  \n29 Define ZIPF\u2019s law.  \nThe probability of occurrence of words or other items starts high and tapers off. \nThus, a few occur very often while many others occur rarely. Formal  Definition:  Pn ~ \n1/na,  where  Pn is the frequency  of occurrence  of the \nnth ranked item and a is close to 1.  \n30 List out the principles of project scheduling. NOV/DEC2017  \n \nSoftware project scheduling is an activity that distributes estimated effort  \n16\n9  \n  across the planed project duration by allocating the effort to specific software engineering \ntasks.  \n \nFirst, a macroscopic schedule is developed. a detailed schedule is redefined for each entry \nin the macroscopic schedule.  \n \nA schedule evolves over time.  \n \nBasic principles gui de software project scheduling:  \n \n- Compartmentalization  \n \n- Interdependency  \n \n- Time  allocation  \n \n- Effort  allocation  \n \n- Effort  validation  \n \n- Defined  responsibilities  \n \n- Defined  outcomes  \n \n- Defined  milestones  \n31 Write a note on Risk information sheet. NOV/DEC 2017  \n \nA risk i nformation sheet is a means of capturing information about a risk. Risk \ninformation sheets are used to document new risks as they are identified. They are also \nused to modify information as risks are managed. It is a form that can be submitted to the \nappro priate person or included in a database with other project risks. In the absence of a \ndatabase, this becomes a primary means of  \ndocumenting and retaining information about a risk.  \n32 List two customer related and technology related risks. APRIL/MAY 2017  \n17\n0  \n  customer related risks  \n \n\uf0b7 Customer relationship management may be  fragmented.  \n\uf0b7 New methods with which to improve customer service and reduce  related costs are \nnot utilized.  \n\uf0b7 Lack of knowledge on the part of one section of an enterprise  regarding \ninteractions with a customer on the part of another can lead to customer frustration \nand embarrassment.  \n\uf0b7 Inability to respond to market demands caused by lack of integration  among order -\nentry systems or, even worse, due to  infrastructure.  \n\uf0b7 Lack of visibility of the order  status along the whole supply  chain.  \n \nTechnology related risk :  \n \n\uf0b7 Architecture risk \n\uf0b7 Artificial intelligence  risk \n\uf0b7 Audit  risk \n\uf0b7 Availability  \n33 What is EVA ?", "mimetype": "text/plain", "start_char_idx": 274317, "end_char_idx": 278439, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d575640e-ff6e-4f34-837d-306d6513c110": {"__data__": {"id_": "d575640e-ff6e-4f34-837d-306d6513c110", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "791b77f1-2ca2-486c-bd66-71802f54fc54", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "30b02c904d596e47abe590a12cb8f31da325de8874d8b3006cde793dd657c7d3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9e195c5d-fe0e-46fe-90e8-20296a8a6060", "node_type": "1", "metadata": {}, "hash": "ad0b5e51b7924fc24ce411de98ef5a233bbc911ef7e52e2352f213b72a8bd561", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "32 List two customer related and technology related risks. APRIL/MAY 2017  \n17\n0  \n  customer related risks  \n \n\uf0b7 Customer relationship management may be  fragmented.  \n\uf0b7 New methods with which to improve customer service and reduce  related costs are \nnot utilized.  \n\uf0b7 Lack of knowledge on the part of one section of an enterprise  regarding \ninteractions with a customer on the part of another can lead to customer frustration \nand embarrassment.  \n\uf0b7 Inability to respond to market demands caused by lack of integration  among order -\nentry systems or, even worse, due to  infrastructure.  \n\uf0b7 Lack of visibility of the order  status along the whole supply  chain.  \n \nTechnology related risk :  \n \n\uf0b7 Architecture risk \n\uf0b7 Artificial intelligence  risk \n\uf0b7 Audit  risk \n\uf0b7 Availability  \n33 What is EVA ? APRIL/MAY 2018  \n \nEarned Value Analysis ( EVA ) is an industry standard method of measuring a project's \nprogress at any given point in time, forecasting its completion date and final cost, and \nanalyzing variances in the schedule  \nand budget as the project proceeds.  \n34 Identify The Types Of Maintenance for each of the following APRIL/MAY  2018  \n \nCorrecting the So ftware Faults . Adapting the \nchange in environment  \nThere are four types of maintenance , namely, corrective , adaptive, perfective, and \npreventive . ... \nCorrectivemaintenance dealswiththe repair of faults or defects found in day -today \nsystem functions. ...  \nIn the event of a system failure due to an error, actions are taken to restore the \noperation of the software  system.  \n17\n1  \n 35 \nWhat is cost schedule?  \n \nCost schedule shows the planned cumulative expenditure cost by the use of resource \novertime  \n36 \nWhat is RMMM?  \nAns. RMMM stands for Risk Mitigation, Monitoring and Management Plan. It is also \ncalled Risk Aversion.  \n37 \nWhat Is Risk mitigation?  \nAns. Mitigation is a possible means if minimizing or even avoiding the Impact of risk.  \n38 \nWhat are the factors that lead to Ri sk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n39 \nWhat are the test points?  \n \nTest points allow data to be inspected or modified at various points in the system  \n40 \nWhat is refactoring?  \n \nA small chang e to a database schema which improves its design  \n41 \nExplain the common risk tools and techniques.  \n \nAns. There are at least six different ways of identifying the potential risks.  \nThese are:  \n17\n2  \n  \n\u2022 Examining organizational  history  \n \n\u2022 Preparing  checklists  \n \n\u2022 Informat ion buying  \n \n\u2022 Framework based risk  categorization  \n \n\u2022 Simulation  \n \n\u2022 Decision  trees.  \n42 \nWhat is called support risk?  \nAns. Support risk is the degree of uncertainty fiat the resultant software will be easy to \ncorrect, adapt and enhance  \n43 \nWhat Is Risk?  \n \nAns. Risks are events that are usually beyond the planner\u2019s control.  \n44 \nWhat are the Dimensions of Risk quantification? Ans. \nProbability and the impact of Risk.  \n45 \nWhat is meant by Delphi method?  \nThe Delphi technique is an estimation technique intended to active a common agreement \nfor estimation efforts.  \n46 \nWhat is meant by CASE tools?  \n \nThe computer aided software engineering tools automatic the project  \n17\n3  \n  management activities, manage all the work products. The CASE tools assist to \nperform various activities such  as analysis, design, coding and  \ntesting.  \n47 \nWhat are the three phases of Risk management? Ans. The \nthree phases of risk management are:  \nRisk identification, Risk Quantification, and Risk mitigation.  \n48 \nWhat are the factors that lead to Risk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n49 \nWhat is meant by software project scheduling?  \nSoftware project scheduling is an activity that distributes estimated effort across the \nplanned project duration by al locating the effort to specified software engineering \ntasks.  \n50 \nWhat are the various steps under risk analysis? Ans. The \nvarious steps under risk analysis are:  \n\uf0b7 Risk Estimation.  \n \n\uf0b7 Risk identification.  \n \n\uf0b7 Risk evaluation.  \n17\n4  \n   \n \nPART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 (f) Elaborate on the series of tasks of a software configuration management  \nprocess.", "mimetype": "text/plain", "start_char_idx": 277636, "end_char_idx": 281932, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9e195c5d-fe0e-46fe-90e8-20296a8a6060": {"__data__": {"id_": "9e195c5d-fe0e-46fe-90e8-20296a8a6060", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "d575640e-ff6e-4f34-837d-306d6513c110", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "3ec7c912bda7dacb6b90a101fa7316df83e230eedeaa79fda62759ace6deadda", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9b851148-f6e6-457d-99ef-c6b72f9d5dbf", "node_type": "1", "metadata": {}, "hash": "7abc39c705e4738930bbbc12227b71fa25ee96ca84a8125f075b08b1f59bb096", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The \nthree phases of risk management are:  \nRisk identification, Risk Quantification, and Risk mitigation.  \n48 \nWhat are the factors that lead to Risk? Ans. The \nfactors that lead to Risk are:  \n\uf0b7 Estimation  errors.  \n \n\uf0b7 Planning  assumptions.  \n \n\uf0b7 Business  risks.  \n49 \nWhat is meant by software project scheduling?  \nSoftware project scheduling is an activity that distributes estimated effort across the \nplanned project duration by al locating the effort to specified software engineering \ntasks.  \n50 \nWhat are the various steps under risk analysis? Ans. The \nvarious steps under risk analysis are:  \n\uf0b7 Risk Estimation.  \n \n\uf0b7 Risk identification.  \n \n\uf0b7 Risk evaluation.  \n17\n4  \n   \n \nPART \u2013B \n \n \n \n \nS.NO  QUESTIONS  \n1 (f) Elaborate on the series of tasks of a software configuration management  \nprocess.  \n(g) Describe  function  point  analysis  with  a neat \nexample NOV/DEC 2013  \nSoftware configuration management, SCM is an activity which is used at every level and \nevery part of the process of software Engineering. Every improvement takes the shape of \nbetter control. This is a discipline which controls betters and according to client need in \nsoftware Engineering. With the help of this many types are changes which play an important \nrole in sof tware Engineering and development process.  \nIn the simple way if we define the term configuration of management, this is the tool which \nmakes better control, easy maintenance during the whole process of software development. \nWith the help of software config uration management we can easily find out what \nmodification and controlling required by the developer. SCM have the capacity to control all \nthose effects which comes in software projects. The main objectives of SCM is increase the \nproduction by reduce the errors.  \nWhen a software development process start then SCM take change by identification, control, \nalteration, audit and etc. after that the output of total process provided to our customer. We \ncan clarify the action of SCM as:  \n1. Software configuration ident ification  - Normally software is used in various kinds \nof programs and documentation and data related to each program is called \nconfiguration identification. With the help of C.I we can make a guide line which \nwill be helpful in software development proces s, several time the requirement of \nguideline for check the document and design of software. Document related to SCM \nare the useful item, with the help of this we can make better control and take a basic \nunit for configuration.  \n2. Software configuration contro l - This is the process of deciding with the help of \nthis we make coordination between the changes which is necessary and apply them \nas per mentioned in guideline. Configuration control board gives the permission for \nany kind of change or modification whic h is necessary for the project. Many times \nCCB take advice of those members which are the part of software development \nprocess.  \n3. Accounting status of Software configuration  - The process of maintaining record \nof all data which is necessary for the software is called accounting status of \nsoftware. It has all the data related to the old software to new software that what \nchanges are done or required for the fulfillment of the customer need.  \n17\n5  \n 4. Auditing of software configuration  - Auditing of software configuratio n is may be \ndefined as an art with the help of this we can understand that the required actions or \nchanges are done by the developer or not. Some of the item involved in the process \nof verifying or auditing.  \no Function is properly performed by the software.  \no The process of documentation, data is completed or not.  \nBenefits  \no With the help of SCM we can easily control all changes which are done in \ndevelopment process.  \no It gives the surety to check that changes are done on required area.  \no It is helpful to generate th e new software with old components.  \no SCM has the capacity to explain everything about the process of software \ndevelopment.  \n \n2 Explain make/buy decision & discuss Putnam resource allocation model & \nderive time & effort equation? APRIL/MAY2016  \nThe Lawrence Pu tnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n6  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution.", "mimetype": "text/plain", "start_char_idx": 281114, "end_char_idx": 285641, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9b851148-f6e6-457d-99ef-c6b72f9d5dbf": {"__data__": {"id_": "9b851148-f6e6-457d-99ef-c6b72f9d5dbf", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9e195c5d-fe0e-46fe-90e8-20296a8a6060", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "8901444bd52f702b303800a4693ba434172c1c15afdbb32115f0f3bcd40cd4ee", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "a8425034-f811-4497-97b0-743a9adde769", "node_type": "1", "metadata": {}, "hash": "b6714ccbf2e2f415a72745c559038e5d382be6fe01bb3f063cdae32abb71c57e", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "o The process of documentation, data is completed or not.  \nBenefits  \no With the help of SCM we can easily control all changes which are done in \ndevelopment process.  \no It gives the surety to check that changes are done on required area.  \no It is helpful to generate th e new software with old components.  \no SCM has the capacity to explain everything about the process of software \ndevelopment.  \n \n2 Explain make/buy decision & discuss Putnam resource allocation model & \nderive time & effort equation? APRIL/MAY2016  \nThe Lawrence Pu tnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n6  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution. \nPutnam used his observation about productivi ty levels to derive the software equation:  \n \nThe various terms of this expression are as follows:  \nThe Lawrence Putnam model describes the time and effort requires finishing a software \nproject of a specified size. Putnam makes a use of a so -called The Norden/Rayleigh Curve to \nestimate project effort, schedule & defect rate as shown in fig:  \n17\n7  \n \n \nPutnam noticed that software staffing profiles followed the well known Rayleigh distribution. \nPutnam used his observation about producti vity levels to derive the software equation:  \n \nThe various terms of this expression are as follows:  \nK is the to tal effort expended (in PM) in product development, and L is the product estimate \nin KLOC  . \ntd correlate to the time of system and integration testing. Therefore,  td can be relatively \nconsidered as the time required for developing the product.  \nCk Is the st ate of technology constant and reflects requirements that impede the development \nof the program.  \nTypical values of  Ck = 2 for poor development environment  \n17\n8  \n Ck= 8 for good software development environment  \nCk = 11 for an excellent environment (in addition to following software engineering \nprinciples, automated tools and techniques are used).  \nThe exact value of  Ck for a specific task can be computed from the historical data of the \norganization developing it.  \nPutnam proposed that optimal staff develop on a proje ct should follow the Rayleigh curve. \nOnly a small number of engineers are required at the beginning of a plan to carry out planning \nand specification tasks. As the project progresses and more detailed work are necessary, the \nnumber of engineers reaches a p eak. After implementation and unit testing, the number of \nproject staff falls.  \nEffect of a Schedule change on Cost  \nPutnam derived the following expression:  \n \nWhere,  K is the total effort expended (in PM) in the product development  \nL is the product size in KLOC  \ntd corresponds to the time of system and integration testing  \nCk Is the state of technology constant and re flects constraints that impede the progress of the \nprogram  \nNow by using the above expression, it is obtained that,  \n \nFor the same product size, C =L3 / C k3 is a constant.  \n \n(As project development effort is equally proport ional to project development cost)  \nFrom the above expression, it can be easily observed that when the schedule of a project is \n17\n9  \n compressed, the required development effort as well as project development cost increases in \nproportion to the fourth power of th e degree of compression. It means that a relatively small \ncompression in delivery schedule can result in a substantial penalty of human effort as well as \ndevelopment cost.  \nFor example,  if the estimated development time is 1 year, then to develop the produc t in 6 \nmonths, the total effort required to develop the product (and hence the project cost) increases \n16 times.  \n \n \n3 Explain the various CASE tools for project management and how they are \nuseful in achieving the objectives  APRIL/MAY - 15 \nProject management  is one of the critical processes of any project. This is due to the fact that \nproject management is the core process that connects all other project activities and \nprocesses together.  \nWhen it comes to the activities of project management, there are plenty . However, these \nplenty of project management activities can be categorized into five main processes.  \nLet's have a look at the five main project management processes in detail.  \n1 - Project Initiation  \nProject initiation is the starting point of any project.  In this process, all the activities related \nto winning a project takes place. Usually, the main activity of this phase is the pre -sale.", "mimetype": "text/plain", "start_char_idx": 284762, "end_char_idx": 289436, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "a8425034-f811-4497-97b0-743a9adde769": {"__data__": {"id_": "a8425034-f811-4497-97b0-743a9adde769", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9b851148-f6e6-457d-99ef-c6b72f9d5dbf", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "978842d2215f7bababf1b93b575e0e0f717e377a4df32b93c8a02252284af4f8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "98784a66-39d0-4b81-87fa-d17cab9bc243", "node_type": "1", "metadata": {}, "hash": "31e60ea76dcad8885dea6e42076206e4892ae5161aad3fcf175465ae337d7b9b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "3 Explain the various CASE tools for project management and how they are \nuseful in achieving the objectives  APRIL/MAY - 15 \nProject management  is one of the critical processes of any project. This is due to the fact that \nproject management is the core process that connects all other project activities and \nprocesses together.  \nWhen it comes to the activities of project management, there are plenty . However, these \nplenty of project management activities can be categorized into five main processes.  \nLet's have a look at the five main project management processes in detail.  \n1 - Project Initiation  \nProject initiation is the starting point of any project.  In this process, all the activities related \nto winning a project takes place. Usually, the main activity of this phase is the pre -sale. \nDuring the pre -sale period, the service provider proves the eligibility and ability of \ncompleting the project to the cl ient and eventually wins the business. Then, it is the detailed \nrequirements gathering which comes next.  \nDuring the requirements gathering activity, all the client requirements are gathered and \nanalysed for implementation. In this activity, negotiations ma y take place to change certain \nrequirements or remove certain requirements altogether.  \nUsually, project initiation process ends with requirements sign -off. \n2 - Project Planning  \nProject planning is one of the main project management processes. If the projec t \nmanagement team gets this step wrong, there could be heavy negative consequences during \nthe next phases of the project.  \nTherefore, the project management team will have to pay detailed attention to this process of \nthe project.  \nIn this process, the projec t plan is derived in order to address the project requirements such \nas, requirements scope, budget and timelines. Once the project plan is derived, then the \nproject schedule is developed.  \nDepending on the budget and the schedule, the resources are then all ocated to the project. \nThis phase is the most important phase when it comes to project cost and effort.  \n18\n0  \n 3 - Project Execution  \nAfter all paperwork is done, in this phase, the project management executes the project in \norder to achieve project objectives.  \nWhen it comes to execution, each member of the team carries out their own assignments \nwithin the given deadline for each activity. The detailed project schedule will be used for \ntracking the project progress.  \nDuring the project execution, there are many repo rting activities to be done. The senior \nmanagement of the company will require daily or weekly status updates on the project \nprogress.  \nIn addition to that, the client may also want to track the progress of the project. During the \nproject execution, it is a  must to track the effort and cost of the project in order to determine \nwhether the project is progressing in the right direction or not.  \nIn addition to reporting, there are multiple deliveries to be made during the project \nexecution. Usually, project deli veries are not onetime deliveries made at the end of the \nproject. Instead, the deliveries are scattered through out the project execution period and \ndelivered upon agreed timelines.  \n4 - Control and Validation  \nDuring the project life cycle, the project acti vities should be thoroughly controlled and \nvalidated. The controlling can be mainly done by adhering to the initial protocols such as \nproject plan, quality assurance test plan and communication plan for the project.  \nSometimes, there can be instances that a re not covered by such protocols. In such cases, the \nproject manager should use adequate and necessary measurements in order to control such \nsituations.  \nValidation is a supporting activity that runs from first day to the last day of a project. Each \nand eve ry activity and delivery should have its own validation criteria in order to verify the \nsuccessful outcome or the successful completion.  \nWhen it comes to project deliveries and requirements, a separate team called 'quality \nassurance team' will assist the p roject team for validation and verification functions.  \n5 - Closeout and Evaluation  \nOnce all the project requirements are achieved, it is time to hand over the implemented \nsystem and closeout the project. If the project deliveries are in par with the accept ance \ncriteria defined by the client, the project will be duly accepted and paid by the customer.  \nOnce the project closeout takes place, it is time to evaluate the entire project. In this \nevaluation, the mistakes made by the project team will be identified and will take necessary \nsteps to avoid them in the future projects.  \nDuring the project evaluation process, the service provider may notice that they haven't \ngained the expected margins for the project and may have exceeded the timelines planned at \nthe begi nning.  \nIn such cases, the project is not a 100% success to the service provider.", "mimetype": "text/plain", "start_char_idx": 288628, "end_char_idx": 293579, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "98784a66-39d0-4b81-87fa-d17cab9bc243": {"__data__": {"id_": "98784a66-39d0-4b81-87fa-d17cab9bc243", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "a8425034-f811-4497-97b0-743a9adde769", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "5c30b645608ce7d926670a09bd0deecdab039bc5b07d250437d42980529f2e87", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "62d1a6fd-dccf-46be-9ac6-3480e0e17366", "node_type": "1", "metadata": {}, "hash": "1787a1a1401746cf30b5f98895ac13173cd7518a8a5681fb708e2266ab8c8543", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "5 - Closeout and Evaluation  \nOnce all the project requirements are achieved, it is time to hand over the implemented \nsystem and closeout the project. If the project deliveries are in par with the accept ance \ncriteria defined by the client, the project will be duly accepted and paid by the customer.  \nOnce the project closeout takes place, it is time to evaluate the entire project. In this \nevaluation, the mistakes made by the project team will be identified and will take necessary \nsteps to avoid them in the future projects.  \nDuring the project evaluation process, the service provider may notice that they haven't \ngained the expected margins for the project and may have exceeded the timelines planned at \nthe begi nning.  \nIn such cases, the project is not a 100% success to the service provider. Therefore, such \ninstances should be studied carefully and should take necessary actions to avoid in the \nfuture.  \n18\n1  \n Conclusion  \nProject management is a responsible process. The pro ject management process connects all \nother project activities together and creates the harmony in the project.  \nTherefore, the project management team should have a detailed understanding on all the \nproject management processes and the tools that they can m ake use for each project \nmanagement process.  \n \n4 Brief about calculating Earned value measures APR/MAY - \n12,APRIL/MAY 2018  \nEarned value analysis is the  project management  tool that is used to measure  project progress. \nIt compares the actual work completed at any time to the original budget and schedule. It \nforecasts the final budget and schedule and analyzes the path to get there. It gives you the \nessential  early warning signal  that things are going awry.  \nThere are two variables which the  earned value method  focuses on.  \n\uf0a7 Schedule (time)  \n\uf0a7 Cost \nThere are 8 steps to performing earned value analysis eff ectively.   It may seem like alot at \nfirst glance, but for small projects this takes five minutes once you learn how to do it:  \n1. Determine the percent complete of each task.  \n2. Determine Planned Value (PV).  \n3. Determine Earned Value (EV).  \n4. Obtain Actual Cost (AC).  \n5. Calculate Schedule Variance (SV).  \n6. Calculate Cost Variance (CV).  \n7. Calculate Other Status Indicators  (SPI, CPI, EAC, ETC, and TCPI)  \n8. Compile Results  \nThe first four steps represent an information gathering phase. The remaining steps are \ncalculations which give t he project manager a glimpse into the current status of the project \nfrom a  budget  and schedule  perspective.  \nBefore you get started, it is important to define appropriate project status points in which this \ncalculation is performed.   Weekly status meetings work very well  for any size project, but \nwhatever time frame is used the important thing is to make sure thes e calculations are \nperformed at that time.  \n18\n2  \n Determine Percent Complete  \nTo start the process, the percentage complete of each task needs to be determined.  \nSmall tasks (80 hours or less) are often best done on a 0, 50, or 100% complete basis (not \nstarted, in progress, or complete).   This brings the workload down to reasonable levels and \nprevents abuse when project team members exaggerate, for example they might tell you a \ntask is 80% complete when it is really 50% complete.  \nFor repetitive tasks you can also us e progressive measures such as number of fence posts \ninstalled.  \nDetermine Planned Value (PV)  \nPlanned Value , also known as  Budgeted Cost of Work Scheduled (BCWS) , is defined as the \namount of the task that is  supposed to  have been completed.   It is in monetary terms as a \nportion of the task budget.   For example let\u2019s say that:  \n\uf0a7 The task budget is $5,000,  \n\uf0a7 The task start date is January 1, and  \n\uf0a7 The task finish date is January 10.  \nIf it\u2019s January 6 today, the task is supposed to be 60% complete. Therefore,  PV = $5,000 x \n60% = $3,000 . \nDetermine Earned Value (EV)  \nEarned Value , also known as  Budgeted Cost of Work Performed (BCWP) , is the amount of \nthe task that is actually complete.   It is, again, in monetary terms as a portion of the task \nbudget.   For example, let\u2019s use the same example task.", "mimetype": "text/plain", "start_char_idx": 292770, "end_char_idx": 296967, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "62d1a6fd-dccf-46be-9ac6-3480e0e17366": {"__data__": {"id_": "62d1a6fd-dccf-46be-9ac6-3480e0e17366", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "98784a66-39d0-4b81-87fa-d17cab9bc243", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ed0e0912ef20cffb7d368be17f10ab4319950ff385492cdd8b8a40152846aaa0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3", "node_type": "1", "metadata": {}, "hash": "0b47029e63947e51bf58526320b017ce6b1333b4d957c758b42b297cc1543090", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "It is in monetary terms as a \nportion of the task budget.   For example let\u2019s say that:  \n\uf0a7 The task budget is $5,000,  \n\uf0a7 The task start date is January 1, and  \n\uf0a7 The task finish date is January 10.  \nIf it\u2019s January 6 today, the task is supposed to be 60% complete. Therefore,  PV = $5,000 x \n60% = $3,000 . \nDetermine Earned Value (EV)  \nEarned Value , also known as  Budgeted Cost of Work Performed (BCWP) , is the amount of \nthe task that is actually complete.   It is, again, in monetary terms as a portion of the task \nbudget.   For example, let\u2019s use the same example task.  \n\uf0a7 The task budget is $5,000, (same as above)  \n\uf0a7 The task start date is January 1, and (same as above)  \n\uf0a7 The task finish date is January 10.   (same as ab ove) \nLet\u2019s say the actual percent complete of the task (step 1) is 40%. Therefore,  EV = $5,000 x \n40% = $2,000 . \nObtain Actual Cost (AC)  \nThe Actual Cost , also known as  Actual Cost of Work Performed (ACWP) , as you might \nguess, is the  actual cost  of the work.   Generally employee hours need to be converted into a \n18\n3  \n cost, and all project costs need to be added up, such as the following items:  \n\uf0a7 Labor  \n\uf0a7 Materials  \n\uf0a7 Equipment  \n\uf0a7 Fixed cost items, like subcontractors  \nSince most projects have these well defined via accounting or project management software, \nwe will not go into great detail here.   For the purposes of our example project let\u2019s say the \nactual cost of the example task is $1,500.  \nAt this point  the information gathering phase is complete. The following  calculations \nrepresent the application of the earned value analysis to keep your project on schedule and \nbudget.  \nCalculate Schedule Variance (SV)  \nThe Schedule Variance  represents the schedule status of the project.  \nSV = EV \u2013 PV \nIn our above example the schedule variance is:   SV = $2,000 \u2013 $3,000 = -$1,000 . \nA negative schedule variance means the task is behind sc hedule.   A positive schedule \nvariance means it is ahead of schedule.   The amount can be compared to worker charge out \nrates or similar metrics to get an idea of how difficult it would be to recover.  \nCalculate Cost Variance (CV)  \nThe Cost Variance  represents the cost status of the project.  \nCV = EV \u2013 AC \nIn our above  example  the cost variance is:   CV = $2,00 0 \u2013 $1,500 = $500 . \nA negative cost variance means the task is over budget.   A positive cost variance means it is \nunder budget.  \nCalculate Other Status Indicators  \nAlthough the SV and CV are the minimum requirement and work well for small projects, \nthere are other variables that are derived from them which you might want to calculate:  \n\uf0a7 Schedule Performance Index (SPI) :  The schedule variance expressed in percentage \n18\n4  \n terms, for example, SPI = 0.8 means the project 20% behind schedule.  \nSPI = EV / PV  \n\uf0a7 Cost Performance Index (CPI) : The cost variance expressed in percentage terms, \nfor example, CPI = 0.9 means the project is 10% over budget.  \nCPI = EV / AC  \n\uf0a7 Estimate at Completion (EAC) :  The expected budget at the end of the project \ngiven the va riances that have already taken place. There are various ways to extrapolate \nthis value but assuming that the past variances are likely to persist:  \nEAC = AC + BAC \u2013 EV \n\uf0a7 Estimate to Complete (ETC) :  The expected cost to finish the rest of the project.  \nETC = EAC \u2013 AC \n\uf0a7 To Complete Performance Index (TCPI) :  The required CPI necessary to finish the \nproject right on budget.   For example, TCPI = 1.25 means you need to find 25% \nefficiencies to finish on budget.  \nTCPI = (BAC \u2013 EV) / (BAC \u2013 AC) \nCompile the Results  \nEach metric is calculated for each individual task in the project. Therefore they need to be \nadded up into overall project variances to get the overall progress indicator for the project.   \nThis represents the  total variance  of the project and can be  reported  to management, clients, \nand stakeholders.", "mimetype": "text/plain", "start_char_idx": 296385, "end_char_idx": 300296, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3": {"__data__": {"id_": "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "62d1a6fd-dccf-46be-9ac6-3480e0e17366", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "1451f29b153b2ef252e3b71b632c00ce4b5d974f462d14ac7bfb6528de64a2c2", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7575763a-6c7c-43b2-ab8c-c338f3d2c814", "node_type": "1", "metadata": {}, "hash": "1b66aaf546791f1a7ddfa860875bf31fd53802a4dcc2a48814db18dcf47f04f7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "ETC = EAC \u2013 AC \n\uf0a7 To Complete Performance Index (TCPI) :  The required CPI necessary to finish the \nproject right on budget.   For example, TCPI = 1.25 means you need to find 25% \nefficiencies to finish on budget.  \nTCPI = (BAC \u2013 EV) / (BAC \u2013 AC) \nCompile the Results  \nEach metric is calculated for each individual task in the project. Therefore they need to be \nadded up into overall project variances to get the overall progress indicator for the project.   \nThis represents the  total variance  of the project and can be  reported  to management, clients, \nand stakeholders.  \nThe results are as instantaneous as the input data, that is, if you input the percent complete as \nof right now the statu s reported will be as of right now as well. It\u2019s amazing how a small \nvariance does not cause anyone concern until they see it as a number, and it can be corrected \nbefore it becomes more serious.  \nInterpreting the Results  \nThe first two calculations (SV and C V) give you the basic indicator of project progress.  A \nnegative value indicates an undesirable situation.  \n\uf0a7 If the schedule variance (SV) is negative, you are behind schedule.  \n\uf0a7 If the cost variance (CV) is negative, you are over budget.  \nThe amount of the var iance can be compared to the project\u2019s budget to see how concerning it \nis.  For example, a variance of $1,000 on a $100,000 project is not that concerning but a \n$10,000 variance might need some attention.  The variances can also  be compared to \nemployee cha rge out rates or something similar, for example a $1,000 variance might require \n18\n5  \n a person who\u2019s earning $50/hour to work 20 hours to recover.  \nIn our example the schedule variance was -$1,000 and the cost variance was $500.   This \nmeans that the project is be hind schedule, but it is being performed efficiently and is cost -\npositive.   If an worker  charging $75/hr was performing the majority of this work, they are \nabout 13 hours behind schedule (although they will finish under budget).  Thus, we know that \nthis ta sk requires a couple days of work over and above the regular schedule to get it back on \ntrack.  \nGraphing the results over multiple status points is a very helpful exercise.   Good  project \ncontrol  often means that the instantaneous project status snapshot is not as important as the \ntrend the indicators are making over time.   For example, if the SV has been increasing, then \nmaybe the project will finish on time even though it\u2019s behin d schedule today.  \nIt is a well understood concept that if projects fall behind early they will tend to continue \nfalling further behind throughout their entire life. Earned value analysis will alert you if you \nare even one hour behind and allow you to take the necessary remedial action. The value of \nthis in producing successful projects is almost without equal.  \n \n  \n5 Define Risk. Explain the needs and activities or risk management? APR/MAY -\n15 , NOV/DEC2015  ,NOV/DEC  2017  \nRisk is inevitable in a business orga nization when undertaking projects. However, the \nproject manager needs to ensure that risks are kept to a minimal. Risks can be mainly \ndivided between two types, negative impact risk and positive impact risk.  \nNot all the time would project managers be faci ng negative impact risks as there are positive \nimpact risks too. Once the risk has been identified, project managers need to come up with a \nmitigation plan or any other solution to counter attack the risk.  \nProject Risk Management  \nManagers can plan their st rategy based on four steps of risk management which prevails in \nan organization. Following are the steps to manage risks effectively in an organization:  \n\uf0b7 Risk Identification  \n\uf0b7 Risk Quantification  \n\uf0b7 Risk Response  \n\uf0b7 Risk Monitoring and Control  \nLet's go through each  of the step in project risk management:  \n18\n6  \n Risk Identification  \nManagers face many difficulties when it comes to identifying and naming the risks that \noccur when undertaking projects. These risks could be resolved through structured or \nunstructured brainstorm ing or strategies. It's important to understand that risks pertaining to \nthe project can only be handled by the project manager and other stakeholders of the project.  \nRisks, such as operational or business risks will be handled by the relevant teams. The r isks \nthat often impact a project are supplier risk, resource risk and budget risk.", "mimetype": "text/plain", "start_char_idx": 299718, "end_char_idx": 304130, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7575763a-6c7c-43b2-ab8c-c338f3d2c814": {"__data__": {"id_": "7575763a-6c7c-43b2-ab8c-c338f3d2c814", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ad91997808a98ed96b181dafc5a209d010e0805775696252dcb19f5160b116d8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "6d2b4279-ac2f-4ae4-821d-a15d1657c534", "node_type": "1", "metadata": {}, "hash": "22002755222735511719b1cc26eade279ed5b910da0e70662d766fdf48fbc2f9", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Project Risk Management  \nManagers can plan their st rategy based on four steps of risk management which prevails in \nan organization. Following are the steps to manage risks effectively in an organization:  \n\uf0b7 Risk Identification  \n\uf0b7 Risk Quantification  \n\uf0b7 Risk Response  \n\uf0b7 Risk Monitoring and Control  \nLet's go through each  of the step in project risk management:  \n18\n6  \n Risk Identification  \nManagers face many difficulties when it comes to identifying and naming the risks that \noccur when undertaking projects. These risks could be resolved through structured or \nunstructured brainstorm ing or strategies. It's important to understand that risks pertaining to \nthe project can only be handled by the project manager and other stakeholders of the project.  \nRisks, such as operational or business risks will be handled by the relevant teams. The r isks \nthat often impact a project are supplier risk, resource risk and budget risk. Supplier risk \nwould refer to risks that can occur in case the supplier is not meeting the timeline to supply \nthe resources required.  \nResource risk occurs when the human reso urce used in the project is not enough or not \nskilled enough. Budget risk would refer to risks that can occur if the costs are more than \nwhat was budgeted.  \nRisk Quantification  \nRisks can be evaluated based on quantity. Project managers need to analyze the l ikely \nchances of a risk occurring with the help of a matrix.  \n \nUsing the matrix, the project manager can categorize the risk into four  categories as Low, \nMedium, High and Critical. The probability of occurrence and the impact on the project are \nthe two parameters used for placing the risk in the matrix categories. As an example, if a risk \noccurrence is low (probability = 2) and it has th e highest impact (impact = 4), the risk can be \ncategorized as 'High'.  \nRisk Response  \nWhen it comes to risk management, it depends on the project manager to choose strategies \nthat will reduce the risk to minimal. Project managers can choose between the four risk \nresponse strategies, which are outlined below.  \n\uf0b7 Risks can be avoided  \n\uf0b7 Pass on the risk  \n\uf0b7 Take corrective measures to reduce the impact of risks  \n\uf0b7 Acknowledge the risk  \nRisk Monitoring and Control  \nRisks can be monitored on a continuous basis to check if any c hange is made. New risks can \nbe identified through the constant monitoring and assessing mechanisms.  \n18\n7  \n Risk Management Process  \nFollowing are the considerations when it comes to risk management process:  \n\uf0b7 Each person involved in the process of planning needs to  identify and understand the \nrisks pertaining to the project.  \n\uf0b7 Once the team members have given their list of risks, the risks should be \nconsolidated to a single list in order to remove the duplications.  \n\uf0b7 Assessing the probability and impact of the risks inv olved with the help of a matrix.  \n\uf0b7 Split the team into subgroups where each group will identify the triggers that lead to \nproject risks.  \n\uf0b7 The teams need to come up with a contingency plan whereby to strategically \neliminate the risks involved or identified.  \n\uf0b7 Plan the risk management process. Each person involved in the project is assigned a \nrisk in which he/she looks out for any triggers and then finds a suitable solution for \nit. \nRisk Register  \nOften project managers will compile a document, which outlines the ri sks involved and the \nstrategies in place. This document is vital as it provides a huge deal of information.  \nRisk register will often consists of diagrams to aid the reader as to the types of risks that are \ndealt by the organization and the course of action  taken. The risk register should be freely \naccessible for all the members of the project team.  \nProject Risk; an Opportunity or a Threat?  \nAs mentioned above, risks contain two sides. It can be either viewed as a negative element \nor a positive element. Negat ive risks can be detrimental factors that can haphazard situations \nfor a project.  \nTherefore, these should be curbed once identified. On the other hand, positive risks can \nbring about acknowledgements from both the customer and the management. All the risks  \nneed to be addressed by the project manager.  \nConclusion  \nAn organization will not be able to fully eliminate or eradicate risks. Every project \nengagement will have its own set of risks to be dealt with. A certain degree of risk will be \ninvolved when undert aking a project.  \nThe risk management process should not be compromised at any point, if ignored can lead to \ndetrimental effects. The entire management team of the organization should be aware of the \nproject risk management methodologies and techniques.", "mimetype": "text/plain", "start_char_idx": 303187, "end_char_idx": 307888, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6d2b4279-ac2f-4ae4-821d-a15d1657c534": {"__data__": {"id_": "6d2b4279-ac2f-4ae4-821d-a15d1657c534", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "7575763a-6c7c-43b2-ab8c-c338f3d2c814", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "17e47ea1b2c74e3d7a8e856d6e4d0dd4a9d6a74b8c577cdf66e8adecc4394319", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "105c5646-761f-45e7-8258-7cedb52c3476", "node_type": "1", "metadata": {}, "hash": "90ee20dea9c321432eeb66b9ab60703a059d693563f1c9ddb6d780a9685b7f31", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "As mentioned above, risks contain two sides. It can be either viewed as a negative element \nor a positive element. Negat ive risks can be detrimental factors that can haphazard situations \nfor a project.  \nTherefore, these should be curbed once identified. On the other hand, positive risks can \nbring about acknowledgements from both the customer and the management. All the risks  \nneed to be addressed by the project manager.  \nConclusion  \nAn organization will not be able to fully eliminate or eradicate risks. Every project \nengagement will have its own set of risks to be dealt with. A certain degree of risk will be \ninvolved when undert aking a project.  \nThe risk management process should not be compromised at any point, if ignored can lead to \ndetrimental effects. The entire management team of the organization should be aware of the \nproject risk management methodologies and techniques.  \nEnhanced education and frequent risk assessments are the best way to minimize the damage \nfrom risks.  \n \n18\n8  \n 6 Explain  about  all COCOMO  models? NOV/DEC  2015,  \nAPRIL/MAY2016, APRIL/MAY 2017, APRIL/MAY  2018  \nCocomo (Constructive Cost Model) is a regression model based o n LOC, i.e  number  \nof Lines  of Code . It is a procedural cost estimate model for software projects and \noften used as a process of reliably predicting the various parameters associated with \nmaking a project such as size, effort, cost, time and quality. It was  proposed by Barry \nBoehm in 1970 and is based on the study of 63 projects, which make it one of the \nbest-documented models.  \nThe key parameters which define the quality of any software products, which are also \nan outcome of the Cocomo are primarily Effort &  Schedule:  \n\uf0b7 Effort:  Amount of labor that will be required to complete a task. It is \nmeasured in person -months units.  \n\uf0b7 Schedule:  Simply means the amount of time required for the completion of \nthe job, which is, of course, proportional to the effort put. It is  measured in the \nunits of time such as weeks, months.  \nDifferent models of Cocomo have been proposed to predict the cost estimation at \ndifferent levels, based on the amount of accuracy and correctness required. All of \nthese models can be applied to a variet y of projects, whose characteristics determine \nthe value of constant to be used in subsequent calculations. These characteristics \npertaining to different system types are mentioned below.  \nBoehm\u2019s definition of organic, semidetached, and embedded systems:  \n1. Organic \u2013 A software project is said to be an organic type if the team size \nrequired is adequately small, the problem is well understood and has been solved \nin the past and also the team members have a nominal experience regarding the \nproblem.  \n2. Semi -detached  \u2013 A software project is said to be a Semi -detached type if the \nvital characteristics such as team -size, experience, knowledge of the various \nprogramming environment lie in between that of organic and Embedded. The \nprojects classified as Semi -Detached are comparatively less familiar and difficult \nto develop compared to the organic ones and require more experience and better \nguidance and creativity. Eg: Compilers or different Embedded Systems can be \nconsidered of Semi -Detached type.  \n3. Embedded \u2013 A software pro ject with requiring the highest level of \ncomplexity, creativity, and experience requirement fall under this category. Such \nsoftware requires a larger team size than the other two models and also the \ndevelopers need to be sufficiently experienced and creati ve to develop such \ncomplex models.  \nAll the above system types utilize different values of the constants used in Effort \nCalculations.  \nTypes of Models:  COCOMO consists of a hierarchy of three increasingly detailed \nand accurate forms. Any of the three forms c an be adopted according to our \nrequirements. These are types of COCOMO model:  \n1. Basic COCOMO Model  \n2. Intermediate COCOMO Model  \n3. Detailed COCOMO Model  \n18\n9  \n The first level,  Basic COCOMO  can be used for quick and slightly rough \ncalculations of Software Costs. Its accu racy is somewhat restricted due to the absence \nof sufficient factor considerations.  \nIntermediate COCOMO  takes these Cost Drivers into account and  Detailed \nCOCOMO  additionally accounts for the influence of individual project phases, i.e in \ncase of Detailed it accounts for both these cost drivers and also calculations are \nperformed phase wise henceforth producing a more accurate result.", "mimetype": "text/plain", "start_char_idx": 306986, "end_char_idx": 311496, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "105c5646-761f-45e7-8258-7cedb52c3476": {"__data__": {"id_": "105c5646-761f-45e7-8258-7cedb52c3476", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "6d2b4279-ac2f-4ae4-821d-a15d1657c534", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "bdaa58c7cf88b6cd0ec2660def6ef4a4df66d0c016951b986860440e5e49bed3", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "3e149501-6908-4ec1-8a3e-a7d0605e0bbb", "node_type": "1", "metadata": {}, "hash": "b5e06762b3dec8144c2e525771f4f975b66379f26f47f50ddefd7408ce0b2f41", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Types of Models:  COCOMO consists of a hierarchy of three increasingly detailed \nand accurate forms. Any of the three forms c an be adopted according to our \nrequirements. These are types of COCOMO model:  \n1. Basic COCOMO Model  \n2. Intermediate COCOMO Model  \n3. Detailed COCOMO Model  \n18\n9  \n The first level,  Basic COCOMO  can be used for quick and slightly rough \ncalculations of Software Costs. Its accu racy is somewhat restricted due to the absence \nof sufficient factor considerations.  \nIntermediate COCOMO  takes these Cost Drivers into account and  Detailed \nCOCOMO  additionally accounts for the influence of individual project phases, i.e in \ncase of Detailed it accounts for both these cost drivers and also calculations are \nperformed phase wise henceforth producing a more accurate result. These two models \nare further discussed below.  \nEstimation of Effort: Calculations \u2013 \n4. Basic Model \u2013 \n5.  \nThe above formula is used for the cost estimation of for the basic COCOMO \nmodel, and also is used in the subsequent models. The constant  values a and b for \nthe Basic Model for the different categories of system:  \nSOFTWARE PROJECTS  A B \nOrganic  2.4 1.05 \nSemi Detached  3.0 1.12 \nEmbedded  3.6 1.20 \nThe effort is measured in Person -Months and as evident from the formula is \ndependent on Kilo -Lines of code. These formulas are used as such in the Basic \nModel calculations, as not much consideration of different factors such as \nreliability, expertise is taken into account, henceforth the estimate is rough.  \n6. Intermediate Model \u2013 \nThe basic Cocomo model assumes that the effort is only a function of the number \nof lines of code and some constants evaluated according to the different software \nsystem. However, in reality, no system\u2019s effort and schedule can be solely \ncalculated on the basis of Lines of Code. For that, various other factors such as \nreliability, experience, Capability. These factors are known as Cost Drivers and \nthe Intermediate Model utilizes 15 such drivers for cost estimation.  \nClassification of Cost Drivers and their attributes:  \n1.", "mimetype": "text/plain", "start_char_idx": 310688, "end_char_idx": 312785, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "3e149501-6908-4ec1-8a3e-a7d0605e0bbb": {"__data__": {"id_": "3e149501-6908-4ec1-8a3e-a7d0605e0bbb", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "105c5646-761f-45e7-8258-7cedb52c3476", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "ebc2aac680e23336193f4ec9e535b359d109ba6f800db7820d56637069dd72c0", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "41153092-1ab6-4b2f-a285-996a158b0fd1", "node_type": "1", "metadata": {}, "hash": "073f48e42df99fcef8e2116e40660331d79a1f9d8a09f0234d5309c7c169c3a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "These formulas are used as such in the Basic \nModel calculations, as not much consideration of different factors such as \nreliability, expertise is taken into account, henceforth the estimate is rough.  \n6. Intermediate Model \u2013 \nThe basic Cocomo model assumes that the effort is only a function of the number \nof lines of code and some constants evaluated according to the different software \nsystem. However, in reality, no system\u2019s effort and schedule can be solely \ncalculated on the basis of Lines of Code. For that, various other factors such as \nreliability, experience, Capability. These factors are known as Cost Drivers and \nthe Intermediate Model utilizes 15 such drivers for cost estimation.  \nClassification of Cost Drivers and their attributes:  \n1. Product attri butes \u2013 \n\uf0b7 Required software reliability extent  \n\uf0b7 Size of the application database  \n\uf0b7 The complexity of the product  \n(ii) Hardware attributes \u2013 \n\uf0b7 Run-time performance constraints  \n\uf0b7 Memory constraints  \n\uf0b7 The volatility of the virtual machine environment  \n19\n0  \n \uf0b7 Required turnabout time \n(iii) Personnel attributes \u2013 \n\uf0b7 Analyst capability  \n\uf0b7 Software engineering capability  \n\uf0b7 Applications experience  \n\uf0b7 Virtual machine experience  \n\uf0b7 Programming language experience  \n(iv) Project attributes \u2013 \n\uf0b7 Use of software tools  \n\uf0b7 Application of software engineering meth ods \n\uf0b7 Required development schedule  \n; \nCOST DRIVERS  VERY \nLOW  LOW  NOMINAL  HIGH  VERY \nHIGH  \nProduct Attributes  \n     Required Software \nReliability  0.75 0.88 1.00 1.15 1.40 \nSize of Application \nDatabase  \n 0.94 1.00 1.08 1.16 \nComplexity of The \nProduct  0.70 0.85 1.00 1.15 1.30 \nHardware Attributes  \n     Runtime Performance \nConstraints  \n  1.00 1.11 1.30 \nMemory Constraints  \n  1.00 1.06 1.21 \nVolatility of the virtual \n 0.87 1.00 1.15 1.30 \n19\n1  \n machine environment  \nRequired turnabout \ntime \n 0.94 1.00 1.07 1.15 \nPersonnel attri butes  \n     Analyst capability  1.46 1.19 1.00 0.86 0.71 \nApplications \nexperience  1.29 1.13 1.00 0.91 0.82 \nSoftware engineer \ncapability  1.42 1.17 1.00 0.86 0.70 \nVirtual machine \nexperience  1.21 1.10 1.00 0.90 \n Programming language \nexperience  1.14 1.07 1.00 0.95 \n Project Attributes  \n     Application of software \nengineering methods  1.24 1.10 1.00 0.91 0.82 \nUse of software tools  1.24 1.10 1.00 0.91 0.83 \nRequired development \nschedule  1.23 1.08 1.00 1.04 1.10 \nThe project manager is to rate these 15 differen t parameters for a particular \nproject on a scale of one to three. Then, depending on these ratings, appropriate \n19\n2  \n cost driver values are taken from the above table. These 15 values are then \nmultiplied to calculate the EAF (Effort Adjustment Factor). The Inte rmediate \nCOCOMO formula now takes the form:  \n \nThe values of a and b in case of the intermediate model are as fo llows:  \nSOFTWARE PROJECTS  A B \nOrganic  3.2 1.05 \nSemi Detached  3.0 1.12 \nEmbeddedc  2.8 1.20 \n2. Detailed Model \u2013 \nDetailed COCOMO incorporates all characteristics of the intermediate version \nwith an assessment of the cost driver\u2019s impact on each step of the sof tware \nengineering process. The detailed model uses different effort multipliers for each \ncost driver attribute. In detailed cocomo, the whole software is divided into \ndifferent modules and then we apply COCOMO in different modules to estimate \neffort and th en sum the effort.  \nThe Six phases of detailed COCOMO are:  \n1. Planning and requirements  \n2. System design  \n3. Detailed design  \n4. Module code and test  \n5. Integration and test  \n6.", "mimetype": "text/plain", "start_char_idx": 312023, "end_char_idx": 315560, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "41153092-1ab6-4b2f-a285-996a158b0fd1": {"__data__": {"id_": "41153092-1ab6-4b2f-a285-996a158b0fd1", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "3e149501-6908-4ec1-8a3e-a7d0605e0bbb", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "a8e7eb0f54bae5f6a2e19dc72923e19d56c1661d4398d14cd1aa5c9bc613a4fc", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "9dc6567c-8023-4a0c-9003-60c93a5e38a4", "node_type": "1", "metadata": {}, "hash": "b1d9686cb545d22b9384f14bea8fc5534aecdcad9f9770e5d960e2fb50c9f573", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Detailed Model \u2013 \nDetailed COCOMO incorporates all characteristics of the intermediate version \nwith an assessment of the cost driver\u2019s impact on each step of the sof tware \nengineering process. The detailed model uses different effort multipliers for each \ncost driver attribute. In detailed cocomo, the whole software is divided into \ndifferent modules and then we apply COCOMO in different modules to estimate \neffort and th en sum the effort.  \nThe Six phases of detailed COCOMO are:  \n1. Planning and requirements  \n2. System design  \n3. Detailed design  \n4. Module code and test  \n5. Integration and test  \n6. Cost Constructive model  \nThe effort is calculated as a function of program size and a set of cost dri vers are \ngiven according to each phase of the software lifecycle.  \n \n7 Write   about   software   maintenance,  PERT  - CPM  for scheduling , \nRMMP  NOV/DEC -12 \nProject Scheduling or project management is used to schedule, manage and \ncontrol projects which can b e analyzed into various semi -independent \nactivities or tasks. Example: Building a New Home When building a home \nindividual subcontractors are hired to:  \n \u2015 Grade and prepare the land  \n \u2015 Build the foundation  \n \u2015 Frame up the home  \n\u2015 Insulate the home  \n\u2015 Wire (Electricity, Cable, Telephone lines) the home \u2015 Drywall  \n19\n3  \n \u2015 Paint (inside)  \n\u2015 Put vinyl siding on home  \n \u2015 Install Carpet  \n \u2015 Landscape  \n \u2015 Lay Concrete  \nPERT \u2013 Program Evaluation and Review Technique  \n \u2013 Developed by U.S. Navy for Polaris missile project  \n \u2013 Developed to handle uncertain activity times CPM  \n\u2013 Critical Path Method  \n\u2013 Developed by Du Pont & Remington Rand  \n \u2013 Developed for industrial projects for which activity times are known \nThere are project management software packages that can perform both.  \nPERT and CPM have been used to plan, schedule, and control a wide \nvariety of projects:  \n \u2013 R&D of new products and processes  \n \u2013 Construction of buildings and highways  \n \u2013 Maintenance of large and complex equipment  \n\u2013 Design and installation of management syste ms \n \u2013 Organizing transportation projects  \n\u2013 Deployment and/or relocation of forces  \n\u2013 Design of computer systems  \n\uf0b7 PERT/CPM is used to plan the scheduling and optimal staffing of \nindividual activities that make up a project.  \n\uf0b7 Projects may have as many as sev eral thousand activities and may \nhave to be broken up into simpler sub -projects.  \n\uf0b7  Usually some activities depend on the completion of other activities \nbefore they can be started.  \n\uf0b7  So we need to start with the Prerequisites Task Set giving the order \nof prec edencies, along with durations for each task, or activity  \n8 Describe steps involved in project scheduling process, project timeline chart \nand task network . MAY/JUN -15, APRIL/MAY  2018  \nPress -Pg-no- 708 \n19\n4  \n 9 (b) Suppose you have a budgeted cost of a project as Rs.  9,00,000. The project \nis to be completed in 9 months. After a month you have completed 10 percent \nof project at a total expense of Rs. 1,00,000. The planned completion should \nhave been 15 percent. You need to determine whether the project is on -time \nand on budget? Use Earned value analysis approach and interpret NOV/DEC  \n2016  \n(c ) Consider the following function point components and their complexity. If \nthe total degree of influence is 52, find the estimated function  points.  \nFunction type  Estimated count  complexi ty \nFED  2 7 \nGHD  4 \n10 \nHJI 22 4 \nBU 16 5 \n BJ 24 4 \n \n \nRefer class notes  \n10 Describe in detail COCOMO model for software cost estimation. Use it to \nestimate the effort required to build software for a simple ATM that produce \n12 screens, 10 reports and has 80 so ftware components. Assume average \ncomplexity and average developer maturity. Use application composition \nmodel with object points. NOV/DEC 2016, NOV/DEC 2017  \n \nRefer class notes  \n11 Explain the process of function point analysis?explain function point analys is \nwith sample cases for componentfor different complexity APRIL/MAY 2018  \nRefer class notes  \n12 Discuss on the various software cost estimation techniques. (April/MayApr/May \n2008)  \nRefer class notes  \n13 Explain  the process of Delphi method ?", "mimetype": "text/plain", "start_char_idx": 314945, "end_char_idx": 319135, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "9dc6567c-8023-4a0c-9003-60c93a5e38a4": {"__data__": {"id_": "9dc6567c-8023-4a0c-9003-60c93a5e38a4", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "41153092-1ab6-4b2f-a285-996a158b0fd1", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "69df9f0f0325be7955ed93d047bd26faea4a4b0a40278af989bb822bc148769e", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "eb97c706-3f5b-43c3-ad73-15b59b6a0f10", "node_type": "1", "metadata": {}, "hash": "2d418f342523144737e2b956a91621e106f986977e7ed1828fdc46549c28d3a0", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Use it to \nestimate the effort required to build software for a simple ATM that produce \n12 screens, 10 reports and has 80 so ftware components. Assume average \ncomplexity and average developer maturity. Use application composition \nmodel with object points. NOV/DEC 2016, NOV/DEC 2017  \n \nRefer class notes  \n11 Explain the process of function point analysis?explain function point analys is \nwith sample cases for componentfor different complexity APRIL/MAY 2018  \nRefer class notes  \n12 Discuss on the various software cost estimation techniques. (April/MayApr/May \n2008)  \nRefer class notes  \n13 Explain  the process of Delphi method ? advantages and  disadvantages \n(Nov/Dec 2013)  \nRefer class notes  \n14 Explain about Risk management (May/Jun 2014)  \nRisk management  is the identification, evaluation, and prioritization of  risks  (defined \n19\n5  \n in ISO 31000  as the effect of uncertainty on objectives ) followed by coordinated and \neconomical application of resources to minimize, monitor, and control the probability \nor impact of unfortunate  events[1] or to maximize the realization of opportunities.  \nRisks can come from various sources including uncertainty in  financial markets , \nthreats from project failures (at any phase in design, development, production, or \nsustaining of life -cycles), legal liabilities, credit risk, accidents,  natural causes and \ndisasters , deliberate attack from an adversary, or events of uncertain or \nunpredictable  root-cause . There are two types of events i.e. negative events can be \nclassified as risks while positive events are classified as opportunities. Risk \nmanagement  standards  have been develope d by various institutions, including \nthe Project Management Institute , the National Institute of Standards and Technology , \nactuarial societies, and ISO standards.[2][3] Methods, definitions and goals vary widely \naccording to whether the risk management method is in the context of project \nmanagement, security,  engineering , industrial processes , financial portfolios, actuarial \nassessments, or public health and safety.  \nStrategies to manage threats (uncertainties with negative consequences) typically \ninclude avoiding the threat, reducing the negative effect or probability of the threat, \ntransferring all or part of the threat to another party, and even retainin g some or all of \nthe potential or actual consequences of a particular threat, and the opposites for \nopportunities (uncertain future states with benefits).  \nCertain risk management standards have been criticized for having no measurable \nimprovement on risk, whereas the confidence in estimates and decisions seems to \nincrease.[1] For example, one study found that one in six IT projects were \" black \nswans \" with gigantic overruns (cost overruns averaged 200%, and schedule overruns \n7 \n \n15 Give detail explanation about Scheduling and Tracking  \nProject Scheduling helps to establish a  roadmap for project managers together with \nestimation methods and risk analysis. Project scheduling and Tracking begins with the \nidentification of process models, identification of software tasks and activities, \nestimation of effort and work and ends with  creation of network of tasks and making \nsure it gets done on time. This network is adapted on encountering of changes and \nrisks.  \n \nAt the project level, the Project Manager does project tracking and scheduling based \non information received from Software En gineers. At an individual level the Software \nEngineer does it. It is important, as in a complex system many tasks may occur in \nparallel and have interdependencies that are understandable only with a schedule. A \ndetailed schedule is a useful tool to assess progress on a moderate or large project.  \n  \nThe basic steps followed are, once the tasks dictated by the software process model is \nrefined based on the functionality of the system , effort and duration are allocated for \neach task and an activity network is created that allows the project to meets its \ndeadlines. The work product of this activity is the project schedule and in order that it \nis accurate it is required to check all tasks are covered in the activity network, effort \nand timing are appropriately al located, interdependencies are correctly indicated, \n19\n6  \n resources are allocated tasks in a right manner and closely spaced milestones are \ndefined to track the project easily.  \n  \nOne of the major challenges in software project management is the difficulty to \nadhere to schedules. The common reasons for a late delivery of software project are \nan unrealistic deadline, changing customer requirements, honest underestimate of \neffort or resources, overlooked risks, unforeseen technical difficulties or human \ndifficulties , miscommunication and failure by project manager to recognize the delay \nearly and take appropriate measures.", "mimetype": "text/plain", "start_char_idx": 318496, "end_char_idx": 323377, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "eb97c706-3f5b-43c3-ad73-15b59b6a0f10": {"__data__": {"id_": "eb97c706-3f5b-43c3-ad73-15b59b6a0f10", "embedding": null, "metadata": {"filename": "soft.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178", "node_type": "4", "metadata": {"filename": "soft.pdf"}, "hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "9dc6567c-8023-4a0c-9003-60c93a5e38a4", "node_type": "1", "metadata": {"filename": "soft.pdf"}, "hash": "7fe6c850d52c337eec16bd6e1dc9b26ebc7bb91222349f7b94ecdcc2f7fde6c7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The work product of this activity is the project schedule and in order that it \nis accurate it is required to check all tasks are covered in the activity network, effort \nand timing are appropriately al located, interdependencies are correctly indicated, \n19\n6  \n resources are allocated tasks in a right manner and closely spaced milestones are \ndefined to track the project easily.  \n  \nOne of the major challenges in software project management is the difficulty to \nadhere to schedules. The common reasons for a late delivery of software project are \nan unrealistic deadline, changing customer requirements, honest underestimate of \neffort or resources, overlooked risks, unforeseen technical difficulties or human \ndifficulties , miscommunication and failure by project manager to recognize the delay \nearly and take appropriate measures.  \n  \nSoftware project scheduling is an activity that distributes estimated effort across the \nduration of project cycle by allocating effort to each s pecific task that is associated \nwith all process. The basic principles that guides software project scheduling is \ncompartmentalization of the project into a number of manageable tasks, correct \nallocation of time, correct effort validation ,defining respons ibility for each task to a \nteam member, defining outcomes or work product for each task and defining \nmilestones for a task or group of tasks as appropriate.  \n  \nA Task set is a collection of software tasks, milestones and deliveries that must be \ncompleted fo r the project to be successfully accomplished. Task sets are defined for \nbeing applicable to different type of project and degree of rigor. The types of projects \ncommonly encountered are Concept Development projects, New applications, \nDevelopment projects,  Application enhancement projects, Application maintenance \nprojects and Re -engineering projects. The degree of rigor with which the software \nprocess is applied may be casual, structured, strict or quick reaction (used for \nemergency situation).  \n  \nFor the pr oject manager to develop a systematic approach for selecting degree of rigor \nfor the type of project project adaptation criteria are defined and a task set selector \nvalue is computed based on the characteristics of the project.  \n  \nProgram evaluation and rev iew technique (PERT) and critical path method (CPM) are \ntwo of the commonly used project scheduling methods. These techniques are driven \nby information such as estimates of effort, decomposition of the product function, the \nselection of process model, task  set and decomposition of tasks. The \ninterdependencies among tasks are defined using a task network.  \n  \nA task network or activity network is a graphic representation of the task flows for a \nproject. According to basic PERT, expected task duration is calcul ated as the \nweighted average of the most pessimistic, the most optimistic and most probable time \nestimates. The expected duration of any path on the network is found by summing the \nexpected durations of tasks.  \n  \nPERT gives appropriate results when there is  a single dominant path in the network. \nThe time needed to complete the project is defined by the longest path in the network \nwhich is called critical path. CPM allows software planner to determine the critical \npath and establish most likely time estimates . \n19\n7  \n   \nWhile creating schedule a timeline chart also called as Gantt chart can be generated. \nThis can be developed for entire project or separately for each function or individual.  \n \nThe information necessary for generation of this is Work Breakdown Structure (WBS \n\u2013 Making a complex project manageable by breaking it into individual components in \na hierarchical structure that defines independent tasks), effort, duration and start date \nand details of assignment of tasks to resources. Along with this most software  project \nscheduling tools produce project tables which is a tabular listing o project tasks, their \nplanned and actual start, end dates and other information. This with timeline chart is \nvaluable to project managers to track the progress.  \n  \nTracking the pro ject schedule can be done by conducting periodic project status \nmeeting, evaluating result of reviews conducted at all stages of development life \ncycle, determining the completion of defined project milestones, comparison of actual \nand planned dates, using  earned value analysis technique for performing quantitative \nanalysis of program.  \n  \nError tracking methods can also be used for ass essing the status of current project. \nThis is done by collecting error related measures and metrics from past project and \nusing this as baseline for comparison against real time data.", "mimetype": "text/plain", "start_char_idx": 322534, "end_char_idx": 327257, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "44cf0c46-fd99-4b63-a73a-e529582e8f90": {"__data__": {"id_": "44cf0c46-fd99-4b63-a73a-e529582e8f90", "embedding": null, "metadata": {"filename": "ware.pdf"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2903c3cd-8969-489e-8da5-879efdb715a1", "node_type": "4", "metadata": {"filename": "ware.pdf"}, "hash": "a775c0e2ac9adad67a980853a63a173d1ea908bfd597ba881dd3c9721bef47ad", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Q1. What is Software Engineering?\nA1. Software Engineering is a systematic, disciplined, and quantifiable approach to the\ndevelopment, operation, and maintenance of software.\nQ2. What are the phases of the Software Development Life Cycle (SDLC)?\nA2. The main phases include: 1) Requirements Gathering, 2) Design, 3) Implementation, 4) Testing,\n5) Deployment, and 6) Maintenance.\nQ3. What is Requirement Engineering?\nA3. Requirement Engineering is the process of defining, documenting, and maintaining the\nrequirements in the engineering design process.\nQ4. What is Agile methodology?\nA4. Agile is an iterative approach to software development that emphasizes flexibility, collaboration,\nand customer feedback.Q5. What is Extreme Programming (XP)?\nA5. XP is a type of Agile software development that takes effective practices to extreme levels like\ncontinuous integration, test-first programming, and pair programming.\nQ6. What is the difference between verification and validation?\nA6. Verification checks if the software meets the specified requirements, while validation checks if\nthe software meets the business needs.\nQ7. What is System Engineering?\nA7. System Engineering is an interdisciplinary field that focuses on designing and managing\ncomplex systems over their life cycles.\nQ8. What is a Use Case Diagram?\nA8. A Use Case Diagram is a UML diagram that shows the interactions between a system and its\nexternal entities (actors) to achieve a goal.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 1456, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/metadata": {"3732e28d-e71f-4d7d-ba7d-a0805f0b7ae4": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "a1257221-d282-4f8d-9947-3f700592d383"}, "1eebecd4-e59d-41e8-9723-20480aad9197": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "a1257221-d282-4f8d-9947-3f700592d383"}, "a1257221-d282-4f8d-9947-3f700592d383": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "63977760-4cb9-4924-a6d1-07d9b2a8075e": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "d1893b24-7b06-405c-a887-e8591aa2306f"}, "e376d566-7e18-434f-ad97-f5369a40fa94": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "d1893b24-7b06-405c-a887-e8591aa2306f"}, "d1893b24-7b06-405c-a887-e8591aa2306f": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "f61c7ded-b3b7-455d-a0c1-9e2b3b0369d6": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "bc7ed7cc-7917-4e07-a0dd-4185ada8977b"}, "c80a0de5-1294-4e89-92fa-67c9035600ba": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "bc7ed7cc-7917-4e07-a0dd-4185ada8977b"}, "bc7ed7cc-7917-4e07-a0dd-4185ada8977b": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "c4081bc3-47e7-433f-a19c-adc995d1e032": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839"}, "fa3b0e4f-c9b9-47fc-8b84-d2b48e602760": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839"}, "ec4c71db-8ce3-4f30-b53b-2d5a0fa26839": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "4095869b-ae76-4ce1-a48c-8d2cea737e51": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "30f94de4-5623-4e09-83be-fc5748776393"}, "10dbabd5-c32a-4e82-9108-24ff0cf8830b": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "30f94de4-5623-4e09-83be-fc5748776393"}, "30f94de4-5623-4e09-83be-fc5748776393": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "bbd6f0e3-164e-41f5-825e-558c047a08e4": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "640651a2-8207-4d3c-a7eb-08cca1fe6e99"}, "648d3b03-303b-42c0-a52c-e524e7ebef65": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "640651a2-8207-4d3c-a7eb-08cca1fe6e99"}, "640651a2-8207-4d3c-a7eb-08cca1fe6e99": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "08cfd150-e98f-44ab-94c6-4e1bfe9395e1": {"doc_hash": "bcf4ce1dc9ce4231959b3484783a9d46ba0c240e088f5eb8f981cde386e6df04", "ref_doc_id": "be734eda-b84a-4c55-8855-185ae5f36dfb"}, "be734eda-b84a-4c55-8855-185ae5f36dfb": {"doc_hash": "a775c0e2ac9adad67a980853a63a173d1ea908bfd597ba881dd3c9721bef47ad"}, "1ba895ec-efea-4220-b6ef-80ad29f07348": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "e2c783cc-a444-4050-aedb-cf5a274932ab"}, "ab1d3eda-24de-4fe2-8ba1-8ee394ff28b5": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "e2c783cc-a444-4050-aedb-cf5a274932ab"}, "e2c783cc-a444-4050-aedb-cf5a274932ab": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "8ce08d25-c8d6-4150-b3a8-747199a09f8a": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "493bcda4-6b99-4d77-98be-ea4b685e845c"}, "66fd7445-28f0-451d-9407-fb6efebdf6bb": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "493bcda4-6b99-4d77-98be-ea4b685e845c"}, "493bcda4-6b99-4d77-98be-ea4b685e845c": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "1210b008-b4f8-48e9-8c64-8f950f3d84de": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "c0cf3f91-02bc-436b-8add-520fe657819b"}, "ff210928-9d06-4151-bc13-7dd5e853c4ee": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "c0cf3f91-02bc-436b-8add-520fe657819b"}, "c0cf3f91-02bc-436b-8add-520fe657819b": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "350c5285-fc42-4e2e-bc01-d38d5a35d94e": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "4594b5f2-a220-4618-875c-09d449782311"}, "4e0373b6-c46f-4c03-ba3e-4072260ab853": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "4594b5f2-a220-4618-875c-09d449782311"}, "4594b5f2-a220-4618-875c-09d449782311": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "e24ba7f6-46a9-4dda-9def-45a67721b786": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "c6c7287d-21fb-4948-9b52-180c137318b1"}, "69b87dd7-bf49-4d1f-aea6-67e65073cc59": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "c6c7287d-21fb-4948-9b52-180c137318b1"}, "c6c7287d-21fb-4948-9b52-180c137318b1": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "d10ba7c5-d413-4a20-ae22-9ad2dea4a089": {"doc_hash": "a3f4d70a88a17c76f220e074d8dd251aac2e4c0a1715fb14f7647c676e4521e7", "ref_doc_id": "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7"}, "8e2ed64f-443a-4ccc-b5a0-1db5f43952dd": {"doc_hash": "4c373a1dda082ad4b1f5b72bef73fd856dd79e0064a817bf503875525906dce6", "ref_doc_id": "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7"}, "6a1ac7bb-497d-4da0-a101-81d4e3c9b3e7": {"doc_hash": "934f8ca050456e03c9531d81cc4555b6abe4f883c3d180f6d739f8d346ab4af2"}, "e917b414-e840-4a38-bed9-25f54ed4775c": {"doc_hash": "0f719e162a73e966b7633fa6714cc9b8526bb7a24c7ac555d2c6d4ff1159d031", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "9d406574-b8a5-497e-8091-fe644ddc6382": {"doc_hash": "7e249cdb42f4f885a9d658a8d891a88557d6d908a006240af964743aac617c84", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "6cebead5-65b6-4710-b810-e63eab959a54": {"doc_hash": "682cdf13bef3d73bc631be28bdc09b887609da7619d1d0b790dc240deb19db02", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "77acaa98-3d2f-4ac1-8f60-e59a74188582": {"doc_hash": "a72a9979ec82634e2e3a2e3cc6129bb1ee62ba82f27060ba9f928d199829272f", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "73fb3584-8e07-4415-a94e-2b602f4e58cb": {"doc_hash": "3c4309adb267750364d7c6e6c9fcb96d9db00cff18711244ab382b36733fe415", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "25bb1c08-54d7-408c-81c5-f8ffe1df9dc9": {"doc_hash": "f4fe093d05e935c4b86db62e17e432eb802826ff6ca06b4cd9a86028348e1c00", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "0de9a1fd-69e8-4769-9267-c0a2b8fafd56": {"doc_hash": "37ee44dec0a027e0d597ceff5bd6e401d2cbe1c3aee637fab21c2683d71c4190", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "a334d951-62b2-4ae8-96cd-9be3f6598c45": {"doc_hash": "1c5f9951b2cdbd54e59c678916a744b54ac3cae2b8eae42ac90ed1535f2867e2", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "bf32291c-7ee0-4ade-9040-45e016fa7baa": {"doc_hash": "05eb74e4165685ae01b66be80509343ed00bd64586b140611ab15bb73cb7c7d8", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "fcad9eb6-d3df-47f4-8035-e70c734fbe4e": {"doc_hash": "a5710797cc3bc01de2e185abe042d2394867b3342a57565f18b2814268697610", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "a725505a-3100-4b26-83eb-3cb7f2c90674": {"doc_hash": "13a52da9974709524143616b7f224f9bc6290c3362956a050c8f1edd581a1800", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "01e80f2f-e744-4056-b3f7-a2c0862f0815": {"doc_hash": "4ca71cd5892e654d7a8150060e6612d5298bf1a4793c4801a5b8fb95ddf3e0be", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "160e78ad-fb8d-42c7-9622-41486dfc6908": {"doc_hash": "1473cb945c74b2a5df2451845abc4076f8dc8968ddcfcd61d8171a7dfcc7a424", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "f7fb867d-4499-454f-9938-9bacfa5f2256": {"doc_hash": "670d73a3e77d590234339bd9339b91db096c5372428468a74c35243cdb83996a", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "f0c5977c-67f9-4f97-82b9-f8d1681f4813": {"doc_hash": "5d83ce4054fbd49474bc4c5d58ed09b5fd7123dd7b25fb2994a85d33bb4e53a7", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "af6c1554-9f7b-4f1a-8866-22b7d5c2177e": {"doc_hash": "0d1254200ac6991b096686f931ca3391fcbedf31a0e58b1bad5bf8f46bac57d8", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d485086a-deae-46f3-83f6-836210f8b21a": {"doc_hash": "b8ad49c9b6e8012ba7d26da5e6788c644f5a4857615b29bc51c2331c3ac8c87a", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "8939d10d-1fb1-4adc-83f7-677621637a6b": {"doc_hash": "fe2d099d702594a91a3471976817b1ecfd52af385e4d6a489152daee790576a3", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "f7b6ff9d-a81a-468e-a544-e05022f8f79f": {"doc_hash": "62102dbdab1daf92715a6aecd63e90f55cbb82e2fd053863e07bf8498313c25c", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "fb5a8d3e-5fe3-4fbd-ae5d-3b4039595913": {"doc_hash": "31985293d096cb92fff8a0bdf16350aabe9ff4779eda3ba1d5e945b1050d619b", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "1563777f-7a75-49a6-84f3-caa1ea5d6419": {"doc_hash": "38399bbbef53689e72749086a51e47f3c13f1fb8cf2bf47f56b5733e47edb0f4", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "73383c8e-2ce9-4d11-acd6-66f1927b9f79": {"doc_hash": "ce44e3fac3d7794966ac77ac063159d67b5b26480d2625891c83c87bce5921af", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "31c69716-dd50-4e06-9d48-9721e28311ce": {"doc_hash": "4cccd09a2a1f7e00faefb291e4bde4d6ffbb13c46aa3f42284c0a36f6deb8111", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "99dc1d3a-ad27-4f99-9792-0d80f2a044a4": {"doc_hash": "5e51bf906d5d9c6067852301dba86be43778c26e276bc012a008c51d01f28a05", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "84523f3d-015b-433e-914f-fcef694a1afa": {"doc_hash": "e79f502118a27ebf8fe2178318d0659172c36be969ca6768ab29401531c0f5f6", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "73afbf76-da3b-4e43-8d47-d567d3bce4d5": {"doc_hash": "dd3e1693c3191fd3fb2e2391f427f0a25a35054185d7686e234eda5e0990d5e2", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "b16dbabf-14bc-4c5b-8e4a-40b81cf29048": {"doc_hash": "1539dc9a528c2231bc272b2ad98a2bbe266a29ecebffafadfb9f9f35998e327c", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "ec67c4d3-66b9-4f24-9c58-57113ad812ea": {"doc_hash": "504b40fec89ea933378344346ef339877a572f054fe24b0a3aec0d2e9626d9dc", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "564f3a27-50c9-4436-b690-b44ba03eb60f": {"doc_hash": "971f11800e73bd72cabe5f3bdf6d9c64d840301626ac8c1d5fd56fb2a026ed67", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "2a215ff5-a4ee-4e94-82a9-25cf0c242fe3": {"doc_hash": "e764b5e9f0f7f78964da5dabd153cb31b662185ca7271ebe2f66a562e9cb60ba", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "371aba88-da90-4d25-9654-7dbdfe3f2c1e": {"doc_hash": "59f7c91c310c7f8f10f122916d573d568bdc95c7fafb77294c6279a60330e150", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "7072d991-c0d7-4229-826e-93ba7378a855": {"doc_hash": "8017b308972112b43aa7685e0181c1ad7f0b5ed99031ee9d5ab1cd85692da219", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "1afc1302-b29a-4eee-bfe4-0f78fb16c1d0": {"doc_hash": "f66508c77706d5c2aa400fbdc2135d06065a9ddcfc1bae3b61e2dd367e0c0231", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "ad683f83-3cba-44bc-af68-d626fc046445": {"doc_hash": "aa62d66d333e186728e52f3c6b56798a63490f2a56d2c102a023da445ea499f4", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "3020acea-f8c9-4c84-af0e-018801cbd300": {"doc_hash": "055a7a3243dcf551e9e93e6ddc86ded3bcb58acad7f4c9a6d399704fa0277e66", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "ffd91dc4-ddd5-446a-94d4-ff98779c3baf": {"doc_hash": "0388b7a7b7f53777ed16aad8d1cb230d55c14d66d775cf28b2958ad3c9be0ef6", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "bd0654c7-ca1d-498d-af99-bb5bf48e6e1c": {"doc_hash": "e0687df0c0ab5d4ae253bd890086873f2939b9c3cace9a078c8af625147453f0", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "67e8b1f3-a0f5-4982-b46d-b66ec4e86a4b": {"doc_hash": "1484188a36d1b749d2241b485fa1942ad48ecd726715817b9df3808d9e5b511e", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "eea8d6e7-9125-4c8f-be4a-f13c35dd0708": {"doc_hash": "fbea3915c54bc62fb213e58b0d2a5ea21a7190271b1d714c2aef7498a16dd101", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "e4356756-edb8-4cae-8303-9b552d0cb3ac": {"doc_hash": "b28f84dc407ed8de90f61b1efaac968cad231fb0edc000da53aa1f53e6f3fb31", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "471b361c-eb0b-45d8-8153-818941ad81e9": {"doc_hash": "e48ac81b2c7c0e441f857e5d70a85f71fdb2a06497534e69e12ab24be975a53d", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d97dd5e9-2de7-4dd2-a1de-78a12b2114ea": {"doc_hash": "834648ec46c47459407f994576c66219611465bccad7812a6253fc202258eb40", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "b6750083-b00d-4023-aa7d-371978f91439": {"doc_hash": "ea2d6c1d79ce683617c29501ede00e1bf24a895b575bc21dc387872972b86082", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "abbb2bcb-0df0-4143-a14c-7895a15e889e": {"doc_hash": "aa176b66552dd242d974c2210589f45afab9762d5b7f3ea1f37e91c700789665", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "908c1dc9-6dfa-4a90-aab0-5c3163538fe9": {"doc_hash": "62355cebffd58476903a0a1bcc3db9d56c93e79808bf2ae5ab37aa65eb71736f", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "b13c1f4e-ef5e-4017-9132-7cf57795c300": {"doc_hash": "39d30d6fd2270f8a081a8e5f80c6235af5ac43dc5ba7cc584f863d614aeac27f", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "4878e34e-60dc-42fd-b295-149174ce612d": {"doc_hash": "6cd7323574544b7ce12abec9e6eb961a1ba73855cdf0054ed5658ee8e43f3f15", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "90edd788-6a51-465d-ac7f-43cdb03858bd": {"doc_hash": "1bca58a9c685b44a834715982b1b2db307be52bb06590fa1559fb9c733f4cb96", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "63e5606f-f066-432c-8d9e-545a8360819e": {"doc_hash": "9a6c603604feeb5574268409feb105a7e3b6bf73cf83a492060aa0d1aff2789b", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d70c5e94-a178-4781-9306-72327ddac925": {"doc_hash": "af1713175d7bcf335daed6c26006f2eee7eddc32ea79f576da13e4fa8e3a641c", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "eb04d43a-74bd-444d-a83e-40b0b31571ab": {"doc_hash": "325c34d816948c15b0bb11df7f1500f22ce97b10e6f866dd4c16fbd9c321971b", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "62fdce68-032b-4fb6-8416-eb8e80f6355c": {"doc_hash": "2956aefbf950b9a1a8258d096691dcb1830eb646ab6c5ae6fe7b29a3b7b005c7", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "78358f6b-7a4e-4985-b1c2-e1a0faa4c691": {"doc_hash": "5d8a3f909251ca6f911f7aaa9bb5b6ef51e84b1d663971a6430d2c85b053fec1", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "647fb88d-c014-48c8-876e-b1463adba515": {"doc_hash": "86627f033a93e2951cd70ff76dd9c37751bef3d22d99c4974a99570126fa5c6d", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "3531adac-7db6-4632-8bbb-6279d07252eb": {"doc_hash": "c69938e7dda1c57c9f96112850c885565603603f6a80e80a6aab13b2839b21f2", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "8671b2f3-590c-460c-accd-6961142fcb40": {"doc_hash": "f2222376127139da4d69523ad805f688ba4dea8c1f51396908c565dcaafa7033", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "48540507-3861-4dfc-9e89-09d8b43532ab": {"doc_hash": "23d17da4199b7c0f9e12513129cd7d8729db799e502adba8ff202877c4f749c5", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "684dc86a-1b2e-4aaa-bb47-70e07cf9f597": {"doc_hash": "91c99fb23e0ff5027386d0d01911bb84117234203e2719ebf60fe2726850269d", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "90d1ac3b-21f8-40e0-abf3-fdd93eb842ac": {"doc_hash": "fdefa4ede38d28856f552a7484d65692ba6e14eeab0cf48d326fbf8b2a120d84", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "965a72af-3845-49b1-b1d5-21712f0d8d8e": {"doc_hash": "62ded8caa9380ab627eeeae6e95ba11cc09485b244c807ec92cb8097a1f6e156", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "97811389-4a6d-4f81-affe-a73ac5587a08": {"doc_hash": "dd3a43b46c767ec6fe2a1ff44def6eaf45126d9548a2be3aca32ce8d1a129649", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d6cde2b4-2390-4003-8c9f-f6a2f529f445": {"doc_hash": "084908c5d2d015141f28475e664e40ad8dedd8e6f4140772bd55e33eb729e6b6", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "3b673e4d-93db-4704-bbaa-ff1d467560a8": {"doc_hash": "67a4fe4a04edb9f868a6a0ada6b1efab5171e56b9c6c81d0efa0b53f6d8a7549", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "0c06a881-d356-48e1-9dbf-319e1489b5ca": {"doc_hash": "7dc9789d03cce144a260e4f621b6df628f019a8e30a27cab9b88cce8520c2b2c", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "4d278904-a78c-41c6-bac9-7a61c4c21ab4": {"doc_hash": "a51df3b05f0f765c48b9d437ae174a337cabb886ab38bf64c32c2641969f7ec3", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d6dd5806-48d3-4c1c-acd5-e196c69ec6d9": {"doc_hash": "4f993486bc2a86fd31de6b0bd8319c407c15f08e6523f805abad38cf8fc53f95", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "7f263947-7383-43a2-be22-39b99cb5a91f": {"doc_hash": "c966e427d085c9a2caab447d5675748baa63e5df757c38341635322d8571ab91", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "9a3e3c0a-b1e1-4eaf-984b-8fe8af24188c": {"doc_hash": "efd32fcda506be99f2dd1fe661b25171ad71dac6119c0082c1e8c0788b334422", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "1e029456-2349-4129-8f61-4067cd0657d6": {"doc_hash": "83f1d8353dfd3c7ecbe70e1fcd2191e0cab2ebbe569e4d1f7e7c87ad42f59ebc", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "4f3f16fc-30b8-4f63-851c-4dfc63d75f5e": {"doc_hash": "c11299f4a45f5c7c8ed529211e3b84ff301c5c5e11297e7a3ad1280a1bfd9c59", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "0c1df18c-5d92-4290-8cfe-480f9066a379": {"doc_hash": "e1f209c684b25796bbd2b899490499676673fa27c263cb26c2033a1675828cbc", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "6f61084d-df44-4d97-8ff7-2105e6b1e8d2": {"doc_hash": "ed7460a1470b3dd0b4f73fce5b21ded18ea69c758c58f773395b27402982c804", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "8850614d-dd1b-4beb-8219-adf93321ba24": {"doc_hash": "ffac73dcedf8f8ee1c16569921dea0662ddfdce45dacc642e155d5d96de30c34", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "52755f8f-e712-4db8-ac55-7cb8fdcb1fcb": {"doc_hash": "30b02c904d596e47abe590a12cb8f31da325de8874d8b3006cde793dd657c7d3", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "787699e2-a516-424a-89d0-03763cc2c216": {"doc_hash": "3ec7c912bda7dacb6b90a101fa7316df83e230eedeaa79fda62759ace6deadda", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "8cd4e341-8b13-46d8-bed4-6a984d0cb372": {"doc_hash": "8901444bd52f702b303800a4693ba434172c1c15afdbb32115f0f3bcd40cd4ee", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "835f4d37-14db-4be5-bcf9-34bd76c0663d": {"doc_hash": "978842d2215f7bababf1b93b575e0e0f717e377a4df32b93c8a02252284af4f8", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "58b3d51c-d3ed-4721-b64b-6a5f3ae261f8": {"doc_hash": "5c30b645608ce7d926670a09bd0deecdab039bc5b07d250437d42980529f2e87", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "0e003cbb-0a63-4b33-962e-2ce986e02e32": {"doc_hash": "ed0e0912ef20cffb7d368be17f10ab4319950ff385492cdd8b8a40152846aaa0", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "8c135d63-f222-4db6-baaf-12f3a9e3c452": {"doc_hash": "1451f29b153b2ef252e3b71b632c00ce4b5d974f462d14ac7bfb6528de64a2c2", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "0f3f7c13-4ef9-4ea4-9c06-6861f774ee2f": {"doc_hash": "ad91997808a98ed96b181dafc5a209d010e0805775696252dcb19f5160b116d8", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "a5b6456b-9069-4290-af6b-5604ef801d32": {"doc_hash": "17e47ea1b2c74e3d7a8e856d6e4d0dd4a9d6a74b8c577cdf66e8adecc4394319", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d0d23288-1f8f-4206-b143-2d27443330a0": {"doc_hash": "bdaa58c7cf88b6cd0ec2660def6ef4a4df66d0c016951b986860440e5e49bed3", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "bf2ceb5d-f329-47ac-87f2-eef545fbb54f": {"doc_hash": "ebc2aac680e23336193f4ec9e535b359d109ba6f800db7820d56637069dd72c0", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "4f25b662-1891-4305-9079-4ab2e2170813": {"doc_hash": "a8e7eb0f54bae5f6a2e19dc72923e19d56c1661d4398d14cd1aa5c9bc613a4fc", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "24375d55-a978-4c4e-90a4-d8beb35572bb": {"doc_hash": "69df9f0f0325be7955ed93d047bd26faea4a4b0a40278af989bb822bc148769e", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "36d409f7-601b-47d5-9472-deefdf8e3697": {"doc_hash": "7fe6c850d52c337eec16bd6e1dc9b26ebc7bb91222349f7b94ecdcc2f7fde6c7", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "9b817c53-525b-4cb5-990f-eb8332c6627e": {"doc_hash": "02e8e444ee4aea9c1da8a5c74a63583d86f37b8bb9aa23d4a9a63ab0375e858b", "ref_doc_id": "d8e2994c-91a7-499a-ad27-2d6b07280208"}, "d8e2994c-91a7-499a-ad27-2d6b07280208": {"doc_hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2"}, "75516d67-96c6-43da-b89e-8e4d52e6a546": {"doc_hash": "0f719e162a73e966b7633fa6714cc9b8526bb7a24c7ac555d2c6d4ff1159d031", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3fb4b9af-dd5c-49d4-8e7e-18845b6d3bee": {"doc_hash": "7e249cdb42f4f885a9d658a8d891a88557d6d908a006240af964743aac617c84", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f0cf1cb0-3124-4086-92a8-42e9a44bcda6": {"doc_hash": "682cdf13bef3d73bc631be28bdc09b887609da7619d1d0b790dc240deb19db02", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e9400b64-c39b-4322-9e3a-833b07693f82": {"doc_hash": "a72a9979ec82634e2e3a2e3cc6129bb1ee62ba82f27060ba9f928d199829272f", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "c5a590e6-1666-45e9-8bac-80410e976250": {"doc_hash": "3c4309adb267750364d7c6e6c9fcb96d9db00cff18711244ab382b36733fe415", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "6284572f-7815-45df-a826-663f5593a7d1": {"doc_hash": "f4fe093d05e935c4b86db62e17e432eb802826ff6ca06b4cd9a86028348e1c00", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "bee753c9-767e-4a9b-9c26-be8c2c94c0e5": {"doc_hash": "37ee44dec0a027e0d597ceff5bd6e401d2cbe1c3aee637fab21c2683d71c4190", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "b48e06aa-df5d-46d3-8c6e-d5db99f4b57a": {"doc_hash": "1c5f9951b2cdbd54e59c678916a744b54ac3cae2b8eae42ac90ed1535f2867e2", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "06607e52-c67e-4b9b-8888-d67eaf66b14c": {"doc_hash": "05eb74e4165685ae01b66be80509343ed00bd64586b140611ab15bb73cb7c7d8", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "bdbc472f-82ba-42ce-a8bb-1ad3e2c8ad04": {"doc_hash": "a5710797cc3bc01de2e185abe042d2394867b3342a57565f18b2814268697610", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3d35f95d-594c-42c8-8a2c-7c6f3f8b3760": {"doc_hash": "13a52da9974709524143616b7f224f9bc6290c3362956a050c8f1edd581a1800", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e8fe1fc0-cc49-44f2-9bd9-7c030716d637": {"doc_hash": "4ca71cd5892e654d7a8150060e6612d5298bf1a4793c4801a5b8fb95ddf3e0be", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f126d84f-d078-45b5-ac88-cc45423d1ad3": {"doc_hash": "1473cb945c74b2a5df2451845abc4076f8dc8968ddcfcd61d8171a7dfcc7a424", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f5723f22-83cc-491d-b119-a74c448dceaa": {"doc_hash": "670d73a3e77d590234339bd9339b91db096c5372428468a74c35243cdb83996a", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "29c4130d-4a8f-42c3-9f6c-83eee33e9c77": {"doc_hash": "5d83ce4054fbd49474bc4c5d58ed09b5fd7123dd7b25fb2994a85d33bb4e53a7", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "777ebdba-4ab9-4e95-a585-c670b16d9353": {"doc_hash": "0d1254200ac6991b096686f931ca3391fcbedf31a0e58b1bad5bf8f46bac57d8", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "8dc30a44-aaae-4dd7-a506-4fc6201a4b7e": {"doc_hash": "b8ad49c9b6e8012ba7d26da5e6788c644f5a4857615b29bc51c2331c3ac8c87a", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "a759a57f-61f7-4325-a448-57876fef0e48": {"doc_hash": "fe2d099d702594a91a3471976817b1ecfd52af385e4d6a489152daee790576a3", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3b40ad02-ea55-4fc5-9749-5002848e5e89": {"doc_hash": "62102dbdab1daf92715a6aecd63e90f55cbb82e2fd053863e07bf8498313c25c", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "19f001be-31d3-4844-88e7-a2d0e988d470": {"doc_hash": "31985293d096cb92fff8a0bdf16350aabe9ff4779eda3ba1d5e945b1050d619b", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "9bf26669-ce55-49ba-90fd-b14ff8bd7f98": {"doc_hash": "38399bbbef53689e72749086a51e47f3c13f1fb8cf2bf47f56b5733e47edb0f4", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "71fae67f-ea78-4dcc-aa1a-faaccf0ea2b0": {"doc_hash": "ce44e3fac3d7794966ac77ac063159d67b5b26480d2625891c83c87bce5921af", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f30f2602-a16c-4487-8c4b-bcafab8959b4": {"doc_hash": "4cccd09a2a1f7e00faefb291e4bde4d6ffbb13c46aa3f42284c0a36f6deb8111", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "b1a9726d-ec99-4834-970d-5f151350e4e7": {"doc_hash": "5e51bf906d5d9c6067852301dba86be43778c26e276bc012a008c51d01f28a05", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "b7dc2c22-2136-4b93-9585-28ed9a27df46": {"doc_hash": "e79f502118a27ebf8fe2178318d0659172c36be969ca6768ab29401531c0f5f6", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d51d616a-59b2-446e-a90a-62b5768c9948": {"doc_hash": "dd3e1693c3191fd3fb2e2391f427f0a25a35054185d7686e234eda5e0990d5e2", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "a7f9db35-7382-42cf-bf7d-9b1c44ea6e32": {"doc_hash": "1539dc9a528c2231bc272b2ad98a2bbe266a29ecebffafadfb9f9f35998e327c", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f910cc61-52c5-4ad7-b537-a5033fcddf73": {"doc_hash": "504b40fec89ea933378344346ef339877a572f054fe24b0a3aec0d2e9626d9dc", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "ca460780-de4d-4596-abca-57b8306cce6f": {"doc_hash": "971f11800e73bd72cabe5f3bdf6d9c64d840301626ac8c1d5fd56fb2a026ed67", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d8d48aae-3f6f-4321-bbdc-689c17b657af": {"doc_hash": "e764b5e9f0f7f78964da5dabd153cb31b662185ca7271ebe2f66a562e9cb60ba", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "04d37175-a2ff-4c7f-963c-0b0566728f32": {"doc_hash": "59f7c91c310c7f8f10f122916d573d568bdc95c7fafb77294c6279a60330e150", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e3fe43ec-7504-4288-8cb1-4ccf19e23ac3": {"doc_hash": "8017b308972112b43aa7685e0181c1ad7f0b5ed99031ee9d5ab1cd85692da219", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "fffe0ccd-64b6-43ec-ab24-6f78ad5fd91a": {"doc_hash": "f66508c77706d5c2aa400fbdc2135d06065a9ddcfc1bae3b61e2dd367e0c0231", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f4504b97-2ace-4b7f-8028-5f7955354fa6": {"doc_hash": "aa62d66d333e186728e52f3c6b56798a63490f2a56d2c102a023da445ea499f4", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "f38f9e86-f2ef-40c3-9f3c-d4fd8adc9d76": {"doc_hash": "055a7a3243dcf551e9e93e6ddc86ded3bcb58acad7f4c9a6d399704fa0277e66", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "80528e67-82c1-4c11-bb96-2379ea8e806c": {"doc_hash": "0388b7a7b7f53777ed16aad8d1cb230d55c14d66d775cf28b2958ad3c9be0ef6", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d47afd40-e451-438f-b54e-5a7e3b201736": {"doc_hash": "e0687df0c0ab5d4ae253bd890086873f2939b9c3cace9a078c8af625147453f0", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "6cdc3eec-5d85-4b4b-94d9-ffc1a5d6c427": {"doc_hash": "1484188a36d1b749d2241b485fa1942ad48ecd726715817b9df3808d9e5b511e", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e2c603ea-be17-435f-85f0-669563edc427": {"doc_hash": "fbea3915c54bc62fb213e58b0d2a5ea21a7190271b1d714c2aef7498a16dd101", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "912bf6d7-38ff-4919-9a08-dc5a12963b40": {"doc_hash": "b28f84dc407ed8de90f61b1efaac968cad231fb0edc000da53aa1f53e6f3fb31", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e4c44a77-716c-48e0-bf88-d2945929a9a6": {"doc_hash": "e48ac81b2c7c0e441f857e5d70a85f71fdb2a06497534e69e12ab24be975a53d", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "4baec4eb-bb89-4e9f-92eb-d560c1fe0255": {"doc_hash": "834648ec46c47459407f994576c66219611465bccad7812a6253fc202258eb40", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d1e38ebb-1373-4b28-bd0e-5a468441430e": {"doc_hash": "ea2d6c1d79ce683617c29501ede00e1bf24a895b575bc21dc387872972b86082", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "1da6a96c-8932-4b3d-a98a-1548d255fcc4": {"doc_hash": "aa176b66552dd242d974c2210589f45afab9762d5b7f3ea1f37e91c700789665", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "36e52a11-8c7d-4c84-aa6f-a87b09c220c4": {"doc_hash": "62355cebffd58476903a0a1bcc3db9d56c93e79808bf2ae5ab37aa65eb71736f", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3478af1b-c91f-4cbe-8293-10136e7c4e2e": {"doc_hash": "39d30d6fd2270f8a081a8e5f80c6235af5ac43dc5ba7cc584f863d614aeac27f", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "84302560-fc91-4f75-961e-51a723ec130b": {"doc_hash": "6cd7323574544b7ce12abec9e6eb961a1ba73855cdf0054ed5658ee8e43f3f15", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "39c3b979-b7a0-43c6-b06a-92172d3c1d6c": {"doc_hash": "1bca58a9c685b44a834715982b1b2db307be52bb06590fa1559fb9c733f4cb96", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "7bc0102f-be1d-4787-a7c5-5dde3d0527c7": {"doc_hash": "9a6c603604feeb5574268409feb105a7e3b6bf73cf83a492060aa0d1aff2789b", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "94351431-31da-41da-9a05-fac85280d386": {"doc_hash": "af1713175d7bcf335daed6c26006f2eee7eddc32ea79f576da13e4fa8e3a641c", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "e7c345aa-3114-4a76-94c1-6df680d972d7": {"doc_hash": "325c34d816948c15b0bb11df7f1500f22ce97b10e6f866dd4c16fbd9c321971b", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "c4f9b63a-d006-4ecf-beed-4648424b17f1": {"doc_hash": "2956aefbf950b9a1a8258d096691dcb1830eb646ab6c5ae6fe7b29a3b7b005c7", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "7448f40b-b826-4777-a93c-cba0253fb59f": {"doc_hash": "5d8a3f909251ca6f911f7aaa9bb5b6ef51e84b1d663971a6430d2c85b053fec1", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "716ebf8f-074c-4c50-91e4-39cc655b3c10": {"doc_hash": "86627f033a93e2951cd70ff76dd9c37751bef3d22d99c4974a99570126fa5c6d", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "a4829875-4df5-4215-bdc3-21c4dbcc8d88": {"doc_hash": "c69938e7dda1c57c9f96112850c885565603603f6a80e80a6aab13b2839b21f2", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "73184b2c-ebcc-4b0c-b476-d52ea3ddc39d": {"doc_hash": "f2222376127139da4d69523ad805f688ba4dea8c1f51396908c565dcaafa7033", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "0bfc9fd9-2fd1-4288-8add-d5869e074b74": {"doc_hash": "23d17da4199b7c0f9e12513129cd7d8729db799e502adba8ff202877c4f749c5", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "2d35f180-3f10-4e08-9917-3b0fe4587833": {"doc_hash": "91c99fb23e0ff5027386d0d01911bb84117234203e2719ebf60fe2726850269d", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "cac64d6e-536a-4c25-b078-89bd17dfef59": {"doc_hash": "fdefa4ede38d28856f552a7484d65692ba6e14eeab0cf48d326fbf8b2a120d84", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d06932a8-b777-482b-9c1c-2d42fb497a46": {"doc_hash": "62ded8caa9380ab627eeeae6e95ba11cc09485b244c807ec92cb8097a1f6e156", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "4a7089d1-ad69-4272-a3b9-000029dced56": {"doc_hash": "dd3a43b46c767ec6fe2a1ff44def6eaf45126d9548a2be3aca32ce8d1a129649", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "03b32e81-c345-498d-aa38-548d034c71c7": {"doc_hash": "084908c5d2d015141f28475e664e40ad8dedd8e6f4140772bd55e33eb729e6b6", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "7955dc08-67b9-494a-b986-394ceab886fd": {"doc_hash": "67a4fe4a04edb9f868a6a0ada6b1efab5171e56b9c6c81d0efa0b53f6d8a7549", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "5fafacf9-f6ce-4140-a5d8-a6b865f91762": {"doc_hash": "7dc9789d03cce144a260e4f621b6df628f019a8e30a27cab9b88cce8520c2b2c", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "174d8f90-db6d-451e-9c85-a550145bb064": {"doc_hash": "a51df3b05f0f765c48b9d437ae174a337cabb886ab38bf64c32c2641969f7ec3", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "214472ca-989c-40f7-82ed-9b57efb4be8d": {"doc_hash": "4f993486bc2a86fd31de6b0bd8319c407c15f08e6523f805abad38cf8fc53f95", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "94bcb1a4-5db6-46f4-a9a1-8b0014dbbc7f": {"doc_hash": "c966e427d085c9a2caab447d5675748baa63e5df757c38341635322d8571ab91", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "b272cead-cccd-4b2a-a02d-4503b1471c0a": {"doc_hash": "efd32fcda506be99f2dd1fe661b25171ad71dac6119c0082c1e8c0788b334422", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "8fd746b2-4f60-48bc-81c2-493d1162296e": {"doc_hash": "83f1d8353dfd3c7ecbe70e1fcd2191e0cab2ebbe569e4d1f7e7c87ad42f59ebc", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "8cfb2b9c-859b-4436-947d-7b1620d50f87": {"doc_hash": "c11299f4a45f5c7c8ed529211e3b84ff301c5c5e11297e7a3ad1280a1bfd9c59", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3260bd06-1d45-4647-b57d-4eba192c5dce": {"doc_hash": "e1f209c684b25796bbd2b899490499676673fa27c263cb26c2033a1675828cbc", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "20fc74ca-3f29-4f9a-856c-72f9009a628b": {"doc_hash": "ed7460a1470b3dd0b4f73fce5b21ded18ea69c758c58f773395b27402982c804", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "bf63c7a4-df67-4efe-b646-b868485d22e9": {"doc_hash": "ffac73dcedf8f8ee1c16569921dea0662ddfdce45dacc642e155d5d96de30c34", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "791b77f1-2ca2-486c-bd66-71802f54fc54": {"doc_hash": "30b02c904d596e47abe590a12cb8f31da325de8874d8b3006cde793dd657c7d3", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "d575640e-ff6e-4f34-837d-306d6513c110": {"doc_hash": "3ec7c912bda7dacb6b90a101fa7316df83e230eedeaa79fda62759ace6deadda", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "9e195c5d-fe0e-46fe-90e8-20296a8a6060": {"doc_hash": "8901444bd52f702b303800a4693ba434172c1c15afdbb32115f0f3bcd40cd4ee", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "9b851148-f6e6-457d-99ef-c6b72f9d5dbf": {"doc_hash": "978842d2215f7bababf1b93b575e0e0f717e377a4df32b93c8a02252284af4f8", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "a8425034-f811-4497-97b0-743a9adde769": {"doc_hash": "5c30b645608ce7d926670a09bd0deecdab039bc5b07d250437d42980529f2e87", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "98784a66-39d0-4b81-87fa-d17cab9bc243": {"doc_hash": "ed0e0912ef20cffb7d368be17f10ab4319950ff385492cdd8b8a40152846aaa0", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "62d1a6fd-dccf-46be-9ac6-3480e0e17366": {"doc_hash": "1451f29b153b2ef252e3b71b632c00ce4b5d974f462d14ac7bfb6528de64a2c2", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "8f3febeb-9e08-4aa9-bc81-718cc5a9aaa3": {"doc_hash": "ad91997808a98ed96b181dafc5a209d010e0805775696252dcb19f5160b116d8", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "7575763a-6c7c-43b2-ab8c-c338f3d2c814": {"doc_hash": "17e47ea1b2c74e3d7a8e856d6e4d0dd4a9d6a74b8c577cdf66e8adecc4394319", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "6d2b4279-ac2f-4ae4-821d-a15d1657c534": {"doc_hash": "bdaa58c7cf88b6cd0ec2660def6ef4a4df66d0c016951b986860440e5e49bed3", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "105c5646-761f-45e7-8258-7cedb52c3476": {"doc_hash": "ebc2aac680e23336193f4ec9e535b359d109ba6f800db7820d56637069dd72c0", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "3e149501-6908-4ec1-8a3e-a7d0605e0bbb": {"doc_hash": "a8e7eb0f54bae5f6a2e19dc72923e19d56c1661d4398d14cd1aa5c9bc613a4fc", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "41153092-1ab6-4b2f-a285-996a158b0fd1": {"doc_hash": "69df9f0f0325be7955ed93d047bd26faea4a4b0a40278af989bb822bc148769e", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "9dc6567c-8023-4a0c-9003-60c93a5e38a4": {"doc_hash": "7fe6c850d52c337eec16bd6e1dc9b26ebc7bb91222349f7b94ecdcc2f7fde6c7", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "eb97c706-3f5b-43c3-ad73-15b59b6a0f10": {"doc_hash": "02e8e444ee4aea9c1da8a5c74a63583d86f37b8bb9aa23d4a9a63ab0375e858b", "ref_doc_id": "ed0eb801-6a0c-4316-8882-4e98a3e4d178"}, "ed0eb801-6a0c-4316-8882-4e98a3e4d178": {"doc_hash": "d83b1422aa89e4b128fe765071d5a5ab195a5bed149f03d06220677b785135e2"}, "44cf0c46-fd99-4b63-a73a-e529582e8f90": {"doc_hash": "bcf4ce1dc9ce4231959b3484783a9d46ba0c240e088f5eb8f981cde386e6df04", "ref_doc_id": "2903c3cd-8969-489e-8da5-879efdb715a1"}, "2903c3cd-8969-489e-8da5-879efdb715a1": {"doc_hash": "a775c0e2ac9adad67a980853a63a173d1ea908bfd597ba881dd3c9721bef47ad"}}}